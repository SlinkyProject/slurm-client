// Package v0043 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package v0043

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	TokenScopes      = "token.Scopes"
	UserScopes       = "user.Scopes"
)

// Defines values for V0043AccountFlags.
const (
	V0043AccountFlagsDELETED          V0043AccountFlags = "DELETED"
	V0043AccountFlagsNoUsersAreCoords V0043AccountFlags = "NoUsersAreCoords"
	V0043AccountFlagsUsersAreCoords   V0043AccountFlags = "UsersAreCoords"
	V0043AccountFlagsWithAssociations V0043AccountFlags = "WithAssociations"
	V0043AccountFlagsWithCoordinators V0043AccountFlags = "WithCoordinators"
)

// Defines values for V0043AssocFlags.
const (
	V0043AssocFlagsDELETED          V0043AssocFlags = "DELETED"
	V0043AssocFlagsExact            V0043AssocFlags = "Exact"
	V0043AssocFlagsNoUpdate         V0043AssocFlags = "NoUpdate"
	V0043AssocFlagsNoUsersAreCoords V0043AssocFlags = "NoUsersAreCoords"
	V0043AssocFlagsUsersAreCoords   V0043AssocFlags = "UsersAreCoords"
)

// Defines values for V0043AssocSharesObjWrapType.
const (
	ASSOCIATION V0043AssocSharesObjWrapType = "ASSOCIATION"
	USER        V0043AssocSharesObjWrapType = "USER"
)

// Defines values for V0043ClusterRecFlags.
const (
	V0043ClusterRecFlagsDELETED        V0043ClusterRecFlags = "DELETED"
	V0043ClusterRecFlagsEXTERNAL       V0043ClusterRecFlags = "EXTERNAL"
	V0043ClusterRecFlagsFEDERATION     V0043ClusterRecFlags = "FEDERATION"
	V0043ClusterRecFlagsMULTIPLESLURMD V0043ClusterRecFlags = "MULTIPLE_SLURMD"
	V0043ClusterRecFlagsREGISTERING    V0043ClusterRecFlags = "REGISTERING"
)

// Defines values for V0043CronEntryFlags.
const (
	WILDDAYOFMONTH V0043CronEntryFlags = "WILD_DAY_OF_MONTH"
	WILDDAYOFWEEK  V0043CronEntryFlags = "WILD_DAY_OF_WEEK"
	WILDHOUR       V0043CronEntryFlags = "WILD_HOUR"
	WILDMINUTE     V0043CronEntryFlags = "WILD_MINUTE"
	WILDMONTH      V0043CronEntryFlags = "WILD_MONTH"
)

// Defines values for V0043JobFlags.
const (
	V0043JobFlagsCLEARSCHEDULING   V0043JobFlags = "CLEAR_SCHEDULING"
	V0043JobFlagsNONE              V0043JobFlags = "NONE"
	V0043JobFlagsNOTSET            V0043JobFlags = "NOT_SET"
	V0043JobFlagsSTARTEDONBACKFILL V0043JobFlags = "STARTED_ON_BACKFILL"
	V0043JobFlagsSTARTEDONSCHEDULE V0043JobFlags = "STARTED_ON_SCHEDULE"
	V0043JobFlagsSTARTEDONSUBMIT   V0043JobFlags = "STARTED_ON_SUBMIT"
	V0043JobFlagsSTARTRECEIVED     V0043JobFlags = "START_RECEIVED"
)

// Defines values for V0043JobStateCurrent.
const (
	V0043JobStateCurrentBOOTFAIL     V0043JobStateCurrent = "BOOT_FAIL"
	V0043JobStateCurrentCANCELLED    V0043JobStateCurrent = "CANCELLED"
	V0043JobStateCurrentCOMPLETED    V0043JobStateCurrent = "COMPLETED"
	V0043JobStateCurrentCOMPLETING   V0043JobStateCurrent = "COMPLETING"
	V0043JobStateCurrentCONFIGURING  V0043JobStateCurrent = "CONFIGURING"
	V0043JobStateCurrentDEADLINE     V0043JobStateCurrent = "DEADLINE"
	V0043JobStateCurrentFAILED       V0043JobStateCurrent = "FAILED"
	V0043JobStateCurrentLAUNCHFAILED V0043JobStateCurrent = "LAUNCH_FAILED"
	V0043JobStateCurrentNODEFAIL     V0043JobStateCurrent = "NODE_FAIL"
	V0043JobStateCurrentOUTOFMEMORY  V0043JobStateCurrent = "OUT_OF_MEMORY"
	V0043JobStateCurrentPENDING      V0043JobStateCurrent = "PENDING"
	V0043JobStateCurrentPOWERUPNODE  V0043JobStateCurrent = "POWER_UP_NODE"
	V0043JobStateCurrentPREEMPTED    V0043JobStateCurrent = "PREEMPTED"
	V0043JobStateCurrentRECONFIGFAIL V0043JobStateCurrent = "RECONFIG_FAIL"
	V0043JobStateCurrentREQUEUED     V0043JobStateCurrent = "REQUEUED"
	V0043JobStateCurrentREQUEUEFED   V0043JobStateCurrent = "REQUEUE_FED"
	V0043JobStateCurrentREQUEUEHOLD  V0043JobStateCurrent = "REQUEUE_HOLD"
	V0043JobStateCurrentRESIZING     V0043JobStateCurrent = "RESIZING"
	V0043JobStateCurrentRESVDELHOLD  V0043JobStateCurrent = "RESV_DEL_HOLD"
	V0043JobStateCurrentREVOKED      V0043JobStateCurrent = "REVOKED"
	V0043JobStateCurrentRUNNING      V0043JobStateCurrent = "RUNNING"
	V0043JobStateCurrentSIGNALING    V0043JobStateCurrent = "SIGNALING"
	V0043JobStateCurrentSPECIALEXIT  V0043JobStateCurrent = "SPECIAL_EXIT"
	V0043JobStateCurrentSTAGEOUT     V0043JobStateCurrent = "STAGE_OUT"
	V0043JobStateCurrentSTOPPED      V0043JobStateCurrent = "STOPPED"
	V0043JobStateCurrentSUSPENDED    V0043JobStateCurrent = "SUSPENDED"
	V0043JobStateCurrentTIMEOUT      V0043JobStateCurrent = "TIMEOUT"
)

// Defines values for V0043JobDescMsgCpuBindingFlags.
const (
	V0043JobDescMsgCpuBindingFlagsCPUBINDLDMAP            V0043JobDescMsgCpuBindingFlags = "CPU_BIND_LDMAP"
	V0043JobDescMsgCpuBindingFlagsCPUBINDLDMASK           V0043JobDescMsgCpuBindingFlags = "CPU_BIND_LDMASK"
	V0043JobDescMsgCpuBindingFlagsCPUBINDLDRANK           V0043JobDescMsgCpuBindingFlags = "CPU_BIND_LDRANK"
	V0043JobDescMsgCpuBindingFlagsCPUBINDMAP              V0043JobDescMsgCpuBindingFlags = "CPU_BIND_MAP"
	V0043JobDescMsgCpuBindingFlagsCPUBINDMASK             V0043JobDescMsgCpuBindingFlags = "CPU_BIND_MASK"
	V0043JobDescMsgCpuBindingFlagsCPUBINDNONE             V0043JobDescMsgCpuBindingFlags = "CPU_BIND_NONE"
	V0043JobDescMsgCpuBindingFlagsCPUBINDONETHREADPERCORE V0043JobDescMsgCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	V0043JobDescMsgCpuBindingFlagsCPUBINDRANK             V0043JobDescMsgCpuBindingFlags = "CPU_BIND_RANK"
	V0043JobDescMsgCpuBindingFlagsCPUBINDTOCORES          V0043JobDescMsgCpuBindingFlags = "CPU_BIND_TO_CORES"
	V0043JobDescMsgCpuBindingFlagsCPUBINDTOLDOMS          V0043JobDescMsgCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	V0043JobDescMsgCpuBindingFlagsCPUBINDTOSOCKETS        V0043JobDescMsgCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	V0043JobDescMsgCpuBindingFlagsCPUBINDTOTHREADS        V0043JobDescMsgCpuBindingFlags = "CPU_BIND_TO_THREADS"
	V0043JobDescMsgCpuBindingFlagsVERBOSE                 V0043JobDescMsgCpuBindingFlags = "VERBOSE"
)

// Defines values for V0043JobDescMsgFlags.
const (
	V0043JobDescMsgFlagsACCRUECOUNTCLEARED       V0043JobDescMsgFlags = "ACCRUE_COUNT_CLEARED"
	V0043JobDescMsgFlagsBACKFILLATTEMPTED        V0043JobDescMsgFlags = "BACKFILL_ATTEMPTED"
	V0043JobDescMsgFlagsCRONJOB                  V0043JobDescMsgFlags = "CRON_JOB"
	V0043JobDescMsgFlagsDEPENDENT                V0043JobDescMsgFlags = "DEPENDENT"
	V0043JobDescMsgFlagsEXACTCPUCOUNTREQUESTED   V0043JobDescMsgFlags = "EXACT_CPU_COUNT_REQUESTED"
	V0043JobDescMsgFlagsEXACTMEMORYREQUESTED     V0043JobDescMsgFlags = "EXACT_MEMORY_REQUESTED"
	V0043JobDescMsgFlagsEXACTTASKCOUNTREQUESTED  V0043JobDescMsgFlags = "EXACT_TASK_COUNT_REQUESTED"
	V0043JobDescMsgFlagsEXTERNALJOB              V0043JobDescMsgFlags = "EXTERNAL_JOB"
	V0043JobDescMsgFlagsGRESBINDINGDISABLED      V0043JobDescMsgFlags = "GRES_BINDING_DISABLED"
	V0043JobDescMsgFlagsGRESBINDINGENFORCED      V0043JobDescMsgFlags = "GRES_BINDING_ENFORCED"
	V0043JobDescMsgFlagsHASSTATEDIRECTORY        V0043JobDescMsgFlags = "HAS_STATE_DIRECTORY"
	V0043JobDescMsgFlagsHETEROGENEOUSJOB         V0043JobDescMsgFlags = "HETEROGENEOUS_JOB"
	V0043JobDescMsgFlagsJOBACCRUETIMERESET       V0043JobDescMsgFlags = "JOB_ACCRUE_TIME_RESET"
	V0043JobDescMsgFlagsJOBKILLHURRY             V0043JobDescMsgFlags = "JOB_KILL_HURRY"
	V0043JobDescMsgFlagsJOBWASRUNNING            V0043JobDescMsgFlags = "JOB_WAS_RUNNING"
	V0043JobDescMsgFlagsKILLINVALIDDEPENDENCY    V0043JobDescMsgFlags = "KILL_INVALID_DEPENDENCY"
	V0043JobDescMsgFlagsMAGNETIC                 V0043JobDescMsgFlags = "MAGNETIC"
	V0043JobDescMsgFlagsNOKILLINVALIDDEPENDENCY  V0043JobDescMsgFlags = "NO_KILL_INVALID_DEPENDENCY"
	V0043JobDescMsgFlagsPARTITIONASSIGNED        V0043JobDescMsgFlags = "PARTITION_ASSIGNED"
	V0043JobDescMsgFlagsPREFERMINIMUMNODECOUNT   V0043JobDescMsgFlags = "PREFER_MINIMUM_NODE_COUNT"
	V0043JobDescMsgFlagsSCHEDULINGATTEMPTED      V0043JobDescMsgFlags = "SCHEDULING_ATTEMPTED"
	V0043JobDescMsgFlagsSENDJOBENVIRONMENT       V0043JobDescMsgFlags = "SEND_JOB_ENVIRONMENT"
	V0043JobDescMsgFlagsSIBLINGCLUSTERUPDATEONLY V0043JobDescMsgFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	V0043JobDescMsgFlagsSKIPTRESSTRINGACCOUNTING V0043JobDescMsgFlags = "SKIP_TRES_STRING_ACCOUNTING"
	V0043JobDescMsgFlagsSPREADJOB                V0043JobDescMsgFlags = "SPREAD_JOB"
	V0043JobDescMsgFlagsSTEPMGRENABLED           V0043JobDescMsgFlags = "STEPMGR_ENABLED"
	V0043JobDescMsgFlagsTESTINGBACKFILL          V0043JobDescMsgFlags = "TESTING_BACKFILL"
	V0043JobDescMsgFlagsTESTINGWHOLENODEBACKFILL V0043JobDescMsgFlags = "TESTING_WHOLE_NODE_BACKFILL"
	V0043JobDescMsgFlagsTESTNOWONLY              V0043JobDescMsgFlags = "TEST_NOW_ONLY"
	V0043JobDescMsgFlagsTOPPRIORITYJOB           V0043JobDescMsgFlags = "TOP_PRIORITY_JOB"
	V0043JobDescMsgFlagsUSINGDEFAULTACCOUNT      V0043JobDescMsgFlags = "USING_DEFAULT_ACCOUNT"
	V0043JobDescMsgFlagsUSINGDEFAULTPARTITION    V0043JobDescMsgFlags = "USING_DEFAULT_PARTITION"
	V0043JobDescMsgFlagsUSINGDEFAULTQOS          V0043JobDescMsgFlags = "USING_DEFAULT_QOS"
	V0043JobDescMsgFlagsUSINGDEFAULTWCKEY        V0043JobDescMsgFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for V0043JobDescMsgKillWarningFlags.
const (
	V0043JobDescMsgKillWarningFlagsARRAYTASK         V0043JobDescMsgKillWarningFlags = "ARRAY_TASK"
	V0043JobDescMsgKillWarningFlagsBATCHJOB          V0043JobDescMsgKillWarningFlags = "BATCH_JOB"
	V0043JobDescMsgKillWarningFlagsCRONJOBS          V0043JobDescMsgKillWarningFlags = "CRON_JOBS"
	V0043JobDescMsgKillWarningFlagsFEDERATIONREQUEUE V0043JobDescMsgKillWarningFlags = "FEDERATION_REQUEUE"
	V0043JobDescMsgKillWarningFlagsFULLJOB           V0043JobDescMsgKillWarningFlags = "FULL_JOB"
	V0043JobDescMsgKillWarningFlagsFULLSTEPSONLY     V0043JobDescMsgKillWarningFlags = "FULL_STEPS_ONLY"
	V0043JobDescMsgKillWarningFlagsHURRY             V0043JobDescMsgKillWarningFlags = "HURRY"
	V0043JobDescMsgKillWarningFlagsNOSIBLINGJOBS     V0043JobDescMsgKillWarningFlags = "NO_SIBLING_JOBS"
	V0043JobDescMsgKillWarningFlagsOUTOFMEMORY       V0043JobDescMsgKillWarningFlags = "OUT_OF_MEMORY"
	V0043JobDescMsgKillWarningFlagsRESERVATIONJOB    V0043JobDescMsgKillWarningFlags = "RESERVATION_JOB"
	V0043JobDescMsgKillWarningFlagsVERBOSE           V0043JobDescMsgKillWarningFlags = "VERBOSE"
	V0043JobDescMsgKillWarningFlagsWARNINGSENT       V0043JobDescMsgKillWarningFlags = "WARNING_SENT"
)

// Defines values for V0043JobDescMsgMailType.
const (
	V0043JobDescMsgMailTypeARRAYTASKS        V0043JobDescMsgMailType = "ARRAY_TASKS"
	V0043JobDescMsgMailTypeBEGIN             V0043JobDescMsgMailType = "BEGIN"
	V0043JobDescMsgMailTypeEND               V0043JobDescMsgMailType = "END"
	V0043JobDescMsgMailTypeFAIL              V0043JobDescMsgMailType = "FAIL"
	V0043JobDescMsgMailTypeINVALIDDEPENDENCY V0043JobDescMsgMailType = "INVALID_DEPENDENCY"
	V0043JobDescMsgMailTypeREQUEUE           V0043JobDescMsgMailType = "REQUEUE"
	V0043JobDescMsgMailTypeSTAGEOUT          V0043JobDescMsgMailType = "STAGE_OUT"
	V0043JobDescMsgMailTypeTIME100           V0043JobDescMsgMailType = "TIME=100%"
	V0043JobDescMsgMailTypeTIME50            V0043JobDescMsgMailType = "TIME=50%"
	V0043JobDescMsgMailTypeTIME80            V0043JobDescMsgMailType = "TIME=80%"
	V0043JobDescMsgMailTypeTIME90            V0043JobDescMsgMailType = "TIME=90%"
)

// Defines values for V0043JobDescMsgMemoryBindingType.
const (
	V0043JobDescMsgMemoryBindingTypeLOCAL   V0043JobDescMsgMemoryBindingType = "LOCAL"
	V0043JobDescMsgMemoryBindingTypeMAP     V0043JobDescMsgMemoryBindingType = "MAP"
	V0043JobDescMsgMemoryBindingTypeMASK    V0043JobDescMsgMemoryBindingType = "MASK"
	V0043JobDescMsgMemoryBindingTypeNONE    V0043JobDescMsgMemoryBindingType = "NONE"
	V0043JobDescMsgMemoryBindingTypePREFER  V0043JobDescMsgMemoryBindingType = "PREFER"
	V0043JobDescMsgMemoryBindingTypeRANK    V0043JobDescMsgMemoryBindingType = "RANK"
	V0043JobDescMsgMemoryBindingTypeSORT    V0043JobDescMsgMemoryBindingType = "SORT"
	V0043JobDescMsgMemoryBindingTypeVERBOSE V0043JobDescMsgMemoryBindingType = "VERBOSE"
)

// Defines values for V0043JobDescMsgOpenMode.
const (
	APPEND   V0043JobDescMsgOpenMode = "APPEND"
	TRUNCATE V0043JobDescMsgOpenMode = "TRUNCATE"
)

// Defines values for V0043JobDescMsgProfile.
const (
	V0043JobDescMsgProfileENERGY  V0043JobDescMsgProfile = "ENERGY"
	V0043JobDescMsgProfileLUSTRE  V0043JobDescMsgProfile = "LUSTRE"
	V0043JobDescMsgProfileNETWORK V0043JobDescMsgProfile = "NETWORK"
	V0043JobDescMsgProfileNONE    V0043JobDescMsgProfile = "NONE"
	V0043JobDescMsgProfileNOTSET  V0043JobDescMsgProfile = "NOT_SET"
	V0043JobDescMsgProfileTASK    V0043JobDescMsgProfile = "TASK"
)

// Defines values for V0043JobDescMsgShared.
const (
	V0043JobDescMsgSharedMcs           V0043JobDescMsgShared = "mcs"
	V0043JobDescMsgSharedNone          V0043JobDescMsgShared = "none"
	V0043JobDescMsgSharedOversubscribe V0043JobDescMsgShared = "oversubscribe"
	V0043JobDescMsgSharedTopo          V0043JobDescMsgShared = "topo"
	V0043JobDescMsgSharedUser          V0043JobDescMsgShared = "user"
)

// Defines values for V0043JobDescMsgX11.
const (
	BATCHNODE       V0043JobDescMsgX11 = "BATCH_NODE"
	FIRSTNODE       V0043JobDescMsgX11 = "FIRST_NODE"
	FORWARDALLNODES V0043JobDescMsgX11 = "FORWARD_ALL_NODES"
	LASTNODE        V0043JobDescMsgX11 = "LAST_NODE"
)

// Defines values for V0043JobInfoFlags.
const (
	V0043JobInfoFlagsACCRUECOUNTCLEARED       V0043JobInfoFlags = "ACCRUE_COUNT_CLEARED"
	V0043JobInfoFlagsBACKFILLATTEMPTED        V0043JobInfoFlags = "BACKFILL_ATTEMPTED"
	V0043JobInfoFlagsCRONJOB                  V0043JobInfoFlags = "CRON_JOB"
	V0043JobInfoFlagsDEPENDENT                V0043JobInfoFlags = "DEPENDENT"
	V0043JobInfoFlagsEXACTCPUCOUNTREQUESTED   V0043JobInfoFlags = "EXACT_CPU_COUNT_REQUESTED"
	V0043JobInfoFlagsEXACTMEMORYREQUESTED     V0043JobInfoFlags = "EXACT_MEMORY_REQUESTED"
	V0043JobInfoFlagsEXACTTASKCOUNTREQUESTED  V0043JobInfoFlags = "EXACT_TASK_COUNT_REQUESTED"
	V0043JobInfoFlagsEXTERNALJOB              V0043JobInfoFlags = "EXTERNAL_JOB"
	V0043JobInfoFlagsGRESBINDINGDISABLED      V0043JobInfoFlags = "GRES_BINDING_DISABLED"
	V0043JobInfoFlagsGRESBINDINGENFORCED      V0043JobInfoFlags = "GRES_BINDING_ENFORCED"
	V0043JobInfoFlagsHASSTATEDIRECTORY        V0043JobInfoFlags = "HAS_STATE_DIRECTORY"
	V0043JobInfoFlagsHETEROGENEOUSJOB         V0043JobInfoFlags = "HETEROGENEOUS_JOB"
	V0043JobInfoFlagsJOBACCRUETIMERESET       V0043JobInfoFlags = "JOB_ACCRUE_TIME_RESET"
	V0043JobInfoFlagsJOBKILLHURRY             V0043JobInfoFlags = "JOB_KILL_HURRY"
	V0043JobInfoFlagsJOBWASRUNNING            V0043JobInfoFlags = "JOB_WAS_RUNNING"
	V0043JobInfoFlagsKILLINVALIDDEPENDENCY    V0043JobInfoFlags = "KILL_INVALID_DEPENDENCY"
	V0043JobInfoFlagsMAGNETIC                 V0043JobInfoFlags = "MAGNETIC"
	V0043JobInfoFlagsNOKILLINVALIDDEPENDENCY  V0043JobInfoFlags = "NO_KILL_INVALID_DEPENDENCY"
	V0043JobInfoFlagsPARTITIONASSIGNED        V0043JobInfoFlags = "PARTITION_ASSIGNED"
	V0043JobInfoFlagsPREFERMINIMUMNODECOUNT   V0043JobInfoFlags = "PREFER_MINIMUM_NODE_COUNT"
	V0043JobInfoFlagsSCHEDULINGATTEMPTED      V0043JobInfoFlags = "SCHEDULING_ATTEMPTED"
	V0043JobInfoFlagsSENDJOBENVIRONMENT       V0043JobInfoFlags = "SEND_JOB_ENVIRONMENT"
	V0043JobInfoFlagsSIBLINGCLUSTERUPDATEONLY V0043JobInfoFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	V0043JobInfoFlagsSKIPTRESSTRINGACCOUNTING V0043JobInfoFlags = "SKIP_TRES_STRING_ACCOUNTING"
	V0043JobInfoFlagsSPREADJOB                V0043JobInfoFlags = "SPREAD_JOB"
	V0043JobInfoFlagsSTEPMGRENABLED           V0043JobInfoFlags = "STEPMGR_ENABLED"
	V0043JobInfoFlagsTESTINGBACKFILL          V0043JobInfoFlags = "TESTING_BACKFILL"
	V0043JobInfoFlagsTESTINGWHOLENODEBACKFILL V0043JobInfoFlags = "TESTING_WHOLE_NODE_BACKFILL"
	V0043JobInfoFlagsTESTNOWONLY              V0043JobInfoFlags = "TEST_NOW_ONLY"
	V0043JobInfoFlagsTOPPRIORITYJOB           V0043JobInfoFlags = "TOP_PRIORITY_JOB"
	V0043JobInfoFlagsUSINGDEFAULTACCOUNT      V0043JobInfoFlags = "USING_DEFAULT_ACCOUNT"
	V0043JobInfoFlagsUSINGDEFAULTPARTITION    V0043JobInfoFlags = "USING_DEFAULT_PARTITION"
	V0043JobInfoFlagsUSINGDEFAULTQOS          V0043JobInfoFlags = "USING_DEFAULT_QOS"
	V0043JobInfoFlagsUSINGDEFAULTWCKEY        V0043JobInfoFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for V0043JobInfoJobState.
const (
	V0043JobInfoJobStateBOOTFAIL     V0043JobInfoJobState = "BOOT_FAIL"
	V0043JobInfoJobStateCANCELLED    V0043JobInfoJobState = "CANCELLED"
	V0043JobInfoJobStateCOMPLETED    V0043JobInfoJobState = "COMPLETED"
	V0043JobInfoJobStateCOMPLETING   V0043JobInfoJobState = "COMPLETING"
	V0043JobInfoJobStateCONFIGURING  V0043JobInfoJobState = "CONFIGURING"
	V0043JobInfoJobStateDEADLINE     V0043JobInfoJobState = "DEADLINE"
	V0043JobInfoJobStateFAILED       V0043JobInfoJobState = "FAILED"
	V0043JobInfoJobStateLAUNCHFAILED V0043JobInfoJobState = "LAUNCH_FAILED"
	V0043JobInfoJobStateNODEFAIL     V0043JobInfoJobState = "NODE_FAIL"
	V0043JobInfoJobStateOUTOFMEMORY  V0043JobInfoJobState = "OUT_OF_MEMORY"
	V0043JobInfoJobStatePENDING      V0043JobInfoJobState = "PENDING"
	V0043JobInfoJobStatePOWERUPNODE  V0043JobInfoJobState = "POWER_UP_NODE"
	V0043JobInfoJobStatePREEMPTED    V0043JobInfoJobState = "PREEMPTED"
	V0043JobInfoJobStateRECONFIGFAIL V0043JobInfoJobState = "RECONFIG_FAIL"
	V0043JobInfoJobStateREQUEUED     V0043JobInfoJobState = "REQUEUED"
	V0043JobInfoJobStateREQUEUEFED   V0043JobInfoJobState = "REQUEUE_FED"
	V0043JobInfoJobStateREQUEUEHOLD  V0043JobInfoJobState = "REQUEUE_HOLD"
	V0043JobInfoJobStateRESIZING     V0043JobInfoJobState = "RESIZING"
	V0043JobInfoJobStateRESVDELHOLD  V0043JobInfoJobState = "RESV_DEL_HOLD"
	V0043JobInfoJobStateREVOKED      V0043JobInfoJobState = "REVOKED"
	V0043JobInfoJobStateRUNNING      V0043JobInfoJobState = "RUNNING"
	V0043JobInfoJobStateSIGNALING    V0043JobInfoJobState = "SIGNALING"
	V0043JobInfoJobStateSPECIALEXIT  V0043JobInfoJobState = "SPECIAL_EXIT"
	V0043JobInfoJobStateSTAGEOUT     V0043JobInfoJobState = "STAGE_OUT"
	V0043JobInfoJobStateSTOPPED      V0043JobInfoJobState = "STOPPED"
	V0043JobInfoJobStateSUSPENDED    V0043JobInfoJobState = "SUSPENDED"
	V0043JobInfoJobStateTIMEOUT      V0043JobInfoJobState = "TIMEOUT"
)

// Defines values for V0043JobInfoMailType.
const (
	V0043JobInfoMailTypeARRAYTASKS        V0043JobInfoMailType = "ARRAY_TASKS"
	V0043JobInfoMailTypeBEGIN             V0043JobInfoMailType = "BEGIN"
	V0043JobInfoMailTypeEND               V0043JobInfoMailType = "END"
	V0043JobInfoMailTypeFAIL              V0043JobInfoMailType = "FAIL"
	V0043JobInfoMailTypeINVALIDDEPENDENCY V0043JobInfoMailType = "INVALID_DEPENDENCY"
	V0043JobInfoMailTypeREQUEUE           V0043JobInfoMailType = "REQUEUE"
	V0043JobInfoMailTypeSTAGEOUT          V0043JobInfoMailType = "STAGE_OUT"
	V0043JobInfoMailTypeTIME100           V0043JobInfoMailType = "TIME=100%"
	V0043JobInfoMailTypeTIME50            V0043JobInfoMailType = "TIME=50%"
	V0043JobInfoMailTypeTIME80            V0043JobInfoMailType = "TIME=80%"
	V0043JobInfoMailTypeTIME90            V0043JobInfoMailType = "TIME=90%"
)

// Defines values for V0043JobInfoProfile.
const (
	V0043JobInfoProfileENERGY  V0043JobInfoProfile = "ENERGY"
	V0043JobInfoProfileLUSTRE  V0043JobInfoProfile = "LUSTRE"
	V0043JobInfoProfileNETWORK V0043JobInfoProfile = "NETWORK"
	V0043JobInfoProfileNONE    V0043JobInfoProfile = "NONE"
	V0043JobInfoProfileNOTSET  V0043JobInfoProfile = "NOT_SET"
	V0043JobInfoProfileTASK    V0043JobInfoProfile = "TASK"
)

// Defines values for V0043JobInfoShared.
const (
	V0043JobInfoSharedMcs           V0043JobInfoShared = "mcs"
	V0043JobInfoSharedNone          V0043JobInfoShared = "none"
	V0043JobInfoSharedOversubscribe V0043JobInfoShared = "oversubscribe"
	V0043JobInfoSharedTopo          V0043JobInfoShared = "topo"
	V0043JobInfoSharedUser          V0043JobInfoShared = "user"
)

// Defines values for V0043JobResNodesSelectType.
const (
	V0043JobResNodesSelectTypeAVAILABLE V0043JobResNodesSelectType = "AVAILABLE"
	V0043JobResNodesSelectTypeONEROW    V0043JobResNodesSelectType = "ONE_ROW"
	V0043JobResNodesSelectTypeRESERVED  V0043JobResNodesSelectType = "RESERVED"
)

// Defines values for V0043JobResSelectType.
const (
	V0043JobResSelectTypeBOARD                V0043JobResSelectType = "BOARD"
	V0043JobResSelectTypeCORE                 V0043JobResSelectType = "CORE"
	V0043JobResSelectTypeCOREDEFAULTDISTBLOCK V0043JobResSelectType = "CORE_DEFAULT_DIST_BLOCK"
	V0043JobResSelectTypeCPU                  V0043JobResSelectType = "CPU"
	V0043JobResSelectTypeLINEAR               V0043JobResSelectType = "LINEAR"
	V0043JobResSelectTypeLLN                  V0043JobResSelectType = "LLN"
	V0043JobResSelectTypeMEMORY               V0043JobResSelectType = "MEMORY"
	V0043JobResSelectTypeONETASKPERCORE       V0043JobResSelectType = "ONE_TASK_PER_CORE"
	V0043JobResSelectTypePACKNODES            V0043JobResSelectType = "PACK_NODES"
	V0043JobResSelectTypeSOCKET               V0043JobResSelectType = "SOCKET"
)

// Defines values for V0043JobResCoreStatus.
const (
	V0043JobResCoreStatusALLOCATED   V0043JobResCoreStatus = "ALLOCATED"
	V0043JobResCoreStatusINUSE       V0043JobResCoreStatus = "IN_USE"
	V0043JobResCoreStatusINVALID     V0043JobResCoreStatus = "INVALID"
	V0043JobResCoreStatusUNALLOCATED V0043JobResCoreStatus = "UNALLOCATED"
)

// Defines values for V0043KillJobsMsgFlags.
const (
	V0043KillJobsMsgFlagsARRAYTASK         V0043KillJobsMsgFlags = "ARRAY_TASK"
	V0043KillJobsMsgFlagsBATCHJOB          V0043KillJobsMsgFlags = "BATCH_JOB"
	V0043KillJobsMsgFlagsCRONJOBS          V0043KillJobsMsgFlags = "CRON_JOBS"
	V0043KillJobsMsgFlagsFEDERATIONREQUEUE V0043KillJobsMsgFlags = "FEDERATION_REQUEUE"
	V0043KillJobsMsgFlagsFULLJOB           V0043KillJobsMsgFlags = "FULL_JOB"
	V0043KillJobsMsgFlagsFULLSTEPSONLY     V0043KillJobsMsgFlags = "FULL_STEPS_ONLY"
	V0043KillJobsMsgFlagsHURRY             V0043KillJobsMsgFlags = "HURRY"
	V0043KillJobsMsgFlagsNOSIBLINGJOBS     V0043KillJobsMsgFlags = "NO_SIBLING_JOBS"
	V0043KillJobsMsgFlagsOUTOFMEMORY       V0043KillJobsMsgFlags = "OUT_OF_MEMORY"
	V0043KillJobsMsgFlagsRESERVATIONJOB    V0043KillJobsMsgFlags = "RESERVATION_JOB"
	V0043KillJobsMsgFlagsVERBOSE           V0043KillJobsMsgFlags = "VERBOSE"
	V0043KillJobsMsgFlagsWARNINGSENT       V0043KillJobsMsgFlags = "WARNING_SENT"
)

// Defines values for V0043KillJobsMsgJobState.
const (
	V0043KillJobsMsgJobStateBOOTFAIL     V0043KillJobsMsgJobState = "BOOT_FAIL"
	V0043KillJobsMsgJobStateCANCELLED    V0043KillJobsMsgJobState = "CANCELLED"
	V0043KillJobsMsgJobStateCOMPLETED    V0043KillJobsMsgJobState = "COMPLETED"
	V0043KillJobsMsgJobStateCOMPLETING   V0043KillJobsMsgJobState = "COMPLETING"
	V0043KillJobsMsgJobStateCONFIGURING  V0043KillJobsMsgJobState = "CONFIGURING"
	V0043KillJobsMsgJobStateDEADLINE     V0043KillJobsMsgJobState = "DEADLINE"
	V0043KillJobsMsgJobStateFAILED       V0043KillJobsMsgJobState = "FAILED"
	V0043KillJobsMsgJobStateLAUNCHFAILED V0043KillJobsMsgJobState = "LAUNCH_FAILED"
	V0043KillJobsMsgJobStateNODEFAIL     V0043KillJobsMsgJobState = "NODE_FAIL"
	V0043KillJobsMsgJobStateOUTOFMEMORY  V0043KillJobsMsgJobState = "OUT_OF_MEMORY"
	V0043KillJobsMsgJobStatePENDING      V0043KillJobsMsgJobState = "PENDING"
	V0043KillJobsMsgJobStatePOWERUPNODE  V0043KillJobsMsgJobState = "POWER_UP_NODE"
	V0043KillJobsMsgJobStatePREEMPTED    V0043KillJobsMsgJobState = "PREEMPTED"
	V0043KillJobsMsgJobStateRECONFIGFAIL V0043KillJobsMsgJobState = "RECONFIG_FAIL"
	V0043KillJobsMsgJobStateREQUEUED     V0043KillJobsMsgJobState = "REQUEUED"
	V0043KillJobsMsgJobStateREQUEUEFED   V0043KillJobsMsgJobState = "REQUEUE_FED"
	V0043KillJobsMsgJobStateREQUEUEHOLD  V0043KillJobsMsgJobState = "REQUEUE_HOLD"
	V0043KillJobsMsgJobStateRESIZING     V0043KillJobsMsgJobState = "RESIZING"
	V0043KillJobsMsgJobStateRESVDELHOLD  V0043KillJobsMsgJobState = "RESV_DEL_HOLD"
	V0043KillJobsMsgJobStateREVOKED      V0043KillJobsMsgJobState = "REVOKED"
	V0043KillJobsMsgJobStateRUNNING      V0043KillJobsMsgJobState = "RUNNING"
	V0043KillJobsMsgJobStateSIGNALING    V0043KillJobsMsgJobState = "SIGNALING"
	V0043KillJobsMsgJobStateSPECIALEXIT  V0043KillJobsMsgJobState = "SPECIAL_EXIT"
	V0043KillJobsMsgJobStateSTAGEOUT     V0043KillJobsMsgJobState = "STAGE_OUT"
	V0043KillJobsMsgJobStateSTOPPED      V0043KillJobsMsgJobState = "STOPPED"
	V0043KillJobsMsgJobStateSUSPENDED    V0043KillJobsMsgJobState = "SUSPENDED"
	V0043KillJobsMsgJobStateTIMEOUT      V0043KillJobsMsgJobState = "TIMEOUT"
)

// Defines values for V0043NodeCertFlags.
const (
	TOKENSET V0043NodeCertFlags = "TOKEN_SET"
)

// Defines values for V0043NodeNextStateAfterReboot.
const (
	V0043NodeNextStateAfterRebootALLOCATED       V0043NodeNextStateAfterReboot = "ALLOCATED"
	V0043NodeNextStateAfterRebootCLOUD           V0043NodeNextStateAfterReboot = "CLOUD"
	V0043NodeNextStateAfterRebootCOMPLETING      V0043NodeNextStateAfterReboot = "COMPLETING"
	V0043NodeNextStateAfterRebootDOWN            V0043NodeNextStateAfterReboot = "DOWN"
	V0043NodeNextStateAfterRebootDRAIN           V0043NodeNextStateAfterReboot = "DRAIN"
	V0043NodeNextStateAfterRebootDYNAMICFUTURE   V0043NodeNextStateAfterReboot = "DYNAMIC_FUTURE"
	V0043NodeNextStateAfterRebootDYNAMICNORM     V0043NodeNextStateAfterReboot = "DYNAMIC_NORM"
	V0043NodeNextStateAfterRebootERROR           V0043NodeNextStateAfterReboot = "ERROR"
	V0043NodeNextStateAfterRebootFAIL            V0043NodeNextStateAfterReboot = "FAIL"
	V0043NodeNextStateAfterRebootFUTURE          V0043NodeNextStateAfterReboot = "FUTURE"
	V0043NodeNextStateAfterRebootIDLE            V0043NodeNextStateAfterReboot = "IDLE"
	V0043NodeNextStateAfterRebootINVALID         V0043NodeNextStateAfterReboot = "INVALID"
	V0043NodeNextStateAfterRebootINVALIDREG      V0043NodeNextStateAfterReboot = "INVALID_REG"
	V0043NodeNextStateAfterRebootMAINTENANCE     V0043NodeNextStateAfterReboot = "MAINTENANCE"
	V0043NodeNextStateAfterRebootMIXED           V0043NodeNextStateAfterReboot = "MIXED"
	V0043NodeNextStateAfterRebootNOTRESPONDING   V0043NodeNextStateAfterReboot = "NOT_RESPONDING"
	V0043NodeNextStateAfterRebootPLANNED         V0043NodeNextStateAfterReboot = "PLANNED"
	V0043NodeNextStateAfterRebootPOWERDOWN       V0043NodeNextStateAfterReboot = "POWER_DOWN"
	V0043NodeNextStateAfterRebootPOWERDRAIN      V0043NodeNextStateAfterReboot = "POWER_DRAIN"
	V0043NodeNextStateAfterRebootPOWEREDDOWN     V0043NodeNextStateAfterReboot = "POWERED_DOWN"
	V0043NodeNextStateAfterRebootPOWERINGDOWN    V0043NodeNextStateAfterReboot = "POWERING_DOWN"
	V0043NodeNextStateAfterRebootPOWERINGUP      V0043NodeNextStateAfterReboot = "POWERING_UP"
	V0043NodeNextStateAfterRebootPOWERUP         V0043NodeNextStateAfterReboot = "POWER_UP"
	V0043NodeNextStateAfterRebootREBOOTCANCELED  V0043NodeNextStateAfterReboot = "REBOOT_CANCELED"
	V0043NodeNextStateAfterRebootREBOOTISSUED    V0043NodeNextStateAfterReboot = "REBOOT_ISSUED"
	V0043NodeNextStateAfterRebootREBOOTREQUESTED V0043NodeNextStateAfterReboot = "REBOOT_REQUESTED"
	V0043NodeNextStateAfterRebootRESERVED        V0043NodeNextStateAfterReboot = "RESERVED"
	V0043NodeNextStateAfterRebootRESUME          V0043NodeNextStateAfterReboot = "RESUME"
	V0043NodeNextStateAfterRebootUNDRAIN         V0043NodeNextStateAfterReboot = "UNDRAIN"
	V0043NodeNextStateAfterRebootUNKNOWN         V0043NodeNextStateAfterReboot = "UNKNOWN"
)

// Defines values for V0043NodeState.
const (
	V0043NodeStateALLOCATED       V0043NodeState = "ALLOCATED"
	V0043NodeStateCLOUD           V0043NodeState = "CLOUD"
	V0043NodeStateCOMPLETING      V0043NodeState = "COMPLETING"
	V0043NodeStateDOWN            V0043NodeState = "DOWN"
	V0043NodeStateDRAIN           V0043NodeState = "DRAIN"
	V0043NodeStateDYNAMICFUTURE   V0043NodeState = "DYNAMIC_FUTURE"
	V0043NodeStateDYNAMICNORM     V0043NodeState = "DYNAMIC_NORM"
	V0043NodeStateERROR           V0043NodeState = "ERROR"
	V0043NodeStateFAIL            V0043NodeState = "FAIL"
	V0043NodeStateFUTURE          V0043NodeState = "FUTURE"
	V0043NodeStateIDLE            V0043NodeState = "IDLE"
	V0043NodeStateINVALID         V0043NodeState = "INVALID"
	V0043NodeStateINVALIDREG      V0043NodeState = "INVALID_REG"
	V0043NodeStateMAINTENANCE     V0043NodeState = "MAINTENANCE"
	V0043NodeStateMIXED           V0043NodeState = "MIXED"
	V0043NodeStateNOTRESPONDING   V0043NodeState = "NOT_RESPONDING"
	V0043NodeStatePLANNED         V0043NodeState = "PLANNED"
	V0043NodeStatePOWERDOWN       V0043NodeState = "POWER_DOWN"
	V0043NodeStatePOWERDRAIN      V0043NodeState = "POWER_DRAIN"
	V0043NodeStatePOWEREDDOWN     V0043NodeState = "POWERED_DOWN"
	V0043NodeStatePOWERINGDOWN    V0043NodeState = "POWERING_DOWN"
	V0043NodeStatePOWERINGUP      V0043NodeState = "POWERING_UP"
	V0043NodeStatePOWERUP         V0043NodeState = "POWER_UP"
	V0043NodeStateREBOOTCANCELED  V0043NodeState = "REBOOT_CANCELED"
	V0043NodeStateREBOOTISSUED    V0043NodeState = "REBOOT_ISSUED"
	V0043NodeStateREBOOTREQUESTED V0043NodeState = "REBOOT_REQUESTED"
	V0043NodeStateRESERVED        V0043NodeState = "RESERVED"
	V0043NodeStateRESUME          V0043NodeState = "RESUME"
	V0043NodeStateUNDRAIN         V0043NodeState = "UNDRAIN"
	V0043NodeStateUNKNOWN         V0043NodeState = "UNKNOWN"
)

// Defines values for V0043PartitionInfoMaximumsOversubscribeFlags.
const (
	Force V0043PartitionInfoMaximumsOversubscribeFlags = "force"
)

// Defines values for V0043PartitionInfoPartitionState.
const (
	V0043PartitionInfoPartitionStateDOWN     V0043PartitionInfoPartitionState = "DOWN"
	V0043PartitionInfoPartitionStateDRAIN    V0043PartitionInfoPartitionState = "DRAIN"
	V0043PartitionInfoPartitionStateINACTIVE V0043PartitionInfoPartitionState = "INACTIVE"
	V0043PartitionInfoPartitionStateUNKNOWN  V0043PartitionInfoPartitionState = "UNKNOWN"
	V0043PartitionInfoPartitionStateUP       V0043PartitionInfoPartitionState = "UP"
)

// Defines values for V0043PartitionInfoSelectType.
const (
	V0043PartitionInfoSelectTypeBOARD                V0043PartitionInfoSelectType = "BOARD"
	V0043PartitionInfoSelectTypeCORE                 V0043PartitionInfoSelectType = "CORE"
	V0043PartitionInfoSelectTypeCOREDEFAULTDISTBLOCK V0043PartitionInfoSelectType = "CORE_DEFAULT_DIST_BLOCK"
	V0043PartitionInfoSelectTypeCPU                  V0043PartitionInfoSelectType = "CPU"
	V0043PartitionInfoSelectTypeLINEAR               V0043PartitionInfoSelectType = "LINEAR"
	V0043PartitionInfoSelectTypeLLN                  V0043PartitionInfoSelectType = "LLN"
	V0043PartitionInfoSelectTypeMEMORY               V0043PartitionInfoSelectType = "MEMORY"
	V0043PartitionInfoSelectTypeONETASKPERCORE       V0043PartitionInfoSelectType = "ONE_TASK_PER_CORE"
	V0043PartitionInfoSelectTypePACKNODES            V0043PartitionInfoSelectType = "PACK_NODES"
	V0043PartitionInfoSelectTypeSOCKET               V0043PartitionInfoSelectType = "SOCKET"
)

// Defines values for V0043ProcessExitCodeVerboseStatus.
const (
	V0043ProcessExitCodeVerboseStatusCOREDUMPED V0043ProcessExitCodeVerboseStatus = "CORE_DUMPED"
	V0043ProcessExitCodeVerboseStatusERROR      V0043ProcessExitCodeVerboseStatus = "ERROR"
	V0043ProcessExitCodeVerboseStatusINVALID    V0043ProcessExitCodeVerboseStatus = "INVALID"
	V0043ProcessExitCodeVerboseStatusPENDING    V0043ProcessExitCodeVerboseStatus = "PENDING"
	V0043ProcessExitCodeVerboseStatusSIGNALED   V0043ProcessExitCodeVerboseStatus = "SIGNALED"
	V0043ProcessExitCodeVerboseStatusSUCCESS    V0043ProcessExitCodeVerboseStatus = "SUCCESS"
)

// Defines values for V0043QosFlags.
const (
	V0043QosFlagsADD                   V0043QosFlags = "ADD"
	V0043QosFlagsDELETED               V0043QosFlags = "DELETED"
	V0043QosFlagsDENYLIMIT             V0043QosFlags = "DENY_LIMIT"
	V0043QosFlagsENFORCEUSAGETHRESHOLD V0043QosFlags = "ENFORCE_USAGE_THRESHOLD"
	V0043QosFlagsNODECAY               V0043QosFlags = "NO_DECAY"
	V0043QosFlagsNORESERVE             V0043QosFlags = "NO_RESERVE"
	V0043QosFlagsNOTSET                V0043QosFlags = "NOT_SET"
	V0043QosFlagsOVERRIDEPARTITIONQOS  V0043QosFlags = "OVERRIDE_PARTITION_QOS"
	V0043QosFlagsPARTITIONMAXIMUMNODE  V0043QosFlags = "PARTITION_MAXIMUM_NODE"
	V0043QosFlagsPARTITIONMINIMUMNODE  V0043QosFlags = "PARTITION_MINIMUM_NODE"
	V0043QosFlagsPARTITIONQOS          V0043QosFlags = "PARTITION_QOS"
	V0043QosFlagsPARTITIONTIMELIMIT    V0043QosFlags = "PARTITION_TIME_LIMIT"
	V0043QosFlagsRELATIVE              V0043QosFlags = "RELATIVE"
	V0043QosFlagsREMOVE                V0043QosFlags = "REMOVE"
	V0043QosFlagsREQUIREDRESERVATION   V0043QosFlags = "REQUIRED_RESERVATION"
	V0043QosFlagsUSAGEFACTORSAFE       V0043QosFlags = "USAGE_FACTOR_SAFE"
)

// Defines values for V0043QosPreemptMode.
const (
	V0043QosPreemptModeCANCEL   V0043QosPreemptMode = "CANCEL"
	V0043QosPreemptModeDISABLED V0043QosPreemptMode = "DISABLED"
	V0043QosPreemptModeGANG     V0043QosPreemptMode = "GANG"
	V0043QosPreemptModeREQUEUE  V0043QosPreemptMode = "REQUEUE"
	V0043QosPreemptModeSUSPEND  V0043QosPreemptMode = "SUSPEND"
)

// Defines values for V0043ReservationDescMsgFlags.
const (
	V0043ReservationDescMsgFlagsALLNODES           V0043ReservationDescMsgFlags = "ALL_NODES"
	V0043ReservationDescMsgFlagsANYNODES           V0043ReservationDescMsgFlags = "ANY_NODES"
	V0043ReservationDescMsgFlagsDAILY              V0043ReservationDescMsgFlags = "DAILY"
	V0043ReservationDescMsgFlagsDURATIONMINUS      V0043ReservationDescMsgFlags = "DURATION_MINUS"
	V0043ReservationDescMsgFlagsDURATIONPLUS       V0043ReservationDescMsgFlags = "DURATION_PLUS"
	V0043ReservationDescMsgFlagsFLEX               V0043ReservationDescMsgFlags = "FLEX"
	V0043ReservationDescMsgFlagsHOURLY             V0043ReservationDescMsgFlags = "HOURLY"
	V0043ReservationDescMsgFlagsIGNOREJOBS         V0043ReservationDescMsgFlags = "IGNORE_JOBS"
	V0043ReservationDescMsgFlagsMAGNETIC           V0043ReservationDescMsgFlags = "MAGNETIC"
	V0043ReservationDescMsgFlagsMAINT              V0043ReservationDescMsgFlags = "MAINT"
	V0043ReservationDescMsgFlagsNODAILY            V0043ReservationDescMsgFlags = "NO_DAILY"
	V0043ReservationDescMsgFlagsNOFLEX             V0043ReservationDescMsgFlags = "NO_FLEX"
	V0043ReservationDescMsgFlagsNOHOLDJOBSAFTEREND V0043ReservationDescMsgFlags = "NO_HOLD_JOBS_AFTER_END"
	V0043ReservationDescMsgFlagsNOHOURLY           V0043ReservationDescMsgFlags = "NO_HOURLY"
	V0043ReservationDescMsgFlagsNOIGNOREJOBS       V0043ReservationDescMsgFlags = "NO_IGNORE_JOBS"
	V0043ReservationDescMsgFlagsNOMAINT            V0043ReservationDescMsgFlags = "NO_MAINT"
	V0043ReservationDescMsgFlagsNOPARTNODES        V0043ReservationDescMsgFlags = "NO_PART_NODES"
	V0043ReservationDescMsgFlagsNOPURGECOMP        V0043ReservationDescMsgFlags = "NO_PURGE_COMP"
	V0043ReservationDescMsgFlagsNOSTATIC           V0043ReservationDescMsgFlags = "NO_STATIC"
	V0043ReservationDescMsgFlagsNOUSERDELETE       V0043ReservationDescMsgFlags = "NO_USER_DELETE"
	V0043ReservationDescMsgFlagsNOWEEKDAY          V0043ReservationDescMsgFlags = "NO_WEEKDAY"
	V0043ReservationDescMsgFlagsNOWEEKEND          V0043ReservationDescMsgFlags = "NO_WEEKEND"
	V0043ReservationDescMsgFlagsNOWEEKLY           V0043ReservationDescMsgFlags = "NO_WEEKLY"
	V0043ReservationDescMsgFlagsOVERLAP            V0043ReservationDescMsgFlags = "OVERLAP"
	V0043ReservationDescMsgFlagsPARTNODES          V0043ReservationDescMsgFlags = "PART_NODES"
	V0043ReservationDescMsgFlagsPURGECOMP          V0043ReservationDescMsgFlags = "PURGE_COMP"
	V0043ReservationDescMsgFlagsREOCCURRING        V0043ReservationDescMsgFlags = "REOCCURRING"
	V0043ReservationDescMsgFlagsREPLACE            V0043ReservationDescMsgFlags = "REPLACE"
	V0043ReservationDescMsgFlagsSKIP               V0043ReservationDescMsgFlags = "SKIP"
	V0043ReservationDescMsgFlagsSPECNODES          V0043ReservationDescMsgFlags = "SPEC_NODES"
	V0043ReservationDescMsgFlagsSTATIC             V0043ReservationDescMsgFlags = "STATIC"
	V0043ReservationDescMsgFlagsTIMEFLOAT          V0043ReservationDescMsgFlags = "TIME_FLOAT"
	V0043ReservationDescMsgFlagsUSERDELETE         V0043ReservationDescMsgFlags = "USER_DELETE"
	V0043ReservationDescMsgFlagsWEEKDAY            V0043ReservationDescMsgFlags = "WEEKDAY"
	V0043ReservationDescMsgFlagsWEEKEND            V0043ReservationDescMsgFlags = "WEEKEND"
	V0043ReservationDescMsgFlagsWEEKLY             V0043ReservationDescMsgFlags = "WEEKLY"
)

// Defines values for V0043ReservationInfoFlags.
const (
	V0043ReservationInfoFlagsALLNODES           V0043ReservationInfoFlags = "ALL_NODES"
	V0043ReservationInfoFlagsANYNODES           V0043ReservationInfoFlags = "ANY_NODES"
	V0043ReservationInfoFlagsDAILY              V0043ReservationInfoFlags = "DAILY"
	V0043ReservationInfoFlagsDURATIONMINUS      V0043ReservationInfoFlags = "DURATION_MINUS"
	V0043ReservationInfoFlagsDURATIONPLUS       V0043ReservationInfoFlags = "DURATION_PLUS"
	V0043ReservationInfoFlagsFLEX               V0043ReservationInfoFlags = "FLEX"
	V0043ReservationInfoFlagsHOURLY             V0043ReservationInfoFlags = "HOURLY"
	V0043ReservationInfoFlagsIGNOREJOBS         V0043ReservationInfoFlags = "IGNORE_JOBS"
	V0043ReservationInfoFlagsMAGNETIC           V0043ReservationInfoFlags = "MAGNETIC"
	V0043ReservationInfoFlagsMAINT              V0043ReservationInfoFlags = "MAINT"
	V0043ReservationInfoFlagsNODAILY            V0043ReservationInfoFlags = "NO_DAILY"
	V0043ReservationInfoFlagsNOFLEX             V0043ReservationInfoFlags = "NO_FLEX"
	V0043ReservationInfoFlagsNOHOLDJOBSAFTEREND V0043ReservationInfoFlags = "NO_HOLD_JOBS_AFTER_END"
	V0043ReservationInfoFlagsNOHOURLY           V0043ReservationInfoFlags = "NO_HOURLY"
	V0043ReservationInfoFlagsNOIGNOREJOBS       V0043ReservationInfoFlags = "NO_IGNORE_JOBS"
	V0043ReservationInfoFlagsNOMAINT            V0043ReservationInfoFlags = "NO_MAINT"
	V0043ReservationInfoFlagsNOPARTNODES        V0043ReservationInfoFlags = "NO_PART_NODES"
	V0043ReservationInfoFlagsNOPURGECOMP        V0043ReservationInfoFlags = "NO_PURGE_COMP"
	V0043ReservationInfoFlagsNOSTATIC           V0043ReservationInfoFlags = "NO_STATIC"
	V0043ReservationInfoFlagsNOUSERDELETE       V0043ReservationInfoFlags = "NO_USER_DELETE"
	V0043ReservationInfoFlagsNOWEEKDAY          V0043ReservationInfoFlags = "NO_WEEKDAY"
	V0043ReservationInfoFlagsNOWEEKEND          V0043ReservationInfoFlags = "NO_WEEKEND"
	V0043ReservationInfoFlagsNOWEEKLY           V0043ReservationInfoFlags = "NO_WEEKLY"
	V0043ReservationInfoFlagsOVERLAP            V0043ReservationInfoFlags = "OVERLAP"
	V0043ReservationInfoFlagsPARTNODES          V0043ReservationInfoFlags = "PART_NODES"
	V0043ReservationInfoFlagsPURGECOMP          V0043ReservationInfoFlags = "PURGE_COMP"
	V0043ReservationInfoFlagsREOCCURRING        V0043ReservationInfoFlags = "REOCCURRING"
	V0043ReservationInfoFlagsREPLACE            V0043ReservationInfoFlags = "REPLACE"
	V0043ReservationInfoFlagsSKIP               V0043ReservationInfoFlags = "SKIP"
	V0043ReservationInfoFlagsSPECNODES          V0043ReservationInfoFlags = "SPEC_NODES"
	V0043ReservationInfoFlagsSTATIC             V0043ReservationInfoFlags = "STATIC"
	V0043ReservationInfoFlagsTIMEFLOAT          V0043ReservationInfoFlags = "TIME_FLOAT"
	V0043ReservationInfoFlagsUSERDELETE         V0043ReservationInfoFlags = "USER_DELETE"
	V0043ReservationInfoFlagsWEEKDAY            V0043ReservationInfoFlags = "WEEKDAY"
	V0043ReservationInfoFlagsWEEKEND            V0043ReservationInfoFlags = "WEEKEND"
	V0043ReservationInfoFlagsWEEKLY             V0043ReservationInfoFlags = "WEEKLY"
)

// Defines values for V0043StepState.
const (
	V0043StepStateBOOTFAIL     V0043StepState = "BOOT_FAIL"
	V0043StepStateCANCELLED    V0043StepState = "CANCELLED"
	V0043StepStateCOMPLETED    V0043StepState = "COMPLETED"
	V0043StepStateCOMPLETING   V0043StepState = "COMPLETING"
	V0043StepStateCONFIGURING  V0043StepState = "CONFIGURING"
	V0043StepStateDEADLINE     V0043StepState = "DEADLINE"
	V0043StepStateFAILED       V0043StepState = "FAILED"
	V0043StepStateLAUNCHFAILED V0043StepState = "LAUNCH_FAILED"
	V0043StepStateNODEFAIL     V0043StepState = "NODE_FAIL"
	V0043StepStateOUTOFMEMORY  V0043StepState = "OUT_OF_MEMORY"
	V0043StepStatePENDING      V0043StepState = "PENDING"
	V0043StepStatePOWERUPNODE  V0043StepState = "POWER_UP_NODE"
	V0043StepStatePREEMPTED    V0043StepState = "PREEMPTED"
	V0043StepStateRECONFIGFAIL V0043StepState = "RECONFIG_FAIL"
	V0043StepStateREQUEUED     V0043StepState = "REQUEUED"
	V0043StepStateREQUEUEFED   V0043StepState = "REQUEUE_FED"
	V0043StepStateREQUEUEHOLD  V0043StepState = "REQUEUE_HOLD"
	V0043StepStateRESIZING     V0043StepState = "RESIZING"
	V0043StepStateRESVDELHOLD  V0043StepState = "RESV_DEL_HOLD"
	V0043StepStateREVOKED      V0043StepState = "REVOKED"
	V0043StepStateRUNNING      V0043StepState = "RUNNING"
	V0043StepStateSIGNALING    V0043StepState = "SIGNALING"
	V0043StepStateSPECIALEXIT  V0043StepState = "SPECIAL_EXIT"
	V0043StepStateSTAGEOUT     V0043StepState = "STAGE_OUT"
	V0043StepStateSTOPPED      V0043StepState = "STOPPED"
	V0043StepStateSUSPENDED    V0043StepState = "SUSPENDED"
	V0043StepStateTIMEOUT      V0043StepState = "TIMEOUT"
)

// Defines values for V0043UpdateNodeMsgState.
const (
	V0043UpdateNodeMsgStateALLOCATED       V0043UpdateNodeMsgState = "ALLOCATED"
	V0043UpdateNodeMsgStateCLOUD           V0043UpdateNodeMsgState = "CLOUD"
	V0043UpdateNodeMsgStateCOMPLETING      V0043UpdateNodeMsgState = "COMPLETING"
	V0043UpdateNodeMsgStateDOWN            V0043UpdateNodeMsgState = "DOWN"
	V0043UpdateNodeMsgStateDRAIN           V0043UpdateNodeMsgState = "DRAIN"
	V0043UpdateNodeMsgStateDYNAMICFUTURE   V0043UpdateNodeMsgState = "DYNAMIC_FUTURE"
	V0043UpdateNodeMsgStateDYNAMICNORM     V0043UpdateNodeMsgState = "DYNAMIC_NORM"
	V0043UpdateNodeMsgStateERROR           V0043UpdateNodeMsgState = "ERROR"
	V0043UpdateNodeMsgStateFAIL            V0043UpdateNodeMsgState = "FAIL"
	V0043UpdateNodeMsgStateFUTURE          V0043UpdateNodeMsgState = "FUTURE"
	V0043UpdateNodeMsgStateIDLE            V0043UpdateNodeMsgState = "IDLE"
	V0043UpdateNodeMsgStateINVALID         V0043UpdateNodeMsgState = "INVALID"
	V0043UpdateNodeMsgStateINVALIDREG      V0043UpdateNodeMsgState = "INVALID_REG"
	V0043UpdateNodeMsgStateMAINTENANCE     V0043UpdateNodeMsgState = "MAINTENANCE"
	V0043UpdateNodeMsgStateMIXED           V0043UpdateNodeMsgState = "MIXED"
	V0043UpdateNodeMsgStateNOTRESPONDING   V0043UpdateNodeMsgState = "NOT_RESPONDING"
	V0043UpdateNodeMsgStatePLANNED         V0043UpdateNodeMsgState = "PLANNED"
	V0043UpdateNodeMsgStatePOWERDOWN       V0043UpdateNodeMsgState = "POWER_DOWN"
	V0043UpdateNodeMsgStatePOWERDRAIN      V0043UpdateNodeMsgState = "POWER_DRAIN"
	V0043UpdateNodeMsgStatePOWEREDDOWN     V0043UpdateNodeMsgState = "POWERED_DOWN"
	V0043UpdateNodeMsgStatePOWERINGDOWN    V0043UpdateNodeMsgState = "POWERING_DOWN"
	V0043UpdateNodeMsgStatePOWERINGUP      V0043UpdateNodeMsgState = "POWERING_UP"
	V0043UpdateNodeMsgStatePOWERUP         V0043UpdateNodeMsgState = "POWER_UP"
	V0043UpdateNodeMsgStateREBOOTCANCELED  V0043UpdateNodeMsgState = "REBOOT_CANCELED"
	V0043UpdateNodeMsgStateREBOOTISSUED    V0043UpdateNodeMsgState = "REBOOT_ISSUED"
	V0043UpdateNodeMsgStateREBOOTREQUESTED V0043UpdateNodeMsgState = "REBOOT_REQUESTED"
	V0043UpdateNodeMsgStateRESERVED        V0043UpdateNodeMsgState = "RESERVED"
	V0043UpdateNodeMsgStateRESUME          V0043UpdateNodeMsgState = "RESUME"
	V0043UpdateNodeMsgStateUNDRAIN         V0043UpdateNodeMsgState = "UNDRAIN"
	V0043UpdateNodeMsgStateUNKNOWN         V0043UpdateNodeMsgState = "UNKNOWN"
)

// Defines values for V0043UserAdministratorLevel.
const (
	V0043UserAdministratorLevelAdministrator V0043UserAdministratorLevel = "Administrator"
	V0043UserAdministratorLevelNone          V0043UserAdministratorLevel = "None"
	V0043UserAdministratorLevelNotSet        V0043UserAdministratorLevel = "Not Set"
	V0043UserAdministratorLevelOperator      V0043UserAdministratorLevel = "Operator"
)

// Defines values for V0043UserFlags.
const (
	V0043UserFlagsDELETED V0043UserFlags = "DELETED"
	V0043UserFlagsNONE    V0043UserFlags = "NONE"
)

// Defines values for V0043UserShortAdminlevel.
const (
	V0043UserShortAdminlevelAdministrator V0043UserShortAdminlevel = "Administrator"
	V0043UserShortAdminlevelNone          V0043UserShortAdminlevel = "None"
	V0043UserShortAdminlevelNotSet        V0043UserShortAdminlevel = "Not Set"
	V0043UserShortAdminlevelOperator      V0043UserShortAdminlevel = "Operator"
)

// Defines values for V0043WckeyFlags.
const (
	V0043WckeyFlagsDELETED V0043WckeyFlags = "DELETED"
)

// Defines values for V0043WckeyTagStructFlags.
const (
	ASSIGNEDDEFAULT V0043WckeyTagStructFlags = "ASSIGNED_DEFAULT"
)

// Defines values for SlurmV0043DeleteJobParamsFlags.
const (
	ARRAYTASK         SlurmV0043DeleteJobParamsFlags = "ARRAY_TASK"
	BATCHJOB          SlurmV0043DeleteJobParamsFlags = "BATCH_JOB"
	CRONJOBS          SlurmV0043DeleteJobParamsFlags = "CRON_JOBS"
	FEDERATIONREQUEUE SlurmV0043DeleteJobParamsFlags = "FEDERATION_REQUEUE"
	FULLJOB           SlurmV0043DeleteJobParamsFlags = "FULL_JOB"
	FULLSTEPSONLY     SlurmV0043DeleteJobParamsFlags = "FULL_STEPS_ONLY"
	HURRY             SlurmV0043DeleteJobParamsFlags = "HURRY"
	NOSIBLINGJOBS     SlurmV0043DeleteJobParamsFlags = "NO_SIBLING_JOBS"
	OUTOFMEMORY       SlurmV0043DeleteJobParamsFlags = "OUT_OF_MEMORY"
	RESERVATIONJOB    SlurmV0043DeleteJobParamsFlags = "RESERVATION_JOB"
	VERBOSE           SlurmV0043DeleteJobParamsFlags = "VERBOSE"
	WARNINGSENT       SlurmV0043DeleteJobParamsFlags = "WARNING_SENT"
)

// Defines values for SlurmV0043GetJobParamsFlags.
const (
	SlurmV0043GetJobParamsFlagsALL        SlurmV0043GetJobParamsFlags = "ALL"
	SlurmV0043GetJobParamsFlagsDETAIL     SlurmV0043GetJobParamsFlags = "DETAIL"
	SlurmV0043GetJobParamsFlagsFEDERATION SlurmV0043GetJobParamsFlags = "FEDERATION"
	SlurmV0043GetJobParamsFlagsFUTURE     SlurmV0043GetJobParamsFlags = "FUTURE"
	SlurmV0043GetJobParamsFlagsLOCAL      SlurmV0043GetJobParamsFlags = "LOCAL"
	SlurmV0043GetJobParamsFlagsMIXED      SlurmV0043GetJobParamsFlags = "MIXED"
	SlurmV0043GetJobParamsFlagsSIBLING    SlurmV0043GetJobParamsFlags = "SIBLING"
)

// Defines values for SlurmV0043GetJobsParamsFlags.
const (
	SlurmV0043GetJobsParamsFlagsALL        SlurmV0043GetJobsParamsFlags = "ALL"
	SlurmV0043GetJobsParamsFlagsDETAIL     SlurmV0043GetJobsParamsFlags = "DETAIL"
	SlurmV0043GetJobsParamsFlagsFEDERATION SlurmV0043GetJobsParamsFlags = "FEDERATION"
	SlurmV0043GetJobsParamsFlagsFUTURE     SlurmV0043GetJobsParamsFlags = "FUTURE"
	SlurmV0043GetJobsParamsFlagsLOCAL      SlurmV0043GetJobsParamsFlags = "LOCAL"
	SlurmV0043GetJobsParamsFlagsMIXED      SlurmV0043GetJobsParamsFlags = "MIXED"
	SlurmV0043GetJobsParamsFlagsSIBLING    SlurmV0043GetJobsParamsFlags = "SIBLING"
)

// Defines values for SlurmV0043GetNodeParamsFlags.
const (
	SlurmV0043GetNodeParamsFlagsALL        SlurmV0043GetNodeParamsFlags = "ALL"
	SlurmV0043GetNodeParamsFlagsDETAIL     SlurmV0043GetNodeParamsFlags = "DETAIL"
	SlurmV0043GetNodeParamsFlagsFEDERATION SlurmV0043GetNodeParamsFlags = "FEDERATION"
	SlurmV0043GetNodeParamsFlagsFUTURE     SlurmV0043GetNodeParamsFlags = "FUTURE"
	SlurmV0043GetNodeParamsFlagsLOCAL      SlurmV0043GetNodeParamsFlags = "LOCAL"
	SlurmV0043GetNodeParamsFlagsMIXED      SlurmV0043GetNodeParamsFlags = "MIXED"
	SlurmV0043GetNodeParamsFlagsSIBLING    SlurmV0043GetNodeParamsFlags = "SIBLING"
)

// Defines values for SlurmV0043GetNodesParamsFlags.
const (
	SlurmV0043GetNodesParamsFlagsALL        SlurmV0043GetNodesParamsFlags = "ALL"
	SlurmV0043GetNodesParamsFlagsDETAIL     SlurmV0043GetNodesParamsFlags = "DETAIL"
	SlurmV0043GetNodesParamsFlagsFEDERATION SlurmV0043GetNodesParamsFlags = "FEDERATION"
	SlurmV0043GetNodesParamsFlagsFUTURE     SlurmV0043GetNodesParamsFlags = "FUTURE"
	SlurmV0043GetNodesParamsFlagsLOCAL      SlurmV0043GetNodesParamsFlags = "LOCAL"
	SlurmV0043GetNodesParamsFlagsMIXED      SlurmV0043GetNodesParamsFlags = "MIXED"
	SlurmV0043GetNodesParamsFlagsSIBLING    SlurmV0043GetNodesParamsFlags = "SIBLING"
)

// Defines values for SlurmV0043GetPartitionParamsFlags.
const (
	SlurmV0043GetPartitionParamsFlagsALL        SlurmV0043GetPartitionParamsFlags = "ALL"
	SlurmV0043GetPartitionParamsFlagsDETAIL     SlurmV0043GetPartitionParamsFlags = "DETAIL"
	SlurmV0043GetPartitionParamsFlagsFEDERATION SlurmV0043GetPartitionParamsFlags = "FEDERATION"
	SlurmV0043GetPartitionParamsFlagsFUTURE     SlurmV0043GetPartitionParamsFlags = "FUTURE"
	SlurmV0043GetPartitionParamsFlagsLOCAL      SlurmV0043GetPartitionParamsFlags = "LOCAL"
	SlurmV0043GetPartitionParamsFlagsMIXED      SlurmV0043GetPartitionParamsFlags = "MIXED"
	SlurmV0043GetPartitionParamsFlagsSIBLING    SlurmV0043GetPartitionParamsFlags = "SIBLING"
)

// Defines values for SlurmV0043GetPartitionsParamsFlags.
const (
	SlurmV0043GetPartitionsParamsFlagsALL        SlurmV0043GetPartitionsParamsFlags = "ALL"
	SlurmV0043GetPartitionsParamsFlagsDETAIL     SlurmV0043GetPartitionsParamsFlags = "DETAIL"
	SlurmV0043GetPartitionsParamsFlagsFEDERATION SlurmV0043GetPartitionsParamsFlags = "FEDERATION"
	SlurmV0043GetPartitionsParamsFlagsFUTURE     SlurmV0043GetPartitionsParamsFlags = "FUTURE"
	SlurmV0043GetPartitionsParamsFlagsLOCAL      SlurmV0043GetPartitionsParamsFlags = "LOCAL"
	SlurmV0043GetPartitionsParamsFlagsMIXED      SlurmV0043GetPartitionsParamsFlags = "MIXED"
	SlurmV0043GetPartitionsParamsFlagsSIBLING    SlurmV0043GetPartitionsParamsFlags = "SIBLING"
)

// Defines values for SlurmdbV0043DeleteClusterParamsClassification.
const (
	SlurmdbV0043DeleteClusterParamsClassificationCAPABILITY   SlurmdbV0043DeleteClusterParamsClassification = "CAPABILITY"
	SlurmdbV0043DeleteClusterParamsClassificationCAPACITY     SlurmdbV0043DeleteClusterParamsClassification = "CAPACITY"
	SlurmdbV0043DeleteClusterParamsClassificationCAPAPACITY   SlurmdbV0043DeleteClusterParamsClassification = "CAPAPACITY"
	SlurmdbV0043DeleteClusterParamsClassificationUNCLASSIFIED SlurmdbV0043DeleteClusterParamsClassification = "UNCLASSIFIED"
)

// Defines values for SlurmdbV0043DeleteClusterParamsFlags.
const (
	SlurmdbV0043DeleteClusterParamsFlagsDELETED        SlurmdbV0043DeleteClusterParamsFlags = "DELETED"
	SlurmdbV0043DeleteClusterParamsFlagsEXTERNAL       SlurmdbV0043DeleteClusterParamsFlags = "EXTERNAL"
	SlurmdbV0043DeleteClusterParamsFlagsFEDERATION     SlurmdbV0043DeleteClusterParamsFlags = "FEDERATION"
	SlurmdbV0043DeleteClusterParamsFlagsMULTIPLESLURMD SlurmdbV0043DeleteClusterParamsFlags = "MULTIPLE_SLURMD"
	SlurmdbV0043DeleteClusterParamsFlagsREGISTERING    SlurmdbV0043DeleteClusterParamsFlags = "REGISTERING"
)

// Defines values for SlurmdbV0043GetClusterParamsClassification.
const (
	SlurmdbV0043GetClusterParamsClassificationCAPABILITY   SlurmdbV0043GetClusterParamsClassification = "CAPABILITY"
	SlurmdbV0043GetClusterParamsClassificationCAPACITY     SlurmdbV0043GetClusterParamsClassification = "CAPACITY"
	SlurmdbV0043GetClusterParamsClassificationCAPAPACITY   SlurmdbV0043GetClusterParamsClassification = "CAPAPACITY"
	SlurmdbV0043GetClusterParamsClassificationUNCLASSIFIED SlurmdbV0043GetClusterParamsClassification = "UNCLASSIFIED"
)

// Defines values for SlurmdbV0043GetClusterParamsFlags.
const (
	SlurmdbV0043GetClusterParamsFlagsDELETED        SlurmdbV0043GetClusterParamsFlags = "DELETED"
	SlurmdbV0043GetClusterParamsFlagsEXTERNAL       SlurmdbV0043GetClusterParamsFlags = "EXTERNAL"
	SlurmdbV0043GetClusterParamsFlagsFEDERATION     SlurmdbV0043GetClusterParamsFlags = "FEDERATION"
	SlurmdbV0043GetClusterParamsFlagsMULTIPLESLURMD SlurmdbV0043GetClusterParamsFlags = "MULTIPLE_SLURMD"
	SlurmdbV0043GetClusterParamsFlagsREGISTERING    SlurmdbV0043GetClusterParamsFlags = "REGISTERING"
)

// Defines values for SlurmdbV0043GetQosParamsPreemptMode.
const (
	SlurmdbV0043GetQosParamsPreemptModeCANCEL   SlurmdbV0043GetQosParamsPreemptMode = "CANCEL"
	SlurmdbV0043GetQosParamsPreemptModeDISABLED SlurmdbV0043GetQosParamsPreemptMode = "DISABLED"
	SlurmdbV0043GetQosParamsPreemptModeGANG     SlurmdbV0043GetQosParamsPreemptMode = "GANG"
	SlurmdbV0043GetQosParamsPreemptModeREQUEUE  SlurmdbV0043GetQosParamsPreemptMode = "REQUEUE"
	SlurmdbV0043GetQosParamsPreemptModeSUSPEND  SlurmdbV0043GetQosParamsPreemptMode = "SUSPEND"
)

// Defines values for SlurmdbV0043PostQosParamsPreemptMode.
const (
	CANCEL   SlurmdbV0043PostQosParamsPreemptMode = "CANCEL"
	DISABLED SlurmdbV0043PostQosParamsPreemptMode = "DISABLED"
	GANG     SlurmdbV0043PostQosParamsPreemptMode = "GANG"
	REQUEUE  SlurmdbV0043PostQosParamsPreemptMode = "REQUEUE"
	SUSPEND  SlurmdbV0043PostQosParamsPreemptMode = "SUSPEND"
)

// Defines values for SlurmdbV0043GetUsersParamsAdminLevel.
const (
	Administrator SlurmdbV0043GetUsersParamsAdminLevel = "Administrator"
	None          SlurmdbV0043GetUsersParamsAdminLevel = "None"
	NotSet        SlurmdbV0043GetUsersParamsAdminLevel = "Not Set"
	Operator      SlurmdbV0043GetUsersParamsAdminLevel = "Operator"
)

// Defines values for SlurmdbV0043PostUsersAssociationParamsFlags.
const (
	ALL        SlurmdbV0043PostUsersAssociationParamsFlags = "ALL"
	DETAIL     SlurmdbV0043PostUsersAssociationParamsFlags = "DETAIL"
	FEDERATION SlurmdbV0043PostUsersAssociationParamsFlags = "FEDERATION"
	FUTURE     SlurmdbV0043PostUsersAssociationParamsFlags = "FUTURE"
	LOCAL      SlurmdbV0043PostUsersAssociationParamsFlags = "LOCAL"
	MIXED      SlurmdbV0043PostUsersAssociationParamsFlags = "MIXED"
	SIBLING    SlurmdbV0043PostUsersAssociationParamsFlags = "SIBLING"
)

// V0043Account defines model for v0.0.43_account.
type V0043Account struct {
	Associations *V0043AssocShortList `json:"associations,omitempty"`
	Coordinators *V0043CoordList      `json:"coordinators,omitempty"`

	// Description Arbitrary string describing the account
	Description string `json:"description"`

	// Flags Flags associated with this account
	Flags *[]V0043AccountFlags `json:"flags,omitempty"`

	// Name Account name
	Name string `json:"name"`

	// Organization Organization to which the account belongs
	Organization string `json:"organization"`
}

// V0043AccountFlags defines model for V0043Account.Flags.
type V0043AccountFlags string

// V0043AccountList defines model for v0.0.43_account_list.
type V0043AccountList = []V0043Account

// V0043AccountShort defines model for v0.0.43_account_short.
type V0043AccountShort struct {
	// Description Arbitrary string describing the account
	Description *string `json:"description,omitempty"`

	// Organization Organization to which the account belongs
	Organization *string `json:"organization,omitempty"`
}

// V0043Accounting defines model for v0.0.43_accounting.
type V0043Accounting struct {
	TRES      *V0043Tres `json:"TRES,omitempty"`
	Allocated *struct {
		// Seconds Number of seconds allocated
		Seconds *int64 `json:"seconds,omitempty"`
	} `json:"allocated,omitempty"`

	// Id Association ID or Workload characterization key ID
	Id *int32 `json:"id,omitempty"`

	// IdAlt Alternate ID (not currently used)
	IdAlt *int32 `json:"id_alt,omitempty"`

	// Start When the record was started (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
	Start *int64 `json:"start,omitempty"`
}

// V0043AccountingList defines model for v0.0.43_accounting_list.
type V0043AccountingList = []V0043Accounting

// V0043AccountsAddCond defines model for v0.0.43_accounts_add_cond.
type V0043AccountsAddCond struct {
	Accounts    V0043StringList   `json:"accounts"`
	Association *V0043AssocRecSet `json:"association,omitempty"`
	Clusters    *V0043StringList  `json:"clusters,omitempty"`
}

// V0043AcctGatherEnergy defines model for v0.0.43_acct_gather_energy.
type V0043AcctGatherEnergy struct {
	// AverageWatts Average power consumption, in watts
	AverageWatts *int32 `json:"average_watts,omitempty"`

	// BaseConsumedEnergy The energy consumed between when the node was powered on and the last time it was registered by slurmd, in joules
	BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`

	// ConsumedEnergy The energy consumed between the last time the node was registered by the slurmd daemon and the last node energy accounting sample, in joules
	ConsumedEnergy *int64                  `json:"consumed_energy,omitempty"`
	CurrentWatts   *V0043Uint32NoValStruct `json:"current_watts,omitempty"`

	// LastCollected Time when energy data was last retrieved (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
	LastCollected *int64 `json:"last_collected,omitempty"`

	// PreviousConsumedEnergy Previous value of consumed_energy
	PreviousConsumedEnergy *int64 `json:"previous_consumed_energy,omitempty"`
}

// V0043Assoc defines model for v0.0.43_assoc.
type V0043Assoc struct {
	// Account Account name
	Account    *string              `json:"account,omitempty"`
	Accounting *V0043AccountingList `json:"accounting,omitempty"`

	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`

	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`
	Default *struct {
		// Qos Default QOS
		Qos *string `json:"qos,omitempty"`
	} `json:"default,omitempty"`

	// Flags Flags on the association
	Flags *[]V0043AssocFlags `json:"flags,omitempty"`

	// Id Unique ID (Association ID)
	Id *int32 `json:"id,omitempty"`

	// IsDefault Is default association for user
	IsDefault *bool `json:"is_default,omitempty"`

	// Lineage Complete path up the hierarchy to the root association
	Lineage *string `json:"lineage,omitempty"`
	Max     *struct {
		Jobs *struct {
			Accruing *V0043Uint32NoValStruct `json:"accruing,omitempty"`
			Active   *V0043Uint32NoValStruct `json:"active,omitempty"`
			Per      *struct {
				Accruing  *V0043Uint32NoValStruct `json:"accruing,omitempty"`
				Count     *V0043Uint32NoValStruct `json:"count,omitempty"`
				Submitted *V0043Uint32NoValStruct `json:"submitted,omitempty"`
				WallClock *V0043Uint32NoValStruct `json:"wall_clock,omitempty"`
			} `json:"per,omitempty"`
			Total *V0043Uint32NoValStruct `json:"total,omitempty"`
		} `json:"jobs,omitempty"`
		Per *struct {
			Account *struct {
				WallClock *V0043Uint32NoValStruct `json:"wall_clock,omitempty"`
			} `json:"account,omitempty"`
		} `json:"per,omitempty"`
		Tres *struct {
			Group *struct {
				Active  *V0043TresList `json:"active,omitempty"`
				Minutes *V0043TresList `json:"minutes,omitempty"`
			} `json:"group,omitempty"`
			Minutes *struct {
				Per *struct {
					Job *V0043TresList `json:"job,omitempty"`
				} `json:"per,omitempty"`
				Total *V0043TresList `json:"total,omitempty"`
			} `json:"minutes,omitempty"`
			Per *struct {
				Job  *V0043TresList `json:"job,omitempty"`
				Node *V0043TresList `json:"node,omitempty"`
			} `json:"per,omitempty"`
			Total *V0043TresList `json:"total,omitempty"`
		} `json:"tres,omitempty"`
	} `json:"max,omitempty"`
	Min *struct {
		PriorityThreshold *V0043Uint32NoValStruct `json:"priority_threshold,omitempty"`
	} `json:"min,omitempty"`

	// ParentAccount Name of parent account
	ParentAccount *string `json:"parent_account,omitempty"`

	// Partition Partition name
	Partition *string                 `json:"partition,omitempty"`
	Priority  *V0043Uint32NoValStruct `json:"priority,omitempty"`

	// Qos List of QOS names
	Qos *V0043QosStringIdList `json:"qos,omitempty"`

	// SharesRaw Allocated shares used for fairshare calculation
	SharesRaw *int32 `json:"shares_raw,omitempty"`

	// User User name
	User string `json:"user"`
}

// V0043AssocFlags defines model for V0043Assoc.Flags.
type V0043AssocFlags string

// V0043AssocList defines model for v0.0.43_assoc_list.
type V0043AssocList = []V0043Assoc

// V0043AssocRecSet defines model for v0.0.43_assoc_rec_set.
type V0043AssocRecSet struct {
	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// Defaultqos Default QOS
	Defaultqos *string `json:"defaultqos,omitempty"`

	// Fairshare Allocated shares used for fairshare calculation
	Fairshare             *int32                  `json:"fairshare,omitempty"`
	Grpjobs               *V0043Uint32NoValStruct `json:"grpjobs,omitempty"`
	Grpjobsaccrue         *V0043Uint32NoValStruct `json:"grpjobsaccrue,omitempty"`
	Grpsubmitjobs         *V0043Uint32NoValStruct `json:"grpsubmitjobs,omitempty"`
	Grptres               *V0043TresList          `json:"grptres,omitempty"`
	Grptresmins           *V0043TresList          `json:"grptresmins,omitempty"`
	Grptresrunmins        *V0043TresList          `json:"grptresrunmins,omitempty"`
	Grpwall               *V0043Uint32NoValStruct `json:"grpwall,omitempty"`
	Maxjobs               *V0043Uint32NoValStruct `json:"maxjobs,omitempty"`
	Maxjobsaccrue         *V0043Uint32NoValStruct `json:"maxjobsaccrue,omitempty"`
	Maxsubmitjobs         *V0043Uint32NoValStruct `json:"maxsubmitjobs,omitempty"`
	Maxtresminsperjob     *V0043TresList          `json:"maxtresminsperjob,omitempty"`
	Maxtresperjob         *V0043TresList          `json:"maxtresperjob,omitempty"`
	Maxtrespernode        *V0043TresList          `json:"maxtrespernode,omitempty"`
	Maxtresrunmins        *V0043TresList          `json:"maxtresrunmins,omitempty"`
	Maxwalldurationperjob *V0043Uint32NoValStruct `json:"maxwalldurationperjob,omitempty"`
	Minpriothresh         *V0043Uint32NoValStruct `json:"minpriothresh,omitempty"`

	// Parent Name of parent account
	Parent   *string                 `json:"parent,omitempty"`
	Priority *V0043Uint32NoValStruct `json:"priority,omitempty"`

	// Qoslevel List of QOS names
	Qoslevel *V0043QosStringIdList `json:"qoslevel,omitempty"`
}

// V0043AssocSharesObjList defines model for v0.0.43_assoc_shares_obj_list.
type V0043AssocSharesObjList = []V0043AssocSharesObjWrap

// V0043AssocSharesObjWrap defines model for v0.0.43_assoc_shares_obj_wrap.
type V0043AssocSharesObjWrap struct {
	// Cluster Cluster name
	Cluster        *string                  `json:"cluster,omitempty"`
	EffectiveUsage *V0043Float64NoValStruct `json:"effective_usage,omitempty"`
	Fairshare      *struct {
		Factor *V0043Float64NoValStruct `json:"factor,omitempty"`
		Level  *V0043Float64NoValStruct `json:"level,omitempty"`
	} `json:"fairshare,omitempty"`

	// Id Association ID
	Id *int32 `json:"id,omitempty"`

	// Name Share name
	Name *string `json:"name,omitempty"`

	// Parent Parent name
	Parent *string `json:"parent,omitempty"`

	// Partition Partition name
	Partition        *string                  `json:"partition,omitempty"`
	Shares           *V0043Uint32NoValStruct  `json:"shares,omitempty"`
	SharesNormalized *V0043Float64NoValStruct `json:"shares_normalized,omitempty"`
	Tres             *struct {
		GroupMinutes *V0043SharesUint64TresList   `json:"group_minutes,omitempty"`
		RunSeconds   *V0043SharesUint64TresList   `json:"run_seconds,omitempty"`
		Usage        *V0043SharesFloat128TresList `json:"usage,omitempty"`
	} `json:"tres,omitempty"`

	// Type User or account association
	Type *[]V0043AssocSharesObjWrapType `json:"type,omitempty"`

	// Usage Measure of tresbillableunits usage
	Usage           *int64                   `json:"usage,omitempty"`
	UsageNormalized *V0043Float64NoValStruct `json:"usage_normalized,omitempty"`
}

// V0043AssocSharesObjWrapType defines model for V0043AssocSharesObjWrap.Type.
type V0043AssocSharesObjWrapType string

// V0043AssocShort defines model for v0.0.43_assoc_short.
type V0043AssocShort struct {
	// Account Account name
	Account *string `json:"account,omitempty"`

	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`

	// Id Numeric association ID
	Id *int32 `json:"id,omitempty"`

	// Partition Partition name
	Partition *string `json:"partition,omitempty"`

	// User User name
	User string `json:"user"`
}

// V0043AssocShortList defines model for v0.0.43_assoc_short_list.
type V0043AssocShortList = []V0043AssocShort

// V0043BfExitFields defines model for v0.0.43_bf_exit_fields.
type V0043BfExitFields struct {
	// BfMaxJobStart Reached number of jobs allowed to start
	BfMaxJobStart *int32 `json:"bf_max_job_start,omitempty"`

	// BfMaxJobTest Reached number of jobs allowed to be tested
	BfMaxJobTest *int32 `json:"bf_max_job_test,omitempty"`

	// BfMaxTime Reached maximum allowed scheduler time
	BfMaxTime *int32 `json:"bf_max_time,omitempty"`

	// BfNodeSpaceSize Reached table size limit
	BfNodeSpaceSize *int32 `json:"bf_node_space_size,omitempty"`

	// EndJobQueue Reached end of queue
	EndJobQueue *int32 `json:"end_job_queue,omitempty"`

	// StateChanged System state changed
	StateChanged *int32 `json:"state_changed,omitempty"`
}

// V0043ClusterRec defines model for v0.0.43_cluster_rec.
type V0043ClusterRec struct {
	Associations *struct {
		Root *V0043AssocShort `json:"root,omitempty"`
	} `json:"associations,omitempty"`
	Controller *struct {
		// Host ControlHost
		Host *string `json:"host,omitempty"`

		// Port ControlPort
		Port *int32 `json:"port,omitempty"`
	} `json:"controller,omitempty"`

	// Flags Flags
	Flags *[]V0043ClusterRecFlags `json:"flags,omitempty"`

	// Name ClusterName
	Name *string `json:"name,omitempty"`

	// Nodes Node names
	Nodes *string `json:"nodes,omitempty"`

	// RpcVersion RPC version used in the cluster
	RpcVersion *int32 `json:"rpc_version,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	SelectPlugin *string        `json:"select_plugin,omitempty"`
	Tres         *V0043TresList `json:"tres,omitempty"`
}

// V0043ClusterRecFlags defines model for V0043ClusterRec.Flags.
type V0043ClusterRecFlags string

// V0043ClusterRecList defines model for v0.0.43_cluster_rec_list.
type V0043ClusterRecList = []V0043ClusterRec

// V0043ControllerPing defines model for v0.0.43_controller_ping.
type V0043ControllerPing struct {
	// Hostname Target for ping
	Hostname *string `json:"hostname,omitempty"`

	// Latency Number of microseconds it took to successfully ping or timeout
	Latency *int64 `json:"latency,omitempty"`

	// Mode The operating mode of the responding slurmctld
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Mode *string `json:"mode,omitempty"`

	// Pinged Ping result
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Pinged *string `json:"pinged,omitempty"`

	// Primary Is responding slurmctld the primary controller (Is responding slurmctld the primary controller)
	Primary bool `json:"primary"`

	// Responding If ping RPC responded with pong from controller
	Responding bool `json:"responding"`
}

// V0043ControllerPingArray defines model for v0.0.43_controller_ping_array.
type V0043ControllerPingArray = []V0043ControllerPing

// V0043Coord defines model for v0.0.43_coord.
type V0043Coord struct {
	// Direct Indicates whether the coordinator was directly assigned to this account
	Direct *bool `json:"direct,omitempty"`

	// Name User name
	Name string `json:"name"`
}

// V0043CoordList defines model for v0.0.43_coord_list.
type V0043CoordList = []V0043Coord

// V0043CronEntry defines model for v0.0.43_cron_entry.
type V0043CronEntry struct {
	// Command Command to run
	Command *string `json:"command,omitempty"`

	// DayOfMonth Ranged string specifying eligible day of month values (e.g. 0-10,29)
	DayOfMonth *string `json:"day_of_month,omitempty"`

	// DayOfWeek Ranged string specifying eligible day of week values (e.g.0-3,7)
	DayOfWeek *string `json:"day_of_week,omitempty"`

	// Flags Flags
	Flags *[]V0043CronEntryFlags `json:"flags,omitempty"`

	// Hour Ranged string specifying eligible hour values (e.g. 0-5,23)
	Hour *string `json:"hour,omitempty"`
	Line *struct {
		// End End of this entry in file
		End *int32 `json:"end,omitempty"`

		// Start Start of this entry in file
		Start *int32 `json:"start,omitempty"`
	} `json:"line,omitempty"`

	// Minute Ranged string specifying eligible minute values (e.g. 0-10,50)
	Minute *string `json:"minute,omitempty"`

	// Month Ranged string specifying eligible month values (e.g. 0-5,12)
	Month *string `json:"month,omitempty"`

	// Specification Complete time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
	Specification *string `json:"specification,omitempty"`
}

// V0043CronEntryFlags defines model for V0043CronEntry.Flags.
type V0043CronEntryFlags string

// V0043CsvString defines model for v0.0.43_csv_string.
type V0043CsvString = []string

// V0043Float64NoValStruct defines model for v0.0.43_float64_no_val_struct.
type V0043Float64NoValStruct struct {
	// Infinite True if number has been set to infinite; "set" and "number" will be ignored
	Infinite *bool `json:"infinite,omitempty"`

	// Number If "set" is True the number will be set with value; otherwise ignore number contents
	Number *float64 `json:"number,omitempty"`

	// Set True if number has been set; False if number is unset
	Set *bool `json:"set,omitempty"`
}

// V0043Hostlist defines model for v0.0.43_hostlist.
type V0043Hostlist = []string

// V0043HostlistString defines model for v0.0.43_hostlist_string.
type V0043HostlistString = []string

// V0043Instance defines model for v0.0.43_instance.
type V0043Instance struct {
	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// InstanceId Cloud instance ID
	InstanceId *string `json:"instance_id,omitempty"`

	// InstanceType Cloud instance type
	InstanceType *string `json:"instance_type,omitempty"`

	// NodeName NodeName
	NodeName *string `json:"node_name,omitempty"`
	Time     *struct {
		// TimeEnd When the instance will end (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
		TimeEnd *int64 `json:"time_end,omitempty"`

		// TimeStart When the instance will start (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
		TimeStart *int64 `json:"time_start,omitempty"`
	} `json:"time,omitempty"`
}

// V0043InstanceList defines model for v0.0.43_instance_list.
type V0043InstanceList = []V0043Instance

// V0043Job defines model for v0.0.43_job.
type V0043Job struct {
	// Account Account the job ran under
	Account *string `json:"account,omitempty"`

	// AllocationNodes List of nodes allocated to the job
	AllocationNodes *int32 `json:"allocation_nodes,omitempty"`
	Array           *struct {
		// JobId Job ID of job array, or 0 if N/A
		JobId  *int32 `json:"job_id,omitempty"`
		Limits *struct {
			Max *struct {
				Running *struct {
					// Tasks Maximum number of simultaneously running tasks, 0 if no limit
					Tasks *int32 `json:"tasks,omitempty"`
				} `json:"running,omitempty"`
			} `json:"max,omitempty"`
		} `json:"limits,omitempty"`

		// Task String expression of task IDs in this record
		Task   *string                 `json:"task,omitempty"`
		TaskId *V0043Uint32NoValStruct `json:"task_id,omitempty"`
	} `json:"array,omitempty"`
	Association *V0043AssocShort `json:"association,omitempty"`

	// Block The name of the block to be used (used with Blue Gene systems)
	Block *string `json:"block,omitempty"`

	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`
	Comment *struct {
		// Administrator Arbitrary comment made by administrator
		Administrator *string `json:"administrator,omitempty"`

		// Job Arbitrary comment made by user
		Job *string `json:"job,omitempty"`

		// System Arbitrary comment from slurmctld
		System *string `json:"system,omitempty"`
	} `json:"comment,omitempty"`

	// Constraints Feature(s) the job requested as a constraint
	Constraints *string `json:"constraints,omitempty"`

	// Container Absolute path to OCI container bundle
	Container       *string                      `json:"container,omitempty"`
	DerivedExitCode *V0043ProcessExitCodeVerbose `json:"derived_exit_code,omitempty"`
	ExitCode        *V0043ProcessExitCodeVerbose `json:"exit_code,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// FailedNode Name of node that caused job failure
	FailedNode *string `json:"failed_node,omitempty"`

	// Flags Flags associated with this job
	Flags *[]V0043JobFlags `json:"flags,omitempty"`

	// Group Group ID of the user that owns the job
	Group *string `json:"group,omitempty"`
	Het   *struct {
		// JobId Heterogeneous job ID, if applicable
		JobId     *int32                  `json:"job_id,omitempty"`
		JobOffset *V0043Uint32NoValStruct `json:"job_offset,omitempty"`
	} `json:"het,omitempty"`

	// Hold Hold (true) or release (false) job (Job held)
	Hold *bool `json:"hold,omitempty"`

	// JobId Job ID
	JobId *int32 `json:"job_id,omitempty"`

	// KillRequestUser User ID that requested termination of the job
	KillRequestUser *string `json:"kill_request_user,omitempty"`

	// Licenses License(s) required by the job
	Licenses *string `json:"licenses,omitempty"`
	Mcs      *struct {
		// Label Multi-Category Security label on the job
		Label *string `json:"label,omitempty"`
	} `json:"mcs,omitempty"`

	// Name Job name
	Name *string `json:"name,omitempty"`

	// Nodes Node(s) allocated to the job
	Nodes *string `json:"nodes,omitempty"`

	// Partition Partition assigned to the job
	Partition *string                 `json:"partition,omitempty"`
	Priority  *V0043Uint32NoValStruct `json:"priority,omitempty"`

	// Qos Quality of Service assigned to the job
	Qos *string `json:"qos,omitempty"`

	// Qosreq Requested QOS
	Qosreq   *string `json:"qosreq,omitempty"`
	Required *struct {
		// CPUs Minimum number of CPUs required
		CPUs          *int32                  `json:"CPUs,omitempty"`
		MemoryPerCpu  *V0043Uint64NoValStruct `json:"memory_per_cpu,omitempty"`
		MemoryPerNode *V0043Uint64NoValStruct `json:"memory_per_node,omitempty"`
	} `json:"required,omitempty"`
	Reservation *struct {
		// Id Unique identifier of requested reservation
		Id *int32 `json:"id,omitempty"`

		// Name Name of reservation to use
		Name *string `json:"name,omitempty"`

		// Requested Comma-separated list of requested reservation names
		Requested *string `json:"requested,omitempty"`
	} `json:"reservation,omitempty"`

	// RestartCnt How many times this job has been requeued/restarted
	RestartCnt *int32 `json:"restart_cnt,omitempty"`

	// Script Job batch script; only the first component in a HetJob is populated or honored
	Script *string `json:"script,omitempty"`

	// SegmentSize Requested segment size
	SegmentSize *int32 `json:"segment_size,omitempty"`
	State       *struct {
		// Current Current state
		Current *[]V0043JobStateCurrent `json:"current,omitempty"`

		// Reason Reason for previous Pending or Failed state
		Reason *string `json:"reason,omitempty"`
	} `json:"state,omitempty"`

	// Stderr Path to stderr file
	Stderr *string `json:"stderr,omitempty"`

	// StderrExpanded Job stderr with expanded fields
	StderrExpanded *string `json:"stderr_expanded,omitempty"`

	// Stdin Path to stdin file
	Stdin *string `json:"stdin,omitempty"`

	// StdinExpanded Job stdin with expanded fields
	StdinExpanded *string `json:"stdin_expanded,omitempty"`

	// Stdout Path to stdout file
	Stdout *string `json:"stdout,omitempty"`

	// StdoutExpanded Job stdout with expanded fields
	StdoutExpanded *string        `json:"stdout_expanded,omitempty"`
	Steps          *V0043StepList `json:"steps,omitempty"`

	// SubmitLine Command used to submit the job
	SubmitLine *string `json:"submit_line,omitempty"`
	Time       *struct {
		// Elapsed Elapsed time in seconds
		Elapsed *int32 `json:"elapsed,omitempty"`

		// Eligible Time when the job became eligible to run (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
		Eligible *int64 `json:"eligible,omitempty"`

		// End End time (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
		End     *int64                  `json:"end,omitempty"`
		Limit   *V0043Uint32NoValStruct `json:"limit,omitempty"`
		Planned *V0043Uint64NoValStruct `json:"planned,omitempty"`

		// Start Time execution began (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
		Start *int64 `json:"start,omitempty"`

		// Submission Time when the job was submitted (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
		Submission *int64 `json:"submission,omitempty"`

		// Suspended Total time in suspended state in seconds
		Suspended *int32 `json:"suspended,omitempty"`
		System    *struct {
			// Microseconds System CPU time used by the job in microseconds
			Microseconds *int64 `json:"microseconds,omitempty"`

			// Seconds System CPU time used by the job in seconds
			Seconds *int64 `json:"seconds,omitempty"`
		} `json:"system,omitempty"`
		Total *struct {
			// Microseconds Sum of System and User CPU time used by the job in microseconds
			Microseconds *int64 `json:"microseconds,omitempty"`

			// Seconds Sum of System and User CPU time used by the job in seconds
			Seconds *int64 `json:"seconds,omitempty"`
		} `json:"total,omitempty"`
		User *struct {
			// Microseconds User CPU time used by the job in microseconds
			Microseconds *int64 `json:"microseconds,omitempty"`

			// Seconds User CPU time used by the job in seconds
			Seconds *int64 `json:"seconds,omitempty"`
		} `json:"user,omitempty"`
	} `json:"time,omitempty"`
	Tres *struct {
		Allocated *V0043TresList `json:"allocated,omitempty"`
		Requested *V0043TresList `json:"requested,omitempty"`
	} `json:"tres,omitempty"`

	// UsedGres Generic resources used by job
	UsedGres *string `json:"used_gres,omitempty"`

	// User User that owns the job
	User  *string              `json:"user,omitempty"`
	Wckey *V0043WckeyTagStruct `json:"wckey,omitempty"`

	// WorkingDirectory Path to current working directory
	WorkingDirectory *string `json:"working_directory,omitempty"`
}

// V0043JobFlags defines model for V0043Job.Flags.
type V0043JobFlags string

// V0043JobStateCurrent defines model for V0043Job.State.Current.
type V0043JobStateCurrent string

// V0043JobAllocReq defines model for v0.0.43_job_alloc_req.
type V0043JobAllocReq struct {
	Hetjob *V0043JobDescMsgList `json:"hetjob,omitempty"`
	Job    *V0043JobDescMsg     `json:"job,omitempty"`
}

// V0043JobArrayResponseArray defines model for v0.0.43_job_array_response_array.
type V0043JobArrayResponseArray = []V0043JobArrayResponseMsgEntry

// V0043JobArrayResponseMsgEntry defines model for v0.0.43_job_array_response_msg_entry.
type V0043JobArrayResponseMsgEntry struct {
	// Error Verbose update status or error
	Error *string `json:"error,omitempty"`

	// ErrorCode Verbose update status or error
	ErrorCode *int32 `json:"error_code,omitempty"`

	// JobId Job ID for updated job
	JobId *int32 `json:"job_id,omitempty"`

	// StepId Step ID for updated job
	StepId *string `json:"step_id,omitempty"`

	// Why Update response message
	Why *string `json:"why,omitempty"`
}

// V0043JobDescMsg defines model for v0.0.43_job_desc_msg.
type V0043JobDescMsg struct {
	// Account Account associated with the job
	Account *string `json:"account,omitempty"`

	// AccountGatherFrequency Job accounting and profiling sampling intervals in seconds
	AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

	// AdminComment Arbitrary comment made by administrator
	AdminComment *string `json:"admin_comment,omitempty"`

	// AllocationNodeList Local node making the resource allocation
	AllocationNodeList *string `json:"allocation_node_list,omitempty"`

	// AllocationNodePort Port to send allocation confirmation to
	AllocationNodePort *int32            `json:"allocation_node_port,omitempty"`
	Argv               *V0043StringArray `json:"argv,omitempty"`

	// Array Job array index value specification
	Array *string `json:"array,omitempty"`

	// BatchFeatures Features required for batch script's node
	BatchFeatures *string                 `json:"batch_features,omitempty"`
	BeginTime     *V0043Uint64NoValStruct `json:"begin_time,omitempty"`

	// BurstBuffer Burst buffer specifications
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// ClusterConstraint Required features that a federated cluster must have to have a sibling job submitted to it
	ClusterConstraint *string `json:"cluster_constraint,omitempty"`

	// Clusters Clusters that a federated job can run on
	Clusters *string `json:"clusters,omitempty"`

	// Comment Arbitrary comment made by user
	Comment *string `json:"comment,omitempty"`

	// Constraints Comma-separated list of features that are required
	Constraints *string `json:"constraints,omitempty"`

	// Container Absolute path to OCI container bundle
	Container *string `json:"container,omitempty"`

	// ContainerId OCI container ID
	ContainerId *string `json:"container_id,omitempty"`

	// Contiguous True if job requires contiguous nodes
	Contiguous *bool `json:"contiguous,omitempty"`

	// CoreSpecification Specialized core count
	CoreSpecification *int32 `json:"core_specification,omitempty"`

	// CpuBinding Method for binding tasks to allocated CPUs
	CpuBinding *string `json:"cpu_binding,omitempty"`

	// CpuBindingFlags Flags for CPU binding
	CpuBindingFlags *[]V0043JobDescMsgCpuBindingFlags `json:"cpu_binding_flags,omitempty"`

	// CpuFrequency Requested CPU frequency range <p1>[-p2][:p3]
	CpuFrequency *string `json:"cpu_frequency,omitempty"`

	// CpusPerTask Number of CPUs required by each task
	CpusPerTask *int32 `json:"cpus_per_task,omitempty"`

	// CpusPerTres Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
	CpusPerTres *string         `json:"cpus_per_tres,omitempty"`
	Crontab     *V0043CronEntry `json:"crontab,omitempty"`

	// CurrentWorkingDirectory Working directory to use for the job
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// Deadline Latest time that the job may start (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
	Deadline *int64 `json:"deadline,omitempty"`

	// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
	DelayBoot *int32 `json:"delay_boot,omitempty"`

	// Dependency Other jobs that must meet certain criteria before this job can start
	Dependency *string `json:"dependency,omitempty"`

	// Distribution Layout
	Distribution          *string                 `json:"distribution,omitempty"`
	DistributionPlaneSize *V0043Uint16NoValStruct `json:"distribution_plane_size,omitempty"`

	// EndTime Expected end time (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
	EndTime       *int64            `json:"end_time,omitempty"`
	Environment   *V0043StringArray `json:"environment,omitempty"`
	ExcludedNodes *V0043CsvString   `json:"excluded_nodes,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// Flags Job flags
	Flags *[]V0043JobDescMsgFlags `json:"flags,omitempty"`

	// GroupId Group ID of the user that owns the job
	GroupId *string `json:"group_id,omitempty"`

	// HetjobGroup Unique sequence number applied to this component of the heterogeneous job
	HetjobGroup *int32 `json:"hetjob_group,omitempty"`

	// Hold Hold (true) or release (false) job (Job held)
	Hold *bool `json:"hold,omitempty"`

	// Immediate If true, exit if resources are not available within the time period specified
	Immediate *bool `json:"immediate,omitempty"`

	// JobId Job ID
	JobId *int32 `json:"job_id,omitempty"`

	// KillOnNodeFail If true, kill job on node failure
	KillOnNodeFail   *bool                   `json:"kill_on_node_fail,omitempty"`
	KillWarningDelay *V0043Uint16NoValStruct `json:"kill_warning_delay,omitempty"`

	// KillWarningFlags Flags related to job signals
	KillWarningFlags *[]V0043JobDescMsgKillWarningFlags `json:"kill_warning_flags,omitempty"`

	// KillWarningSignal Signal to send when approaching end time (e.g. "10" or "USR1")
	KillWarningSignal *string `json:"kill_warning_signal,omitempty"`

	// Licenses License(s) required by the job
	Licenses *string `json:"licenses,omitempty"`

	// MailType Mail event type(s)
	MailType *[]V0043JobDescMsgMailType `json:"mail_type,omitempty"`

	// MailUser User to receive email notifications
	MailUser *string `json:"mail_user,omitempty"`

	// MaximumCpus Maximum number of CPUs required
	MaximumCpus *int32 `json:"maximum_cpus,omitempty"`

	// MaximumNodes Maximum node count
	MaximumNodes *int32 `json:"maximum_nodes,omitempty"`

	// McsLabel Multi-Category Security label on the job
	McsLabel *string `json:"mcs_label,omitempty"`

	// MemoryBinding Binding map for map/mask_cpu
	MemoryBinding *string `json:"memory_binding,omitempty"`

	// MemoryBindingType Method for binding tasks to memory
	MemoryBindingType *[]V0043JobDescMsgMemoryBindingType `json:"memory_binding_type,omitempty"`
	MemoryPerCpu      *V0043Uint64NoValStruct             `json:"memory_per_cpu,omitempty"`
	MemoryPerNode     *V0043Uint64NoValStruct             `json:"memory_per_node,omitempty"`

	// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
	MemoryPerTres *string `json:"memory_per_tres,omitempty"`

	// MinimumBoardsPerNode Boards per node required
	MinimumBoardsPerNode *int32 `json:"minimum_boards_per_node,omitempty"`

	// MinimumCpus Minimum number of CPUs required
	MinimumCpus *int32 `json:"minimum_cpus,omitempty"`

	// MinimumCpusPerNode Minimum number of CPUs per node
	MinimumCpusPerNode *int32 `json:"minimum_cpus_per_node,omitempty"`

	// MinimumNodes Minimum node count
	MinimumNodes *int32 `json:"minimum_nodes,omitempty"`

	// MinimumSocketsPerBoard Sockets per board required
	MinimumSocketsPerBoard *int32 `json:"minimum_sockets_per_board,omitempty"`

	// Name Job name
	Name *string `json:"name,omitempty"`

	// Network Network specs for job step
	Network *string `json:"network,omitempty"`

	// Nice Requested job priority change
	Nice *int32 `json:"nice,omitempty"`

	// Nodes Node count range specification (e.g. 1-15:4)
	Nodes *string `json:"nodes,omitempty"`

	// NtasksPerTres Number of tasks that can access each GPU
	NtasksPerTres *int32 `json:"ntasks_per_tres,omitempty"`

	// OomKillStep Kill whole step in case of OOM in one of the tasks
	OomKillStep *int32 `json:"oom_kill_step,omitempty"`

	// OpenMode Open mode used for stdout and stderr files
	OpenMode *[]V0043JobDescMsgOpenMode `json:"open_mode,omitempty"`

	// Overcommit Overcommit resources
	Overcommit *bool `json:"overcommit,omitempty"`

	// Partition Partition assigned to the job
	Partition *string `json:"partition,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	PowerFlags *[]interface{} `json:"power_flags,omitempty"`

	// Prefer Comma-separated list of features that are preferred but not required
	Prefer   *string                 `json:"prefer,omitempty"`
	Priority *V0043Uint32NoValStruct `json:"priority,omitempty"`

	// Profile Profile used by the acct_gather_profile plugin
	Profile *[]V0043JobDescMsgProfile `json:"profile,omitempty"`

	// Qos Quality of Service assigned to the job
	Qos *string `json:"qos,omitempty"`

	// Reboot Node reboot requested before start
	Reboot *bool `json:"reboot,omitempty"`

	// Requeue Determines whether the job may be requeued
	Requeue          *bool                   `json:"requeue,omitempty"`
	RequiredNodes    *V0043CsvString         `json:"required_nodes,omitempty"`
	RequiredSwitches *V0043Uint32NoValStruct `json:"required_switches,omitempty"`

	// Reservation Name of reservation to use
	Reservation *string `json:"reservation,omitempty"`

	// ReservePorts Port to send various notification msg to
	ReservePorts *int32 `json:"reserve_ports,omitempty"`
	Rlimits      *struct {
		As      *V0043Uint64NoValStruct `json:"as,omitempty"`
		Core    *V0043Uint64NoValStruct `json:"core,omitempty"`
		Cpu     *V0043Uint64NoValStruct `json:"cpu,omitempty"`
		Data    *V0043Uint64NoValStruct `json:"data,omitempty"`
		Fsize   *V0043Uint64NoValStruct `json:"fsize,omitempty"`
		Memlock *V0043Uint64NoValStruct `json:"memlock,omitempty"`
		Nofile  *V0043Uint64NoValStruct `json:"nofile,omitempty"`
		Nproc   *V0043Uint64NoValStruct `json:"nproc,omitempty"`
		Rss     *V0043Uint64NoValStruct `json:"rss,omitempty"`
		Stack   *V0043Uint64NoValStruct `json:"stack,omitempty"`
	} `json:"rlimits,omitempty"`

	// Script Job batch script; only the first component in a HetJob is populated or honored
	Script      *string                 `json:"script,omitempty"`
	SegmentSize *V0043Uint16NoValStruct `json:"segment_size,omitempty"`

	// SelinuxContext SELinux context
	SelinuxContext *string `json:"selinux_context,omitempty"`

	// Shared How the job can share resources with other jobs, if at all
	Shared *[]V0043JobDescMsgShared `json:"shared,omitempty"`

	// SiteFactor Site-specific priority factor
	SiteFactor *int32 `json:"site_factor,omitempty"`

	// SocketsPerNode Sockets per node required
	SocketsPerNode   *int32            `json:"sockets_per_node,omitempty"`
	SpankEnvironment *V0043StringArray `json:"spank_environment,omitempty"`

	// StandardError Path to stderr file
	StandardError *string `json:"standard_error,omitempty"`

	// StandardInput Path to stdin file
	StandardInput *string `json:"standard_input,omitempty"`

	// StandardOutput Path to stdout file
	StandardOutput *string `json:"standard_output,omitempty"`

	// Tasks Number of tasks
	Tasks *int32 `json:"tasks,omitempty"`

	// TasksPerBoard Number of tasks to invoke on each board
	TasksPerBoard *int32 `json:"tasks_per_board,omitempty"`

	// TasksPerCore Number of tasks to invoke on each core
	TasksPerCore *int32 `json:"tasks_per_core,omitempty"`

	// TasksPerNode Number of tasks to invoke on each node
	TasksPerNode *int32 `json:"tasks_per_node,omitempty"`

	// TasksPerSocket Number of tasks to invoke on each socket
	TasksPerSocket *int32 `json:"tasks_per_socket,omitempty"`

	// TemporaryDiskPerNode Minimum tmp disk space required per node
	TemporaryDiskPerNode *int32 `json:"temporary_disk_per_node,omitempty"`

	// ThreadSpecification Specialized thread count
	ThreadSpecification *int32 `json:"thread_specification,omitempty"`

	// ThreadsPerCore Threads per core required
	ThreadsPerCore *int32                  `json:"threads_per_core,omitempty"`
	TimeLimit      *V0043Uint32NoValStruct `json:"time_limit,omitempty"`
	TimeMinimum    *V0043Uint32NoValStruct `json:"time_minimum,omitempty"`

	// TresBind Task to TRES binding directives
	TresBind *string `json:"tres_bind,omitempty"`

	// TresFreq TRES frequency directives
	TresFreq *string `json:"tres_freq,omitempty"`

	// TresPerJob Comma-separated list of TRES=# values to be allocated for every job
	TresPerJob *string `json:"tres_per_job,omitempty"`

	// TresPerNode Comma-separated list of TRES=# values to be allocated for every node
	TresPerNode *string `json:"tres_per_node,omitempty"`

	// TresPerSocket Comma-separated list of TRES=# values to be allocated for every socket
	TresPerSocket *string `json:"tres_per_socket,omitempty"`

	// TresPerTask Comma-separated list of TRES=# values to be allocated for every task
	TresPerTask *string `json:"tres_per_task,omitempty"`

	// UserId User ID that owns the job
	UserId *string `json:"user_id,omitempty"`

	// WaitAllNodes If true, wait to start until after all nodes have booted
	WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

	// WaitForSwitch Maximum time to wait for switches in seconds
	WaitForSwitch *int32 `json:"wait_for_switch,omitempty"`

	// Wckey Workload characterization key
	Wckey *string `json:"wckey,omitempty"`

	// X11 X11 forwarding options
	X11 *[]V0043JobDescMsgX11 `json:"x11,omitempty"`

	// X11MagicCookie Magic cookie for X11 forwarding
	X11MagicCookie *string `json:"x11_magic_cookie,omitempty"`

	// X11TargetHost Hostname or UNIX socket if x11_target_port=0
	X11TargetHost *string `json:"x11_target_host,omitempty"`

	// X11TargetPort TCP port
	X11TargetPort *int32 `json:"x11_target_port,omitempty"`
}

// V0043JobDescMsgCpuBindingFlags defines model for V0043JobDescMsg.CpuBindingFlags.
type V0043JobDescMsgCpuBindingFlags string

// V0043JobDescMsgFlags defines model for V0043JobDescMsg.Flags.
type V0043JobDescMsgFlags string

// V0043JobDescMsgKillWarningFlags defines model for V0043JobDescMsg.KillWarningFlags.
type V0043JobDescMsgKillWarningFlags string

// V0043JobDescMsgMailType defines model for V0043JobDescMsg.MailType.
type V0043JobDescMsgMailType string

// V0043JobDescMsgMemoryBindingType defines model for V0043JobDescMsg.MemoryBindingType.
type V0043JobDescMsgMemoryBindingType string

// V0043JobDescMsgOpenMode defines model for V0043JobDescMsg.OpenMode.
type V0043JobDescMsgOpenMode string

// V0043JobDescMsgProfile defines model for V0043JobDescMsg.Profile.
type V0043JobDescMsgProfile string

// V0043JobDescMsgShared defines model for V0043JobDescMsg.Shared.
type V0043JobDescMsgShared string

// V0043JobDescMsgX11 defines model for V0043JobDescMsg.X11.
type V0043JobDescMsgX11 string

// V0043JobDescMsgList defines model for v0.0.43_job_desc_msg_list.
type V0043JobDescMsgList = []V0043JobDescMsg

// V0043JobInfo defines model for v0.0.43_job_info.
type V0043JobInfo struct {
	// Account Account associated with the job
	Account    *string                 `json:"account,omitempty"`
	AccrueTime *V0043Uint64NoValStruct `json:"accrue_time,omitempty"`

	// AdminComment Arbitrary comment made by administrator
	AdminComment *string `json:"admin_comment,omitempty"`

	// AllocatingNode Local node making the resource allocation
	AllocatingNode *string                 `json:"allocating_node,omitempty"`
	ArrayJobId     *V0043Uint32NoValStruct `json:"array_job_id,omitempty"`
	ArrayMaxTasks  *V0043Uint32NoValStruct `json:"array_max_tasks,omitempty"`
	ArrayTaskId    *V0043Uint32NoValStruct `json:"array_task_id,omitempty"`

	// ArrayTaskString String expression of task IDs in this record
	ArrayTaskString *string `json:"array_task_string,omitempty"`

	// AssociationId Unique identifier for the association
	AssociationId *int32 `json:"association_id,omitempty"`

	// BatchFeatures Features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// BatchFlag True if batch job
	BatchFlag *bool `json:"batch_flag,omitempty"`

	// BatchHost Name of host running batch script
	BatchHost    *string                  `json:"batch_host,omitempty"`
	BillableTres *V0043Float64NoValStruct `json:"billable_tres,omitempty"`

	// BurstBuffer Burst buffer specifications
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// BurstBufferState Burst buffer state details
	BurstBufferState *string `json:"burst_buffer_state,omitempty"`

	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`

	// ClusterFeatures List of required cluster features
	ClusterFeatures *string `json:"cluster_features,omitempty"`

	// Command Executed command
	Command *string `json:"command,omitempty"`

	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// Container Absolute path to OCI container bundle
	Container *string `json:"container,omitempty"`

	// ContainerId OCI container ID
	ContainerId *string `json:"container_id,omitempty"`

	// Contiguous True if job requires contiguous nodes
	Contiguous *bool `json:"contiguous,omitempty"`

	// CoreSpec Specialized core count
	CoreSpec             *int32                  `json:"core_spec,omitempty"`
	CoresPerSocket       *V0043Uint16NoValStruct `json:"cores_per_socket,omitempty"`
	CpuFrequencyGovernor *V0043Uint32NoValStruct `json:"cpu_frequency_governor,omitempty"`
	CpuFrequencyMaximum  *V0043Uint32NoValStruct `json:"cpu_frequency_maximum,omitempty"`
	CpuFrequencyMinimum  *V0043Uint32NoValStruct `json:"cpu_frequency_minimum,omitempty"`
	Cpus                 *V0043Uint32NoValStruct `json:"cpus,omitempty"`
	CpusPerTask          *V0043Uint16NoValStruct `json:"cpus_per_task,omitempty"`

	// CpusPerTres Semicolon delimited list of TRES=# values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
	CpusPerTres *string `json:"cpus_per_tres,omitempty"`

	// Cron Time specification for scrontab job
	Cron *string `json:"cron,omitempty"`

	// CurrentWorkingDirectory Working directory to use for the job
	CurrentWorkingDirectory *string                 `json:"current_working_directory,omitempty"`
	Deadline                *V0043Uint64NoValStruct `json:"deadline,omitempty"`
	DelayBoot               *V0043Uint32NoValStruct `json:"delay_boot,omitempty"`

	// Dependency Other jobs that must meet certain criteria before this job can start
	Dependency      *string                      `json:"dependency,omitempty"`
	DerivedExitCode *V0043ProcessExitCodeVerbose `json:"derived_exit_code,omitempty"`
	EligibleTime    *V0043Uint64NoValStruct      `json:"eligible_time,omitempty"`
	EndTime         *V0043Uint64NoValStruct      `json:"end_time,omitempty"`

	// ExcludedNodes Comma-separated list of nodes that may not be used
	ExcludedNodes *string                      `json:"excluded_nodes,omitempty"`
	ExitCode      *V0043ProcessExitCodeVerbose `json:"exit_code,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// FailedNode Name of node that caused job failure
	FailedNode *string `json:"failed_node,omitempty"`

	// Features Comma-separated list of features that are required
	Features *string `json:"features,omitempty"`

	// FederationOrigin Origin cluster's name (when using federation)
	FederationOrigin *string `json:"federation_origin,omitempty"`

	// FederationSiblingsActive Active sibling job names
	FederationSiblingsActive *string `json:"federation_siblings_active,omitempty"`

	// FederationSiblingsViable Viable sibling job names
	FederationSiblingsViable *string `json:"federation_siblings_viable,omitempty"`

	// Flags Job flags
	Flags      *[]V0043JobInfoFlags    `json:"flags,omitempty"`
	GresDetail *V0043JobInfoGresDetail `json:"gres_detail,omitempty"`

	// GroupId Group ID of the user that owns the job
	GroupId *int32 `json:"group_id,omitempty"`

	// GroupName Group name of the user that owns the job
	GroupName *string                 `json:"group_name,omitempty"`
	HetJobId  *V0043Uint32NoValStruct `json:"het_job_id,omitempty"`

	// HetJobIdSet Job ID range for all heterogeneous job components
	HetJobIdSet  *string                 `json:"het_job_id_set,omitempty"`
	HetJobOffset *V0043Uint32NoValStruct `json:"het_job_offset,omitempty"`

	// Hold Hold (true) or release (false) job (Job held)
	Hold *bool `json:"hold,omitempty"`

	// JobId Job ID
	JobId        *int32          `json:"job_id,omitempty"`
	JobResources *V0043JobRes    `json:"job_resources,omitempty"`
	JobSizeStr   *V0043CsvString `json:"job_size_str,omitempty"`

	// JobState Current state
	JobState            *[]V0043JobInfoJobState `json:"job_state,omitempty"`
	LastSchedEvaluation *V0043Uint64NoValStruct `json:"last_sched_evaluation,omitempty"`

	// Licenses License(s) required by the job
	Licenses *string `json:"licenses,omitempty"`

	// LicensesAllocated License(s) allocated to the job
	LicensesAllocated *string `json:"licenses_allocated,omitempty"`

	// MailType Mail event type(s)
	MailType *[]V0043JobInfoMailType `json:"mail_type,omitempty"`

	// MailUser User to receive email notifications
	MailUser *string                 `json:"mail_user,omitempty"`
	MaxCpus  *V0043Uint32NoValStruct `json:"max_cpus,omitempty"`
	MaxNodes *V0043Uint32NoValStruct `json:"max_nodes,omitempty"`

	// MaximumSwitchWaitTime Maximum time to wait for switches in seconds
	MaximumSwitchWaitTime *int32 `json:"maximum_switch_wait_time,omitempty"`

	// McsLabel Multi-Category Security label on the job
	McsLabel      *string                 `json:"mcs_label,omitempty"`
	MemoryPerCpu  *V0043Uint64NoValStruct `json:"memory_per_cpu,omitempty"`
	MemoryPerNode *V0043Uint64NoValStruct `json:"memory_per_node,omitempty"`

	// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
	MemoryPerTres         *string                 `json:"memory_per_tres,omitempty"`
	MinimumCpusPerNode    *V0043Uint16NoValStruct `json:"minimum_cpus_per_node,omitempty"`
	MinimumTmpDiskPerNode *V0043Uint32NoValStruct `json:"minimum_tmp_disk_per_node,omitempty"`

	// Name Job name
	Name *string `json:"name,omitempty"`

	// Network Network specs for the job
	Network *string `json:"network,omitempty"`

	// Nice Requested job priority change
	Nice      *int32                  `json:"nice,omitempty"`
	NodeCount *V0043Uint32NoValStruct `json:"node_count,omitempty"`

	// Nodes Node(s) allocated to the job
	Nodes *string `json:"nodes,omitempty"`

	// Partition Partition assigned to the job
	Partition *string `json:"partition,omitempty"`
	Power     *struct {
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Flags *[]interface{} `json:"flags,omitempty"`
	} `json:"power,omitempty"`
	PreSusTime      *V0043Uint64NoValStruct `json:"pre_sus_time,omitempty"`
	PreemptTime     *V0043Uint64NoValStruct `json:"preempt_time,omitempty"`
	PreemptableTime *V0043Uint64NoValStruct `json:"preemptable_time,omitempty"`

	// Prefer Feature(s) the job requested but that are not required
	Prefer              *string                   `json:"prefer,omitempty"`
	Priority            *V0043Uint32NoValStruct   `json:"priority,omitempty"`
	PriorityByPartition *V0043PriorityByPartition `json:"priority_by_partition,omitempty"`

	// Profile Profile used by the acct_gather_profile plugin
	Profile *[]V0043JobInfoProfile `json:"profile,omitempty"`

	// Qos Quality of Service assigned to the job, if pending the QOS requested
	Qos *string `json:"qos,omitempty"`

	// Reboot Node reboot requested before start
	Reboot *bool `json:"reboot,omitempty"`

	// Requeue Determines whether the job may be requeued
	Requeue *bool `json:"requeue,omitempty"`

	// RequiredNodes Comma-separated list of required nodes
	RequiredNodes *string `json:"required_nodes,omitempty"`

	// RequiredSwitches Maximum number of switches
	RequiredSwitches *int32                  `json:"required_switches,omitempty"`
	ResizeTime       *V0043Uint64NoValStruct `json:"resize_time,omitempty"`

	// RestartCnt Number of job restarts
	RestartCnt *int32 `json:"restart_cnt,omitempty"`

	// ResvName Name of reservation to use
	ResvName *string `json:"resv_name,omitempty"`

	// ScheduledNodes List of nodes scheduled to be used for the job
	ScheduledNodes *string `json:"scheduled_nodes,omitempty"`

	// SegmentSize Requested segment size
	SegmentSize *int32 `json:"segment_size,omitempty"`

	// SelinuxContext SELinux context
	SelinuxContext *string `json:"selinux_context,omitempty"`

	// Shared How the job can share resources with other jobs, if at all
	Shared *[]V0043JobInfoShared `json:"shared,omitempty"`

	// SocketsPerBoard Number of sockets per board required
	SocketsPerBoard *int32                  `json:"sockets_per_board,omitempty"`
	SocketsPerNode  *V0043Uint16NoValStruct `json:"sockets_per_node,omitempty"`

	// StandardError Path to stderr file
	StandardError *string `json:"standard_error,omitempty"`

	// StandardInput Path to stdin file
	StandardInput *string `json:"standard_input,omitempty"`

	// StandardOutput Path to stdout file
	StandardOutput *string                 `json:"standard_output,omitempty"`
	StartTime      *V0043Uint64NoValStruct `json:"start_time,omitempty"`

	// StateDescription Optional details for state_reason
	StateDescription *string `json:"state_description,omitempty"`

	// StateReason Reason for current Pending or Failed state
	StateReason *string `json:"state_reason,omitempty"`

	// StderrExpanded Job stderr with expanded fields
	StderrExpanded *string `json:"stderr_expanded,omitempty"`

	// StdinExpanded Job stdin with expanded fields
	StdinExpanded *string `json:"stdin_expanded,omitempty"`

	// StdoutExpanded Job stdout with expanded fields
	StdoutExpanded *string                 `json:"stdout_expanded,omitempty"`
	SubmitTime     *V0043Uint64NoValStruct `json:"submit_time,omitempty"`
	SuspendTime    *V0043Uint64NoValStruct `json:"suspend_time,omitempty"`

	// SystemComment Arbitrary comment from slurmctld
	SystemComment  *string                 `json:"system_comment,omitempty"`
	Tasks          *V0043Uint32NoValStruct `json:"tasks,omitempty"`
	TasksPerBoard  *V0043Uint16NoValStruct `json:"tasks_per_board,omitempty"`
	TasksPerCore   *V0043Uint16NoValStruct `json:"tasks_per_core,omitempty"`
	TasksPerNode   *V0043Uint16NoValStruct `json:"tasks_per_node,omitempty"`
	TasksPerSocket *V0043Uint16NoValStruct `json:"tasks_per_socket,omitempty"`
	TasksPerTres   *V0043Uint16NoValStruct `json:"tasks_per_tres,omitempty"`

	// ThreadSpec Specialized thread count
	ThreadSpec     *int32                  `json:"thread_spec,omitempty"`
	ThreadsPerCore *V0043Uint16NoValStruct `json:"threads_per_core,omitempty"`
	TimeLimit      *V0043Uint32NoValStruct `json:"time_limit,omitempty"`
	TimeMinimum    *V0043Uint32NoValStruct `json:"time_minimum,omitempty"`

	// TresAllocStr TRES used by the job
	TresAllocStr *string `json:"tres_alloc_str,omitempty"`

	// TresBind Task to TRES binding directives
	TresBind *string `json:"tres_bind,omitempty"`

	// TresFreq TRES frequency directives
	TresFreq *string `json:"tres_freq,omitempty"`

	// TresPerJob Comma-separated list of TRES=# values to be allocated per job
	TresPerJob *string `json:"tres_per_job,omitempty"`

	// TresPerNode Comma-separated list of TRES=# values to be allocated per node
	TresPerNode *string `json:"tres_per_node,omitempty"`

	// TresPerSocket Comma-separated list of TRES=# values to be allocated per socket
	TresPerSocket *string `json:"tres_per_socket,omitempty"`

	// TresPerTask Comma-separated list of TRES=# values to be allocated per task
	TresPerTask *string `json:"tres_per_task,omitempty"`

	// TresReqStr TRES requested by the job
	TresReqStr *string `json:"tres_req_str,omitempty"`

	// UserId User ID that owns the job
	UserId *int32 `json:"user_id,omitempty"`

	// UserName User name that owns the job
	UserName *string `json:"user_name,omitempty"`

	// Wckey Workload characterization key
	Wckey *string `json:"wckey,omitempty"`
}

// V0043JobInfoFlags defines model for V0043JobInfo.Flags.
type V0043JobInfoFlags string

// V0043JobInfoJobState defines model for V0043JobInfo.JobState.
type V0043JobInfoJobState string

// V0043JobInfoMailType defines model for V0043JobInfo.MailType.
type V0043JobInfoMailType string

// V0043JobInfoProfile defines model for V0043JobInfo.Profile.
type V0043JobInfoProfile string

// V0043JobInfoShared defines model for V0043JobInfo.Shared.
type V0043JobInfoShared string

// V0043JobInfoGresDetail defines model for v0.0.43_job_info_gres_detail.
type V0043JobInfoGresDetail = []string

// V0043JobInfoMsg defines model for v0.0.43_job_info_msg.
type V0043JobInfoMsg = []V0043JobInfo

// V0043JobList defines model for v0.0.43_job_list.
type V0043JobList = []V0043Job

// V0043JobRes defines model for v0.0.43_job_res.
type V0043JobRes struct {
	// Cpus Number of allocated CPUs
	Cpus  int32 `json:"cpus"`
	Nodes *struct {
		// Allocation Job resources for a node
		Allocation *V0043JobResNodes `json:"allocation,omitempty"`

		// Count Number of allocated nodes
		Count *int32 `json:"count,omitempty"`

		// List Node(s) allocated to the job
		List *string `json:"list,omitempty"`

		// SelectType Node scheduling selection method
		SelectType *[]V0043JobResNodesSelectType `json:"select_type,omitempty"`

		// Whole Whether whole nodes were allocated
		Whole *bool `json:"whole,omitempty"`
	} `json:"nodes,omitempty"`

	// SelectType Scheduler consumable resource selection type
	SelectType     []V0043JobResSelectType `json:"select_type"`
	ThreadsPerCore V0043Uint16NoValStruct  `json:"threads_per_core"`
}

// V0043JobResNodesSelectType defines model for V0043JobRes.Nodes.SelectType.
type V0043JobResNodesSelectType string

// V0043JobResSelectType defines model for V0043JobRes.SelectType.
type V0043JobResSelectType string

// V0043JobResCore defines model for v0.0.43_job_res_core.
type V0043JobResCore struct {
	// Index Core index
	Index int32 `json:"index"`

	// Status Core status
	Status []V0043JobResCoreStatus `json:"status"`
}

// V0043JobResCoreStatus defines model for V0043JobResCore.Status.
type V0043JobResCoreStatus string

// V0043JobResCoreArray defines model for v0.0.43_job_res_core_array.
type V0043JobResCoreArray = []V0043JobResCore

// V0043JobResNode defines model for v0.0.43_job_res_node.
type V0043JobResNode struct {
	Cpus *struct {
		// Count Total number of CPUs assigned to job
		Count *int32 `json:"count,omitempty"`

		// Used Total number of CPUs used by job
		Used *int32 `json:"used,omitempty"`
	} `json:"cpus,omitempty"`

	// Index Node index
	Index  int32 `json:"index"`
	Memory *struct {
		// Allocated Total memory (MiB) allocated to job
		Allocated *int64 `json:"allocated,omitempty"`

		// Used Total memory (MiB) used by job
		Used *int64 `json:"used,omitempty"`
	} `json:"memory,omitempty"`

	// Name Node name
	Name    string                 `json:"name"`
	Sockets V0043JobResSocketArray `json:"sockets"`
}

// V0043JobResNodes Job resources for a node
type V0043JobResNodes = []V0043JobResNode

// V0043JobResSocket defines model for v0.0.43_job_res_socket.
type V0043JobResSocket struct {
	Cores V0043JobResCoreArray `json:"cores"`

	// Index Core index
	Index int32 `json:"index"`
}

// V0043JobResSocketArray defines model for v0.0.43_job_res_socket_array.
type V0043JobResSocketArray = []V0043JobResSocket

// V0043JobSubmitReq defines model for v0.0.43_job_submit_req.
type V0043JobSubmitReq struct {
	Job  *V0043JobDescMsg     `json:"job,omitempty"`
	Jobs *V0043JobDescMsgList `json:"jobs,omitempty"`

	// Script Deprecated; Populate script field in jobs[0] or job
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Script *string `json:"script,omitempty"`
}

// V0043KillJobsMsg defines model for v0.0.43_kill_jobs_msg.
type V0043KillJobsMsg struct {
	// Account Filter jobs to a specific account
	Account *string `json:"account,omitempty"`

	// Flags Filter jobs according to flags
	Flags *[]V0043KillJobsMsgFlags `json:"flags,omitempty"`

	// JobName Filter jobs to a specific name
	JobName *string `json:"job_name,omitempty"`

	// JobState Filter jobs to a specific state
	JobState *[]V0043KillJobsMsgJobState `json:"job_state,omitempty"`
	Jobs     *V0043KillJobsMsgJobsArray  `json:"jobs,omitempty"`
	Nodes    *V0043HostlistString        `json:"nodes,omitempty"`

	// Partition Filter jobs to a specific partition
	Partition *string `json:"partition,omitempty"`

	// Qos Filter jobs to a specific QOS
	Qos *string `json:"qos,omitempty"`

	// Reservation Filter jobs to a specific reservation
	Reservation *string `json:"reservation,omitempty"`

	// Signal Signal to send to jobs
	Signal *string `json:"signal,omitempty"`

	// UserId Filter jobs to a specific numeric user id
	UserId *string `json:"user_id,omitempty"`

	// UserName Filter jobs to a specific user name
	UserName *string `json:"user_name,omitempty"`

	// Wckey Filter jobs to a specific wckey
	Wckey *string `json:"wckey,omitempty"`
}

// V0043KillJobsMsgFlags defines model for V0043KillJobsMsg.Flags.
type V0043KillJobsMsgFlags string

// V0043KillJobsMsgJobState defines model for V0043KillJobsMsg.JobState.
type V0043KillJobsMsgJobState string

// V0043KillJobsMsgJobsArray defines model for v0.0.43_kill_jobs_msg_jobs_array.
type V0043KillJobsMsgJobsArray = []string

// V0043KillJobsRespJob defines model for v0.0.43_kill_jobs_resp_job.
type V0043KillJobsRespJob struct {
	Error *struct {
		// Code Numeric error encountered signaling job
		Code *int32 `json:"code,omitempty"`

		// Message Error message why signaling job failed
		Message *string `json:"message,omitempty"`

		// String String error encountered signaling job
		String *string `json:"string,omitempty"`
	} `json:"error,omitempty"`
	Federation *struct {
		// Sibling Name of federation sibling (may be empty for non-federation)
		Sibling *string `json:"sibling,omitempty"`
	} `json:"federation,omitempty"`
	JobId V0043Uint32NoValStruct `json:"job_id"`

	// StepId Job or Step ID that signaling failed
	StepId string `json:"step_id"`
}

// V0043KillJobsRespMsg List of jobs signal responses
type V0043KillJobsRespMsg = []V0043KillJobsRespJob

// V0043License defines model for v0.0.43_license.
type V0043License struct {
	// Free Number of licenses currently available
	Free *int32 `json:"Free,omitempty"`

	// LastConsumed Last known number of licenses that were consumed in the license manager (Remote Only)
	LastConsumed *int32 `json:"LastConsumed,omitempty"`

	// LastDeficit Number of "missing licenses" from the cluster's perspective
	LastDeficit *int32 `json:"LastDeficit,omitempty"`

	// LastUpdate When the license information was last updated (UNIX Timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
	LastUpdate *int64 `json:"LastUpdate,omitempty"`

	// LicenseName Name of the license
	LicenseName *string `json:"LicenseName,omitempty"`

	// Remote Indicates whether licenses are served by the database
	Remote *bool `json:"Remote,omitempty"`

	// Reserved Number of licenses reserved
	Reserved *int32 `json:"Reserved,omitempty"`

	// Total Total number of licenses present
	Total *int32 `json:"Total,omitempty"`

	// Used Number of licenses in use
	Used *int32 `json:"Used,omitempty"`
}

// V0043Licenses defines model for v0.0.43_licenses.
type V0043Licenses = []V0043License

// V0043Node defines model for v0.0.43_node.
type V0043Node struct {
	ActiveFeatures *V0043CsvString `json:"active_features,omitempty"`

	// Address NodeAddr, used to establish a communication path
	Address *string `json:"address,omitempty"`

	// AllocCpus Total number of CPUs currently allocated for jobs
	AllocCpus *int32 `json:"alloc_cpus,omitempty"`

	// AllocIdleCpus Total number of idle CPUs
	AllocIdleCpus *int32 `json:"alloc_idle_cpus,omitempty"`

	// AllocMemory Total memory in MB currently allocated for jobs
	AllocMemory *int64 `json:"alloc_memory,omitempty"`

	// Architecture Computer architecture
	Architecture *string `json:"architecture,omitempty"`

	// Boards Number of Baseboards in nodes with a baseboard controller
	Boards   *int32                  `json:"boards,omitempty"`
	BootTime *V0043Uint64NoValStruct `json:"boot_time,omitempty"`

	// BurstbufferNetworkAddress Alternate network path to be used for sbcast network traffic
	BurstbufferNetworkAddress *string `json:"burstbuffer_network_address,omitempty"`

	// CertFlags Certmgr status flags
	CertFlags *[]V0043NodeCertFlags `json:"cert_flags,omitempty"`

	// ClusterName Cluster name (only set in federated environments)
	ClusterName *string `json:"cluster_name,omitempty"`

	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// Cores Number of cores in a single physical processor socket
	Cores *int32 `json:"cores,omitempty"`

	// CpuBinding Default method for binding tasks to allocated CPUs
	CpuBinding *int32 `json:"cpu_binding,omitempty"`

	// CpuLoad CPU load as reported by the OS
	CpuLoad *int32 `json:"cpu_load,omitempty"`

	// Cpus Total CPUs, including cores and threads
	Cpus *int32 `json:"cpus,omitempty"`

	// EffectiveCpus Number of effective CPUs (excluding specialized CPUs)
	EffectiveCpus *int32                 `json:"effective_cpus,omitempty"`
	Energy        *V0043AcctGatherEnergy `json:"energy,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	ExternalSensors *map[string]interface{} `json:"external_sensors,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra    *string                 `json:"extra,omitempty"`
	Features *V0043CsvString         `json:"features,omitempty"`
	FreeMem  *V0043Uint64NoValStruct `json:"free_mem,omitempty"`

	// GpuSpec CPU cores reserved for jobs that also use a GPU
	GpuSpec *string `json:"gpu_spec,omitempty"`

	// Gres Generic resources
	Gres *string `json:"gres,omitempty"`

	// GresDrained Drained generic resources
	GresDrained *string `json:"gres_drained,omitempty"`

	// GresUsed Generic resources currently in use
	GresUsed *string `json:"gres_used,omitempty"`

	// Hostname NodeHostname
	Hostname *string `json:"hostname,omitempty"`

	// InstanceId Cloud instance ID
	InstanceId *string `json:"instance_id,omitempty"`

	// InstanceType Cloud instance type
	InstanceType *string                 `json:"instance_type,omitempty"`
	LastBusy     *V0043Uint64NoValStruct `json:"last_busy,omitempty"`

	// McsLabel Multi-Category Security label
	McsLabel *string `json:"mcs_label,omitempty"`

	// Name NodeName
	Name *string `json:"name,omitempty"`

	// NextStateAfterReboot The state the node will be assigned after rebooting
	NextStateAfterReboot *[]V0043NodeNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`

	// OperatingSystem Operating system reported by the node
	OperatingSystem *string `json:"operating_system,omitempty"`

	// Owner User allowed to run jobs on this node (unset if no restriction)
	Owner      *string         `json:"owner,omitempty"`
	Partitions *V0043CsvString `json:"partitions,omitempty"`

	// Port TCP port number of the slurmd
	Port *int32 `json:"port,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Power *map[string]interface{} `json:"power,omitempty"`

	// RealMemory Total memory in MB on the node
	RealMemory *int64 `json:"real_memory,omitempty"`

	// Reason Describes why the node is in a "DOWN", "DRAINED", "DRAINING", "FAILING" or "FAIL" state
	Reason          *string                 `json:"reason,omitempty"`
	ReasonChangedAt *V0043Uint64NoValStruct `json:"reason_changed_at,omitempty"`

	// ReasonSetByUser User who set the reason
	ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`

	// ResCoresPerGpu Number of CPU cores per GPU restricted to GPU jobs
	ResCoresPerGpu *int32 `json:"res_cores_per_gpu,omitempty"`

	// Reservation Name of reservation containing this node
	Reservation     *string                 `json:"reservation,omitempty"`
	ResumeAfter     *V0043Uint64NoValStruct `json:"resume_after,omitempty"`
	SlurmdStartTime *V0043Uint64NoValStruct `json:"slurmd_start_time,omitempty"`

	// Sockets Number of physical processor sockets/chips on the node
	Sockets *int32 `json:"sockets,omitempty"`

	// SpecializedCores Number of cores reserved for system use
	SpecializedCores *int32 `json:"specialized_cores,omitempty"`

	// SpecializedCpus Abstract CPU IDs on this node reserved for exclusive use by slurmd and slurmstepd
	SpecializedCpus *string `json:"specialized_cpus,omitempty"`

	// SpecializedMemory Combined memory limit, in MB, for Slurm compute node daemons
	SpecializedMemory *int64 `json:"specialized_memory,omitempty"`

	// State Node state(s) applicable to this node
	State *[]V0043NodeState `json:"state,omitempty"`

	// TemporaryDisk Total size in MB of temporary disk storage in TmpFS
	TemporaryDisk *int32 `json:"temporary_disk,omitempty"`

	// Threads Number of logical threads in a single physical core
	Threads            *int32                  `json:"threads,omitempty"`
	TlsCertLastRenewal *V0043Uint64NoValStruct `json:"tls_cert_last_renewal,omitempty"`

	// Topology Topology
	Topology *string `json:"topology,omitempty"`

	// Tres Configured trackable resources
	Tres *string `json:"tres,omitempty"`

	// TresUsed Trackable resources currently allocated for jobs
	TresUsed *string `json:"tres_used,omitempty"`

	// TresWeighted Ignored. Was weighted number of billable trackable resources allocated
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	TresWeighted *float64 `json:"tres_weighted,omitempty"`

	// Version Slurmd version
	Version *string `json:"version,omitempty"`

	// Weight Weight of the node for scheduling purposes
	Weight *int32 `json:"weight,omitempty"`
}

// V0043NodeCertFlags defines model for V0043Node.CertFlags.
type V0043NodeCertFlags string

// V0043NodeNextStateAfterReboot defines model for V0043Node.NextStateAfterReboot.
type V0043NodeNextStateAfterReboot string

// V0043NodeState defines model for V0043Node.State.
type V0043NodeState string

// V0043Nodes defines model for v0.0.43_nodes.
type V0043Nodes = []V0043Node

// V0043OpenapiAccountsAddCondResp defines model for v0.0.43_openapi_accounts_add_cond_resp.
type V0043OpenapiAccountsAddCondResp struct {
	Account              *V0043AccountShort    `json:"account,omitempty"`
	AssociationCondition *V0043AccountsAddCond `json:"association_condition,omitempty"`
	Errors               *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta                 *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings             *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiAccountsAddCondRespStr defines model for v0.0.43_openapi_accounts_add_cond_resp_str.
type V0043OpenapiAccountsAddCondRespStr struct {
	// AddedAccounts added_accounts
	AddedAccounts string                `json:"added_accounts"`
	Errors        *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta          *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings      *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiAccountsRemovedResp defines model for v0.0.43_openapi_accounts_removed_resp.
type V0043OpenapiAccountsRemovedResp struct {
	Errors          *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta            *V0043OpenapiMeta     `json:"meta,omitempty"`
	RemovedAccounts V0043StringList       `json:"removed_accounts"`
	Warnings        *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiAccountsResp defines model for v0.0.43_openapi_accounts_resp.
type V0043OpenapiAccountsResp struct {
	Accounts V0043AccountList      `json:"accounts"`
	Errors   *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiAssocsRemovedResp defines model for v0.0.43_openapi_assocs_removed_resp.
type V0043OpenapiAssocsRemovedResp struct {
	Errors              *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta                *V0043OpenapiMeta     `json:"meta,omitempty"`
	RemovedAssociations V0043StringList       `json:"removed_associations"`
	Warnings            *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiAssocsResp defines model for v0.0.43_openapi_assocs_resp.
type V0043OpenapiAssocsResp struct {
	Associations V0043AssocList        `json:"associations"`
	Errors       *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta         *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings     *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiClustersRemovedResp defines model for v0.0.43_openapi_clusters_removed_resp.
type V0043OpenapiClustersRemovedResp struct {
	DeletedClusters V0043StringList       `json:"deleted_clusters"`
	Errors          *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta            *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings        *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiClustersResp defines model for v0.0.43_openapi_clusters_resp.
type V0043OpenapiClustersResp struct {
	Clusters V0043ClusterRecList   `json:"clusters"`
	Errors   *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiDiagResp defines model for v0.0.43_openapi_diag_resp.
type V0043OpenapiDiagResp struct {
	Errors     *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta       *V0043OpenapiMeta     `json:"meta,omitempty"`
	Statistics V0043StatsMsg         `json:"statistics"`
	Warnings   *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiError defines model for v0.0.43_openapi_error.
type V0043OpenapiError struct {
	// Description Long form error description
	Description *string `json:"description,omitempty"`

	// Error Short form error description
	Error *string `json:"error,omitempty"`

	// ErrorNumber Slurm numeric error identifier
	ErrorNumber *int32 `json:"error_number,omitempty"`

	// Source Source of error or where error was first detected
	Source *string `json:"source,omitempty"`
}

// V0043OpenapiErrors defines model for v0.0.43_openapi_errors.
type V0043OpenapiErrors = []V0043OpenapiError

// V0043OpenapiInstancesResp defines model for v0.0.43_openapi_instances_resp.
type V0043OpenapiInstancesResp struct {
	Errors    *V0043OpenapiErrors   `json:"errors,omitempty"`
	Instances V0043InstanceList     `json:"instances"`
	Meta      *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings  *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiJobAllocResp defines model for v0.0.43_openapi_job_alloc_resp.
type V0043OpenapiJobAllocResp struct {
	Errors *V0043OpenapiErrors `json:"errors,omitempty"`

	// JobId Submitted Job ID
	JobId *int32 `json:"job_id,omitempty"`

	// JobSubmitUserMsg Job submission user message
	JobSubmitUserMsg *string               `json:"job_submit_user_msg,omitempty"`
	Meta             *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings         *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiJobInfoResp defines model for v0.0.43_openapi_job_info_resp.
type V0043OpenapiJobInfoResp struct {
	Errors       *V0043OpenapiErrors    `json:"errors,omitempty"`
	Jobs         V0043JobInfoMsg        `json:"jobs"`
	LastBackfill V0043Uint64NoValStruct `json:"last_backfill"`
	LastUpdate   V0043Uint64NoValStruct `json:"last_update"`
	Meta         *V0043OpenapiMeta      `json:"meta,omitempty"`
	Warnings     *V0043OpenapiWarnings  `json:"warnings,omitempty"`
}

// V0043OpenapiJobPostResponse defines model for v0.0.43_openapi_job_post_response.
type V0043OpenapiJobPostResponse struct {
	Errors   *V0043OpenapiErrors         `json:"errors,omitempty"`
	Meta     *V0043OpenapiMeta           `json:"meta,omitempty"`
	Results  *V0043JobArrayResponseArray `json:"results,omitempty"`
	Warnings *V0043OpenapiWarnings       `json:"warnings,omitempty"`
}

// V0043OpenapiJobSubmitResponse defines model for v0.0.43_openapi_job_submit_response.
type V0043OpenapiJobSubmitResponse struct {
	Errors *V0043OpenapiErrors `json:"errors,omitempty"`

	// JobId submitted Job ID
	JobId *int32 `json:"job_id,omitempty"`

	// JobSubmitUserMsg Job submission user message
	JobSubmitUserMsg *string           `json:"job_submit_user_msg,omitempty"`
	Meta             *V0043OpenapiMeta `json:"meta,omitempty"`

	// StepId submitted Step ID
	StepId   *string               `json:"step_id,omitempty"`
	Warnings *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiKillJobResp defines model for v0.0.43_openapi_kill_job_resp.
type V0043OpenapiKillJobResp struct {
	Errors *V0043OpenapiErrors `json:"errors,omitempty"`
	Meta   *V0043OpenapiMeta   `json:"meta,omitempty"`

	// Status List of jobs signal responses
	Status   V0043KillJobsRespMsg  `json:"status"`
	Warnings *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiKillJobsResp defines model for v0.0.43_openapi_kill_jobs_resp.
type V0043OpenapiKillJobsResp struct {
	Errors *V0043OpenapiErrors `json:"errors,omitempty"`
	Meta   *V0043OpenapiMeta   `json:"meta,omitempty"`

	// Status List of jobs signal responses
	Status   V0043KillJobsRespMsg  `json:"status"`
	Warnings *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiLicensesResp defines model for v0.0.43_openapi_licenses_resp.
type V0043OpenapiLicensesResp struct {
	Errors     *V0043OpenapiErrors    `json:"errors,omitempty"`
	LastUpdate V0043Uint64NoValStruct `json:"last_update"`
	Licenses   V0043Licenses          `json:"licenses"`
	Meta       *V0043OpenapiMeta      `json:"meta,omitempty"`
	Warnings   *V0043OpenapiWarnings  `json:"warnings,omitempty"`
}

// V0043OpenapiMeta defines model for v0.0.43_openapi_meta.
type V0043OpenapiMeta struct {
	Client *struct {
		// Group Client group (if known)
		Group *string `json:"group,omitempty"`

		// Source Client source description
		Source *string `json:"source,omitempty"`

		// User Client user (if known)
		User *string `json:"user,omitempty"`
	} `json:"client,omitempty"`
	Command *V0043StringArray `json:"command,omitempty"`
	Plugin  *struct {
		// AccountingStorage Slurm accounting plugin
		AccountingStorage *string `json:"accounting_storage,omitempty"`

		// DataParser Slurm data_parser plugin
		DataParser *string `json:"data_parser,omitempty"`

		// Name Slurm plugin name (if applicable)
		Name *string `json:"name,omitempty"`

		// Type Slurm plugin type (if applicable)
		Type *string `json:"type,omitempty"`
	} `json:"plugin,omitempty"`
	Slurm *struct {
		// Cluster Slurm cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Release Slurm release string
		Release *string `json:"release,omitempty"`
		Version *struct {
			// Major Slurm release major version
			Major *string `json:"major,omitempty"`

			// Micro Slurm release micro version
			Micro *string `json:"micro,omitempty"`

			// Minor Slurm release minor version
			Minor *string `json:"minor,omitempty"`
		} `json:"version,omitempty"`
	} `json:"slurm,omitempty"`
}

// V0043OpenapiNodesResp defines model for v0.0.43_openapi_nodes_resp.
type V0043OpenapiNodesResp struct {
	Errors     *V0043OpenapiErrors    `json:"errors,omitempty"`
	LastUpdate V0043Uint64NoValStruct `json:"last_update"`
	Meta       *V0043OpenapiMeta      `json:"meta,omitempty"`
	Nodes      V0043Nodes             `json:"nodes"`
	Warnings   *V0043OpenapiWarnings  `json:"warnings,omitempty"`
}

// V0043OpenapiPartitionResp defines model for v0.0.43_openapi_partition_resp.
type V0043OpenapiPartitionResp struct {
	Errors     *V0043OpenapiErrors    `json:"errors,omitempty"`
	LastUpdate V0043Uint64NoValStruct `json:"last_update"`
	Meta       *V0043OpenapiMeta      `json:"meta,omitempty"`
	Partitions V0043PartitionInfoMsg  `json:"partitions"`
	Warnings   *V0043OpenapiWarnings  `json:"warnings,omitempty"`
}

// V0043OpenapiPingArrayResp defines model for v0.0.43_openapi_ping_array_resp.
type V0043OpenapiPingArrayResp struct {
	Errors   *V0043OpenapiErrors      `json:"errors,omitempty"`
	Meta     *V0043OpenapiMeta        `json:"meta,omitempty"`
	Pings    V0043ControllerPingArray `json:"pings"`
	Warnings *V0043OpenapiWarnings    `json:"warnings,omitempty"`
}

// V0043OpenapiReservationModResp defines model for v0.0.43_openapi_reservation_mod_resp.
type V0043OpenapiReservationModResp struct {
	Errors       *V0043OpenapiErrors         `json:"errors,omitempty"`
	Meta         *V0043OpenapiMeta           `json:"meta,omitempty"`
	Reservations V0043ReservationDescMsgList `json:"reservations"`
	Warnings     *V0043OpenapiWarnings       `json:"warnings,omitempty"`
}

// V0043OpenapiReservationResp defines model for v0.0.43_openapi_reservation_resp.
type V0043OpenapiReservationResp struct {
	Errors       *V0043OpenapiErrors     `json:"errors,omitempty"`
	LastUpdate   V0043Uint64NoValStruct  `json:"last_update"`
	Meta         *V0043OpenapiMeta       `json:"meta,omitempty"`
	Reservations V0043ReservationInfoMsg `json:"reservations"`
	Warnings     *V0043OpenapiWarnings   `json:"warnings,omitempty"`
}

// V0043OpenapiResp defines model for v0.0.43_openapi_resp.
type V0043OpenapiResp struct {
	Errors   *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiSharesResp defines model for v0.0.43_openapi_shares_resp.
type V0043OpenapiSharesResp struct {
	Errors   *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0043OpenapiMeta     `json:"meta,omitempty"`
	Shares   V0043SharesRespMsg    `json:"shares"`
	Warnings *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiSlurmdbdConfigResp defines model for v0.0.43_openapi_slurmdbd_config_resp.
type V0043OpenapiSlurmdbdConfigResp struct {
	Accounts     *V0043AccountList     `json:"accounts,omitempty"`
	Associations *V0043AssocList       `json:"associations,omitempty"`
	Clusters     *V0043ClusterRecList  `json:"clusters,omitempty"`
	Errors       *V0043OpenapiErrors   `json:"errors,omitempty"`
	Instances    *V0043InstanceList    `json:"instances,omitempty"`
	Meta         *V0043OpenapiMeta     `json:"meta,omitempty"`
	Qos          *V0043QosList         `json:"qos,omitempty"`
	Tres         *V0043TresList        `json:"tres,omitempty"`
	Users        *V0043UserList        `json:"users,omitempty"`
	Warnings     *V0043OpenapiWarnings `json:"warnings,omitempty"`
	Wckeys       *V0043WckeyList       `json:"wckeys,omitempty"`
}

// V0043OpenapiSlurmdbdJobsResp defines model for v0.0.43_openapi_slurmdbd_jobs_resp.
type V0043OpenapiSlurmdbdJobsResp struct {
	Errors   *V0043OpenapiErrors   `json:"errors,omitempty"`
	Jobs     V0043JobList          `json:"jobs"`
	Meta     *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiSlurmdbdPingResp defines model for v0.0.43_openapi_slurmdbd_ping_resp.
type V0043OpenapiSlurmdbdPingResp struct {
	Errors   *V0043OpenapiErrors    `json:"errors,omitempty"`
	Meta     *V0043OpenapiMeta      `json:"meta,omitempty"`
	Pings    V0043SlurmdbdPingArray `json:"pings"`
	Warnings *V0043OpenapiWarnings  `json:"warnings,omitempty"`
}

// V0043OpenapiSlurmdbdQosRemovedResp defines model for v0.0.43_openapi_slurmdbd_qos_removed_resp.
type V0043OpenapiSlurmdbdQosRemovedResp struct {
	Errors     *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta       *V0043OpenapiMeta     `json:"meta,omitempty"`
	RemovedQos V0043StringList       `json:"removed_qos"`
	Warnings   *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiSlurmdbdQosResp defines model for v0.0.43_openapi_slurmdbd_qos_resp.
type V0043OpenapiSlurmdbdQosResp struct {
	Errors   *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0043OpenapiMeta     `json:"meta,omitempty"`
	Qos      V0043QosList          `json:"qos"`
	Warnings *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiSlurmdbdStatsResp defines model for v0.0.43_openapi_slurmdbd_stats_resp.
type V0043OpenapiSlurmdbdStatsResp struct {
	Errors     *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta       *V0043OpenapiMeta     `json:"meta,omitempty"`
	Statistics V0043StatsRec         `json:"statistics"`
	Warnings   *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiTresResp defines model for v0.0.43_openapi_tres_resp.
type V0043OpenapiTresResp struct {
	TRES     V0043TresList         `json:"TRES"`
	Errors   *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiUsersAddCondResp defines model for v0.0.43_openapi_users_add_cond_resp.
type V0043OpenapiUsersAddCondResp struct {
	AssociationCondition V0043UsersAddCond     `json:"association_condition"`
	Errors               *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta                 *V0043OpenapiMeta     `json:"meta,omitempty"`
	User                 V0043UserShort        `json:"user"`
	Warnings             *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiUsersAddCondRespStr defines model for v0.0.43_openapi_users_add_cond_resp_str.
type V0043OpenapiUsersAddCondRespStr struct {
	// AddedUsers added_users
	AddedUsers string                `json:"added_users"`
	Errors     *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta       *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings   *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiUsersResp defines model for v0.0.43_openapi_users_resp.
type V0043OpenapiUsersResp struct {
	Errors   *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0043OpenapiMeta     `json:"meta,omitempty"`
	Users    V0043UserList         `json:"users"`
	Warnings *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiWarning defines model for v0.0.43_openapi_warning.
type V0043OpenapiWarning struct {
	// Description Long form warning description
	Description *string `json:"description,omitempty"`

	// Source Source of warning or where warning was first detected
	Source *string `json:"source,omitempty"`
}

// V0043OpenapiWarnings defines model for v0.0.43_openapi_warnings.
type V0043OpenapiWarnings = []V0043OpenapiWarning

// V0043OpenapiWckeyRemovedResp defines model for v0.0.43_openapi_wckey_removed_resp.
type V0043OpenapiWckeyRemovedResp struct {
	DeletedWckeys V0043StringList       `json:"deleted_wckeys"`
	Errors        *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta          *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings      *V0043OpenapiWarnings `json:"warnings,omitempty"`
}

// V0043OpenapiWckeyResp defines model for v0.0.43_openapi_wckey_resp.
type V0043OpenapiWckeyResp struct {
	Errors   *V0043OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0043OpenapiMeta     `json:"meta,omitempty"`
	Warnings *V0043OpenapiWarnings `json:"warnings,omitempty"`
	Wckeys   V0043WckeyList        `json:"wckeys"`
}

// V0043PartPrio defines model for v0.0.43_part_prio.
type V0043PartPrio struct {
	// Partition Partition name
	Partition *string `json:"partition,omitempty"`

	// Priority Prospective job priority if it runs in this partition
	Priority *int32 `json:"priority,omitempty"`
}

// V0043PartitionInfo defines model for v0.0.43_partition_info.
type V0043PartitionInfo struct {
	Accounts *struct {
		// Allowed AllowAccounts - Comma-separated list of accounts which may execute jobs in the partition
		Allowed *string `json:"allowed,omitempty"`

		// Deny DenyAccounts - Comma-separated list of accounts which may not execute jobs in the partition
		Deny *string `json:"deny,omitempty"`
	} `json:"accounts,omitempty"`

	// Alternate Alternate - Partition name of alternate partition to be used if the state of this partition is DRAIN or INACTIVE
	Alternate *string `json:"alternate,omitempty"`

	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`
	Cpus    *struct {
		// TaskBinding CpuBind - Default method controlling how tasks are bound to allocated resources
		TaskBinding *int32 `json:"task_binding,omitempty"`

		// Total TotalCPUs - Number of CPUs available in this partition
		Total *int32 `json:"total,omitempty"`
	} `json:"cpus,omitempty"`
	Defaults *struct {
		// Job JobDefaults - Comma-separated list of job default values (this field is only used to set new defaults)
		Job *string `json:"job,omitempty"`

		// MemoryPerCpu Raw value for DefMemPerCPU or DefMemPerNode
		MemoryPerCpu           *int64                  `json:"memory_per_cpu,omitempty"`
		PartitionMemoryPerCpu  *V0043Uint64NoValStruct `json:"partition_memory_per_cpu,omitempty"`
		PartitionMemoryPerNode *V0043Uint64NoValStruct `json:"partition_memory_per_node,omitempty"`
		Time                   *V0043Uint32NoValStruct `json:"time,omitempty"`
	} `json:"defaults,omitempty"`

	// GraceTime GraceTime - Grace time in seconds to be extended to a job which has been selected for preemption
	GraceTime *int32 `json:"grace_time,omitempty"`
	Groups    *struct {
		// Allowed AllowGroups - Comma-separated list of group names which may execute jobs in this partition
		Allowed *string `json:"allowed,omitempty"`
	} `json:"groups,omitempty"`
	Maximums *struct {
		CpusPerNode   *V0043Uint32NoValStruct `json:"cpus_per_node,omitempty"`
		CpusPerSocket *V0043Uint32NoValStruct `json:"cpus_per_socket,omitempty"`

		// MemoryPerCpu Raw value for MaxMemPerCPU or MaxMemPerNode
		MemoryPerCpu  *int64                  `json:"memory_per_cpu,omitempty"`
		Nodes         *V0043Uint32NoValStruct `json:"nodes,omitempty"`
		OverTimeLimit *V0043Uint16NoValStruct `json:"over_time_limit,omitempty"`
		Oversubscribe *struct {
			// Flags Flags applicable to the OverSubscribe setting
			Flags *[]V0043PartitionInfoMaximumsOversubscribeFlags `json:"flags,omitempty"`

			// Jobs Maximum number of jobs allowed to oversubscribe resources
			Jobs *int32 `json:"jobs,omitempty"`
		} `json:"oversubscribe,omitempty"`
		PartitionMemoryPerCpu  *V0043Uint64NoValStruct `json:"partition_memory_per_cpu,omitempty"`
		PartitionMemoryPerNode *V0043Uint64NoValStruct `json:"partition_memory_per_node,omitempty"`

		// Shares OverSubscribe - Controls the ability of the partition to execute more than one job at a time on each resource
		Shares *int32                  `json:"shares,omitempty"`
		Time   *V0043Uint32NoValStruct `json:"time,omitempty"`
	} `json:"maximums,omitempty"`
	Minimums *struct {
		// Nodes MinNodes - Minimum count of nodes which may be allocated to any single job
		Nodes *int32 `json:"nodes,omitempty"`
	} `json:"minimums,omitempty"`

	// Name PartitionName - Name by which the partition may be referenced
	Name *string `json:"name,omitempty"`

	// NodeSets NodeSets - Comma-separated list of nodesets which are associated with this partition
	NodeSets *string `json:"node_sets,omitempty"`
	Nodes    *struct {
		// AllowedAllocation AllocNodes - Comma-separated list of nodes from which users can submit jobs in the partition
		AllowedAllocation *string `json:"allowed_allocation,omitempty"`

		// Configured Nodes - Comma-separated list of nodes which are associated with this partition
		Configured *string `json:"configured,omitempty"`

		// Total TotalNodes - Number of nodes available in this partition
		Total *int32 `json:"total,omitempty"`
	} `json:"nodes,omitempty"`
	Partition *struct {
		// State Current state(s)
		State *[]V0043PartitionInfoPartitionState `json:"state,omitempty"`
	} `json:"partition,omitempty"`
	Priority *struct {
		// JobFactor PriorityJobFactor - Partition factor used by priority/multifactor plugin in calculating job priority
		JobFactor *int32 `json:"job_factor,omitempty"`

		// Tier PriorityTier - Controls the order in which the scheduler evaluates jobs from different partitions
		Tier *int32 `json:"tier,omitempty"`
	} `json:"priority,omitempty"`
	Qos *struct {
		// Allowed AllowQOS - Comma-separated list of Qos which may execute jobs in the partition
		Allowed *string `json:"allowed,omitempty"`

		// Assigned QOS - QOS name containing limits that will apply to all jobs in this partition
		Assigned *string `json:"assigned,omitempty"`

		// Deny DenyQOS - Comma-separated list of Qos which may not execute jobs in the partition
		Deny *string `json:"deny,omitempty"`
	} `json:"qos,omitempty"`

	// SelectType Scheduler consumable resource selection type
	SelectType  *[]V0043PartitionInfoSelectType `json:"select_type,omitempty"`
	SuspendTime *V0043Uint32NoValStruct         `json:"suspend_time,omitempty"`
	Timeouts    *struct {
		Resume  *V0043Uint16NoValStruct `json:"resume,omitempty"`
		Suspend *V0043Uint16NoValStruct `json:"suspend,omitempty"`
	} `json:"timeouts,omitempty"`

	// Topology Topology - Name of the topology, defined in topology.yaml, used by jobs in this partition
	Topology *string `json:"topology,omitempty"`
	Tres     *struct {
		// BillingWeights TRESBillingWeights - Billing weights of each tracked TRES type that will be used in calculating the usage of a job
		BillingWeights *string `json:"billing_weights,omitempty"`

		// Configured TRES - Number of each applicable TRES type available in this partition
		Configured *string `json:"configured,omitempty"`
	} `json:"tres,omitempty"`
}

// V0043PartitionInfoMaximumsOversubscribeFlags defines model for V0043PartitionInfo.Maximums.Oversubscribe.Flags.
type V0043PartitionInfoMaximumsOversubscribeFlags string

// V0043PartitionInfoPartitionState defines model for V0043PartitionInfo.Partition.State.
type V0043PartitionInfoPartitionState string

// V0043PartitionInfoSelectType defines model for V0043PartitionInfo.SelectType.
type V0043PartitionInfoSelectType string

// V0043PartitionInfoMsg defines model for v0.0.43_partition_info_msg.
type V0043PartitionInfoMsg = []V0043PartitionInfo

// V0043PriorityByPartition defines model for v0.0.43_priority_by_partition.
type V0043PriorityByPartition = []V0043PartPrio

// V0043ProcessExitCodeVerbose defines model for v0.0.43_process_exit_code_verbose.
type V0043ProcessExitCodeVerbose struct {
	ReturnCode *V0043Uint32NoValStruct `json:"return_code,omitempty"`
	Signal     *struct {
		Id *V0043Uint16NoValStruct `json:"id,omitempty"`

		// Name Signal sent to process (name)
		Name *string `json:"name,omitempty"`
	} `json:"signal,omitempty"`

	// Status Status given by return code
	Status *[]V0043ProcessExitCodeVerboseStatus `json:"status,omitempty"`
}

// V0043ProcessExitCodeVerboseStatus defines model for V0043ProcessExitCodeVerbose.Status.
type V0043ProcessExitCodeVerboseStatus string

// V0043Qos defines model for v0.0.43_qos.
type V0043Qos struct {
	// Description Arbitrary description
	Description *string `json:"description,omitempty"`

	// Flags Flags, to avoid modifying current values specify NOT_SET
	Flags *[]V0043QosFlags `json:"flags,omitempty"`

	// Id Unique ID
	Id     *int32 `json:"id,omitempty"`
	Limits *struct {
		Factor *V0043Float64NoValStruct `json:"factor,omitempty"`

		// GraceTime GraceTime - Preemption grace time in seconds to be extended to a job which has been selected for preemption
		GraceTime *int32 `json:"grace_time,omitempty"`
		Max       *struct {
			Accruing *struct {
				Per *struct {
					Account *V0043Uint32NoValStruct `json:"account,omitempty"`
					User    *V0043Uint32NoValStruct `json:"user,omitempty"`
				} `json:"per,omitempty"`
			} `json:"accruing,omitempty"`
			ActiveJobs *struct {
				Accruing *V0043Uint32NoValStruct `json:"accruing,omitempty"`
				Count    *V0043Uint32NoValStruct `json:"count,omitempty"`
			} `json:"active_jobs,omitempty"`
			Jobs *struct {
				ActiveJobs *struct {
					Per *struct {
						Account *V0043Uint32NoValStruct `json:"account,omitempty"`
						User    *V0043Uint32NoValStruct `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"active_jobs,omitempty"`
				Count *V0043Uint32NoValStruct `json:"count,omitempty"`
				Per   *struct {
					Account *V0043Uint32NoValStruct `json:"account,omitempty"`
					User    *V0043Uint32NoValStruct `json:"user,omitempty"`
				} `json:"per,omitempty"`
			} `json:"jobs,omitempty"`
			Tres *struct {
				Minutes *struct {
					Per *struct {
						Account *V0043TresList `json:"account,omitempty"`
						Job     *V0043TresList `json:"job,omitempty"`
						Qos     *V0043TresList `json:"qos,omitempty"`
						User    *V0043TresList `json:"user,omitempty"`
					} `json:"per,omitempty"`
					Total *V0043TresList `json:"total,omitempty"`
				} `json:"minutes,omitempty"`
				Per *struct {
					Account *V0043TresList `json:"account,omitempty"`
					Job     *V0043TresList `json:"job,omitempty"`
					Node    *V0043TresList `json:"node,omitempty"`
					User    *V0043TresList `json:"user,omitempty"`
				} `json:"per,omitempty"`
				Total *V0043TresList `json:"total,omitempty"`
			} `json:"tres,omitempty"`
			WallClock *struct {
				Per *struct {
					Job *V0043Uint32NoValStruct `json:"job,omitempty"`
					Qos *V0043Uint32NoValStruct `json:"qos,omitempty"`
				} `json:"per,omitempty"`
			} `json:"wall_clock,omitempty"`
		} `json:"max,omitempty"`
		Min *struct {
			PriorityThreshold *V0043Uint32NoValStruct `json:"priority_threshold,omitempty"`
			Tres              *struct {
				Per *struct {
					Job *V0043TresList `json:"job,omitempty"`
				} `json:"per,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"min,omitempty"`
	} `json:"limits,omitempty"`

	// Name Name
	Name    *string `json:"name,omitempty"`
	Preempt *struct {
		ExemptTime *V0043Uint32NoValStruct `json:"exempt_time,omitempty"`
		List       *V0043QosPreemptList    `json:"list,omitempty"`

		// Mode PreemptMode - Mechanism used to preempt jobs or enable gang scheduling
		Mode *[]V0043QosPreemptMode `json:"mode,omitempty"`
	} `json:"preempt,omitempty"`
	Priority       *V0043Uint32NoValStruct  `json:"priority,omitempty"`
	UsageFactor    *V0043Float64NoValStruct `json:"usage_factor,omitempty"`
	UsageThreshold *V0043Float64NoValStruct `json:"usage_threshold,omitempty"`
}

// V0043QosFlags defines model for V0043Qos.Flags.
type V0043QosFlags string

// V0043QosPreemptMode defines model for V0043Qos.Preempt.Mode.
type V0043QosPreemptMode string

// V0043QosList defines model for v0.0.43_qos_list.
type V0043QosList = []V0043Qos

// V0043QosPreemptList defines model for v0.0.43_qos_preempt_list.
type V0043QosPreemptList = []string

// V0043QosStringIdList List of QOS names
type V0043QosStringIdList = []string

// V0043ReservationCoreSpec defines model for v0.0.43_reservation_core_spec.
type V0043ReservationCoreSpec struct {
	// Core IDs of reserved cores
	Core *string `json:"core,omitempty"`

	// Node Name of reserved node
	Node *string `json:"node,omitempty"`
}

// V0043ReservationDescMsg defines model for v0.0.43_reservation_desc_msg.
type V0043ReservationDescMsg struct {
	Accounts *V0043CsvString `json:"accounts,omitempty"`

	// BurstBuffer BurstBuffer
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// Comment Arbitrary string
	Comment   *string                 `json:"comment,omitempty"`
	CoreCount *V0043Uint32NoValStruct `json:"core_count,omitempty"`
	Duration  *V0043Uint32NoValStruct `json:"duration,omitempty"`
	EndTime   *V0043Uint64NoValStruct `json:"end_time,omitempty"`

	// Features Requested node features. Multiple values may be "&" separated if all features are required (AND operation) or separated by "|" if any of the specified features are required (OR operation). Parenthesis are also supported for features to be ANDed together with counts of nodes having the specified features.
	Features *string `json:"features,omitempty"`

	// Flags Flags associated with this reservation. Note, to remove flags use "NO_" prefixed flag excluding NO_HOLD_JOBS_AFTER_END
	Flags         *[]V0043ReservationDescMsgFlags `json:"flags,omitempty"`
	Groups        *V0043CsvString                 `json:"groups,omitempty"`
	Licenses      *V0043CsvString                 `json:"licenses,omitempty"`
	MaxStartDelay *V0043Uint32NoValStruct         `json:"max_start_delay,omitempty"`

	// Name ReservationName
	Name      *string                 `json:"name,omitempty"`
	NodeCount *V0043Uint32NoValStruct `json:"node_count,omitempty"`
	NodeList  *V0043HostlistString    `json:"node_list,omitempty"`

	// Partition Partition used to reserve nodes from. This will attempt to allocate all nodes in the specified partition unless you request fewer resources than are available with core_cnt, node_cnt or tres.
	Partition      *string `json:"partition,omitempty"`
	PurgeCompleted *struct {
		Time *V0043Uint32NoValStruct `json:"time,omitempty"`
	} `json:"purge_completed,omitempty"`
	StartTime *V0043Uint64NoValStruct `json:"start_time,omitempty"`
	Tres      *V0043TresList          `json:"tres,omitempty"`
	Users     *V0043CsvString         `json:"users,omitempty"`
}

// V0043ReservationDescMsgFlags defines model for V0043ReservationDescMsg.Flags.
type V0043ReservationDescMsgFlags string

// V0043ReservationDescMsgList defines model for v0.0.43_reservation_desc_msg_list.
type V0043ReservationDescMsgList = []V0043ReservationDescMsg

// V0043ReservationInfo defines model for v0.0.43_reservation_info.
type V0043ReservationInfo struct {
	// Accounts Comma-separated list of permitted accounts
	Accounts *string `json:"accounts,omitempty"`

	// BurstBuffer BurstBuffer - Burst buffer resources reserved
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// CoreCount CoreCnt - Number of cores reserved
	CoreCount           *int32                        `json:"core_count,omitempty"`
	CoreSpecializations *V0043ReservationInfoCoreSpec `json:"core_specializations,omitempty"`
	EndTime             *V0043Uint64NoValStruct       `json:"end_time,omitempty"`

	// Features Features - Expression describing the reservation's required node features
	Features *string `json:"features,omitempty"`

	// Flags Flags associated with this reservation
	Flags *[]V0043ReservationInfoFlags `json:"flags,omitempty"`

	// Groups Groups - Comma-separated list of permitted groups
	Groups *string `json:"groups,omitempty"`

	// Licenses Licenses - Comma-separated list of licenses reserved
	Licenses *string `json:"licenses,omitempty"`

	// MaxStartDelay MaxStartDelay - Maximum time an eligible job not requesting this reservation can delay a job requesting it in seconds
	MaxStartDelay *int32 `json:"max_start_delay,omitempty"`

	// Name ReservationName - Name of the reservation
	Name *string `json:"name,omitempty"`

	// NodeCount NodeCnt - Number of nodes reserved
	NodeCount *int32 `json:"node_count,omitempty"`

	// NodeList Nodes - Comma-separated list of node names and/or node ranges reserved
	NodeList *string `json:"node_list,omitempty"`

	// Partition PartitionName - Partition used to reserve nodes from
	Partition      *string `json:"partition,omitempty"`
	PurgeCompleted *struct {
		Time *V0043Uint32NoValStruct `json:"time,omitempty"`
	} `json:"purge_completed,omitempty"`
	StartTime *V0043Uint64NoValStruct `json:"start_time,omitempty"`

	// Tres Comma-separated list of required TRES
	Tres *string `json:"tres,omitempty"`

	// Users Comma-separated list of permitted users
	Users *string                 `json:"users,omitempty"`
	Watts *V0043Uint32NoValStruct `json:"watts,omitempty"`
}

// V0043ReservationInfoFlags defines model for V0043ReservationInfo.Flags.
type V0043ReservationInfoFlags string

// V0043ReservationInfoCoreSpec defines model for v0.0.43_reservation_info_core_spec.
type V0043ReservationInfoCoreSpec = []V0043ReservationCoreSpec

// V0043ReservationInfoMsg defines model for v0.0.43_reservation_info_msg.
type V0043ReservationInfoMsg = []V0043ReservationInfo

// V0043ReservationModReq defines model for v0.0.43_reservation_mod_req.
type V0043ReservationModReq struct {
	Reservations *V0043ReservationDescMsgList `json:"reservations,omitempty"`
}

// V0043RollupStats defines model for v0.0.43_rollup_stats.
type V0043RollupStats struct {
	Daily *struct {
		// Count Number of daily rollups since last_run
		Count    *int32 `json:"count,omitempty"`
		Duration *struct {
			// Last Total time spent doing daily daily rollup (seconds)
			Last *int64 `json:"last,omitempty"`

			// Max Longest daily rollup time (seconds)
			Max *int64 `json:"max,omitempty"`

			// Time Total time spent doing daily rollups (seconds)
			Time *int64 `json:"time,omitempty"`
		} `json:"duration,omitempty"`

		// LastRun Last time daily rollup ran (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
		LastRun *int64 `json:"last_run,omitempty"`
	} `json:"daily,omitempty"`
	Hourly *struct {
		// Count Number of hourly rollups since last_run
		Count    *int32 `json:"count,omitempty"`
		Duration *struct {
			// Last Total time spent doing last daily rollup (seconds)
			Last *int64 `json:"last,omitempty"`

			// Max Longest hourly rollup time (seconds)
			Max *int64 `json:"max,omitempty"`

			// Time Total time spent doing hourly rollups (seconds)
			Time *int64 `json:"time,omitempty"`
		} `json:"duration,omitempty"`

		// LastRun Last time hourly rollup ran (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
		LastRun *int64 `json:"last_run,omitempty"`
	} `json:"hourly,omitempty"`
	Monthly *struct {
		// Count Number of monthly rollups since last_run
		Count    *int32 `json:"count,omitempty"`
		Duration *struct {
			// Last Total time spent doing monthly daily rollup (seconds)
			Last *int64 `json:"last,omitempty"`

			// Max Longest monthly rollup time (seconds)
			Max *int64 `json:"max,omitempty"`

			// Time Total time spent doing monthly rollups (seconds)
			Time *int64 `json:"time,omitempty"`
		} `json:"duration,omitempty"`

		// LastRun Last time monthly rollup ran (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
		LastRun *int64 `json:"last_run,omitempty"`
	} `json:"monthly,omitempty"`
}

// V0043ScheduleExitFields defines model for v0.0.43_schedule_exit_fields.
type V0043ScheduleExitFields struct {
	// DefaultQueueDepth Reached number of jobs allowed to be tested
	DefaultQueueDepth *int32 `json:"default_queue_depth,omitempty"`

	// EndJobQueue Reached end of queue
	EndJobQueue *int32 `json:"end_job_queue,omitempty"`

	// Licenses Blocked on licenses
	Licenses *int32 `json:"licenses,omitempty"`

	// MaxJobStart Reached number of jobs allowed to start
	MaxJobStart *int32 `json:"max_job_start,omitempty"`

	// MaxRpcCnt Reached RPC limit
	MaxRpcCnt *int32 `json:"max_rpc_cnt,omitempty"`

	// MaxSchedTime Reached maximum allowed scheduler time
	MaxSchedTime *int32 `json:"max_sched_time,omitempty"`
}

// V0043SharesFloat128Tres defines model for v0.0.43_shares_float128_tres.
type V0043SharesFloat128Tres struct {
	// Name TRES name
	Name *string `json:"name,omitempty"`

	// Value TRES value
	Value *float32 `json:"value,omitempty"`
}

// V0043SharesFloat128TresList defines model for v0.0.43_shares_float128_tres_list.
type V0043SharesFloat128TresList = []V0043SharesFloat128Tres

// V0043SharesRespMsg defines model for v0.0.43_shares_resp_msg.
type V0043SharesRespMsg struct {
	Shares *V0043AssocSharesObjList `json:"shares,omitempty"`

	// TotalShares Total number of shares
	TotalShares *int64 `json:"total_shares,omitempty"`
}

// V0043SharesUint64Tres defines model for v0.0.43_shares_uint64_tres.
type V0043SharesUint64Tres struct {
	// Name TRES name
	Name  *string                 `json:"name,omitempty"`
	Value *V0043Uint64NoValStruct `json:"value,omitempty"`
}

// V0043SharesUint64TresList defines model for v0.0.43_shares_uint64_tres_list.
type V0043SharesUint64TresList = []V0043SharesUint64Tres

// V0043SlurmdbdPing defines model for v0.0.43_slurmdbd_ping.
type V0043SlurmdbdPing struct {
	// Hostname Target for ping
	Hostname string `json:"hostname"`

	// Latency Number of microseconds it took to successfully ping or timeout
	Latency int64 `json:"latency"`

	// Primary Is responding slurmdbd the primary controller (Is responding slurmctld the primary controller)
	Primary bool `json:"primary"`

	// Responding If ping RPC responded with pong from slurmdbd
	Responding bool `json:"responding"`
}

// V0043SlurmdbdPingArray defines model for v0.0.43_slurmdbd_ping_array.
type V0043SlurmdbdPingArray = []V0043SlurmdbdPing

// V0043StatsMsg defines model for v0.0.43_stats_msg.
type V0043StatsMsg struct {
	// AgentCount Number of agent threads
	AgentCount *int32 `json:"agent_count,omitempty"`

	// AgentQueueSize Number of enqueued outgoing RPC requests in an internal retry list
	AgentQueueSize *int32 `json:"agent_queue_size,omitempty"`

	// AgentThreadCount Total number of active threads created by all agent threads
	AgentThreadCount *int32 `json:"agent_thread_count,omitempty"`

	// BfActive Backfill scheduler currently running
	BfActive *bool `json:"bf_active,omitempty"`

	// BfBackfilledHetJobs Number of heterogeneous job components started through backfilling since last Slurm start
	BfBackfilledHetJobs *int32 `json:"bf_backfilled_het_jobs,omitempty"`

	// BfBackfilledJobs Number of jobs started through backfilling since last slurm start
	BfBackfilledJobs *int32 `json:"bf_backfilled_jobs,omitempty"`

	// BfCycleCounter Number of backfill scheduling cycles since last reset
	BfCycleCounter *int32 `json:"bf_cycle_counter,omitempty"`

	// BfCycleLast Execution time in microseconds of last backfill scheduling cycle
	BfCycleLast *int32 `json:"bf_cycle_last,omitempty"`

	// BfCycleMax Execution time in microseconds of longest backfill scheduling cycle
	BfCycleMax *int32 `json:"bf_cycle_max,omitempty"`

	// BfCycleMean Mean time in microseconds of backfilling scheduling cycles since last reset
	BfCycleMean *int64 `json:"bf_cycle_mean,omitempty"`

	// BfCycleSum Total time in microseconds of backfilling scheduling cycles since last reset
	BfCycleSum *int64 `json:"bf_cycle_sum,omitempty"`

	// BfDepthMean Mean number of eligible to run jobs processed during all backfilling scheduling cycles since last reset
	BfDepthMean *int64 `json:"bf_depth_mean,omitempty"`

	// BfDepthMeanTry The subset of Depth Mean that the backfill scheduler attempted to schedule
	BfDepthMeanTry *int64 `json:"bf_depth_mean_try,omitempty"`

	// BfDepthSum Total number of jobs processed during all backfilling scheduling cycles since last reset
	BfDepthSum *int32 `json:"bf_depth_sum,omitempty"`

	// BfDepthTrySum Subset of bf_depth_sum that the backfill scheduler attempted to schedule
	BfDepthTrySum *int32             `json:"bf_depth_try_sum,omitempty"`
	BfExit        *V0043BfExitFields `json:"bf_exit,omitempty"`

	// BfLastBackfilledJobs Number of jobs started through backfilling since last reset
	BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`

	// BfLastDepth Number of processed jobs during last backfilling scheduling cycle
	BfLastDepth *int32 `json:"bf_last_depth,omitempty"`

	// BfLastDepthTry Number of processed jobs during last backfilling scheduling cycle that had a chance to start using available resources
	BfLastDepthTry *int32 `json:"bf_last_depth_try,omitempty"`

	// BfQueueLen Number of jobs pending to be processed by backfilling algorithm
	BfQueueLen *int32 `json:"bf_queue_len,omitempty"`

	// BfQueueLenMean Mean number of jobs pending to be processed by backfilling algorithm
	BfQueueLenMean *int64 `json:"bf_queue_len_mean,omitempty"`

	// BfQueueLenSum Total number of jobs pending to be processed by backfilling algorithm since last reset
	BfQueueLenSum *int32 `json:"bf_queue_len_sum,omitempty"`

	// BfTableSize Number of different time slots tested by the backfill scheduler in its last iteration
	BfTableSize *int32 `json:"bf_table_size,omitempty"`

	// BfTableSizeMean Mean number of different time slots tested by the backfill scheduler
	BfTableSizeMean *int64 `json:"bf_table_size_mean,omitempty"`

	// BfTableSizeSum Total number of different time slots tested by the backfill scheduler
	BfTableSizeSum  *int32                  `json:"bf_table_size_sum,omitempty"`
	BfWhenLastCycle *V0043Uint64NoValStruct `json:"bf_when_last_cycle,omitempty"`

	// DbdAgentQueueSize Number of messages for SlurmDBD that are queued
	DbdAgentQueueSize *int32 `json:"dbd_agent_queue_size,omitempty"`

	// GettimeofdayLatency Latency of 1000 calls to the gettimeofday() syscall in microseconds, as measured at controller startup
	GettimeofdayLatency *int32                  `json:"gettimeofday_latency,omitempty"`
	JobStatesTs         *V0043Uint64NoValStruct `json:"job_states_ts,omitempty"`

	// JobsCanceled Number of jobs canceled since the last reset
	JobsCanceled *int32 `json:"jobs_canceled,omitempty"`

	// JobsCompleted Number of jobs completed since last reset
	JobsCompleted *int32 `json:"jobs_completed,omitempty"`

	// JobsFailed Number of jobs failed due to slurmd or other internal issues since last reset
	JobsFailed *int32 `json:"jobs_failed,omitempty"`

	// JobsPending Number of jobs pending at the time of listed in job_state_ts
	JobsPending *int32 `json:"jobs_pending,omitempty"`

	// JobsRunning Number of jobs running at the time of listed in job_state_ts
	JobsRunning *int32 `json:"jobs_running,omitempty"`

	// JobsStarted Number of jobs started since last reset
	JobsStarted *int32 `json:"jobs_started,omitempty"`

	// JobsSubmitted Number of jobs submitted since last reset
	JobsSubmitted *int32 `json:"jobs_submitted,omitempty"`

	// PartsPacked Zero if only RPC statistic included
	PartsPacked *int32 `json:"parts_packed,omitempty"`

	// PendingRpcs Pending RPCs
	PendingRpcs *V0043StatsMsgRpcsQueue `json:"pending_rpcs,omitempty"`

	// PendingRpcsByHostlist Pending RPCs by hostlist
	PendingRpcsByHostlist *V0043StatsMsgRpcsDump  `json:"pending_rpcs_by_hostlist,omitempty"`
	ReqTime               *V0043Uint64NoValStruct `json:"req_time,omitempty"`
	ReqTimeStart          *V0043Uint64NoValStruct `json:"req_time_start,omitempty"`

	// RpcsByMessageType RPCs by type
	RpcsByMessageType *V0043StatsMsgRpcsByType `json:"rpcs_by_message_type,omitempty"`

	// RpcsByUser RPCs by user
	RpcsByUser *V0043StatsMsgRpcsByUser `json:"rpcs_by_user,omitempty"`

	// ScheduleCycleDepth Total number of jobs processed in scheduling cycles
	ScheduleCycleDepth *int32 `json:"schedule_cycle_depth,omitempty"`

	// ScheduleCycleLast Time in microseconds for last scheduling cycle
	ScheduleCycleLast *int32 `json:"schedule_cycle_last,omitempty"`

	// ScheduleCycleMax Max time of any scheduling cycle in microseconds since last reset
	ScheduleCycleMax *int32 `json:"schedule_cycle_max,omitempty"`

	// ScheduleCycleMean Mean time in microseconds for all scheduling cycles since last reset
	ScheduleCycleMean *int64 `json:"schedule_cycle_mean,omitempty"`

	// ScheduleCycleMeanDepth Mean of the number of jobs processed in a scheduling cycle
	ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`

	// ScheduleCyclePerMinute Number of scheduling executions per minute
	ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`

	// ScheduleCycleSum Total run time in microseconds for all scheduling cycles since last reset
	ScheduleCycleSum *int32 `json:"schedule_cycle_sum,omitempty"`

	// ScheduleCycleTotal Number of scheduling cycles since last reset
	ScheduleCycleTotal *int32                   `json:"schedule_cycle_total,omitempty"`
	ScheduleExit       *V0043ScheduleExitFields `json:"schedule_exit,omitempty"`

	// ScheduleQueueLength Number of jobs pending in queue
	ScheduleQueueLength *int32 `json:"schedule_queue_length,omitempty"`

	// ServerThreadCount Number of current active slurmctld threads
	ServerThreadCount *int32 `json:"server_thread_count,omitempty"`
}

// V0043StatsMsgRpcDump defines model for v0.0.43_stats_msg_rpc_dump.
type V0043StatsMsgRpcDump struct {
	Count V0043HostlistString `json:"count"`

	// MessageType Message type as string (Slurm RPC message type)
	MessageType string `json:"message_type"`

	// TypeId Message type as integer
	TypeId int32 `json:"type_id"`
}

// V0043StatsMsgRpcQueue defines model for v0.0.43_stats_msg_rpc_queue.
type V0043StatsMsgRpcQueue struct {
	// Count Number of pending RPCs queued
	Count int32 `json:"count"`

	// MessageType Message type as string (Slurm RPC message type)
	MessageType string `json:"message_type"`

	// TypeId Message type as integer
	TypeId int32 `json:"type_id"`
}

// V0043StatsMsgRpcType defines model for v0.0.43_stats_msg_rpc_type.
type V0043StatsMsgRpcType struct {
	AverageTime V0043Uint64NoValStruct `json:"average_time"`

	// Count Number of RPCs received
	Count int32 `json:"count"`

	// CycleLast Number of RPCs processed within the last RPC queue cycle
	CycleLast int32 `json:"cycle_last"`

	// CycleMax Maximum number of RPCs processed within a RPC queue cycle since start
	CycleMax int32 `json:"cycle_max"`

	// Dropped Number of RPCs dropped
	Dropped int64 `json:"dropped"`

	// MessageType Message type as string (Slurm RPC message type)
	MessageType string `json:"message_type"`

	// Queued Number of RPCs queued
	Queued int32 `json:"queued"`

	// TotalTime Total time spent processing RPC in seconds
	TotalTime int64 `json:"total_time"`

	// TypeId Message type as integer
	TypeId int32 `json:"type_id"`
}

// V0043StatsMsgRpcUser defines model for v0.0.43_stats_msg_rpc_user.
type V0043StatsMsgRpcUser struct {
	AverageTime V0043Uint64NoValStruct `json:"average_time"`

	// Count Number of RPCs received
	Count int32 `json:"count"`

	// TotalTime Total time spent processing RPC in seconds
	TotalTime int64 `json:"total_time"`

	// User User name
	User string `json:"user"`

	// UserId User ID (numeric)
	UserId int32 `json:"user_id"`
}

// V0043StatsMsgRpcsByType RPCs by type
type V0043StatsMsgRpcsByType = []V0043StatsMsgRpcType

// V0043StatsMsgRpcsByUser RPCs by user
type V0043StatsMsgRpcsByUser = []V0043StatsMsgRpcUser

// V0043StatsMsgRpcsDump Pending RPCs by hostlist
type V0043StatsMsgRpcsDump = []V0043StatsMsgRpcDump

// V0043StatsMsgRpcsQueue Pending RPCs
type V0043StatsMsgRpcsQueue = []V0043StatsMsgRpcQueue

// V0043StatsRec defines model for v0.0.43_stats_rec.
type V0043StatsRec struct {
	RPCs    *V0043StatsRpcList `json:"RPCs,omitempty"`
	Rollups *V0043RollupStats  `json:"rollups,omitempty"`

	// TimeStart When data collection started (UNIX timestamp) (UNIX timestamp or time string recognized by Slurm (e.g., '[MM/DD[/YY]-]HH:MM[:SS]'))
	TimeStart *int64              `json:"time_start,omitempty"`
	Users     *V0043StatsUserList `json:"users,omitempty"`
}

// V0043StatsRpc defines model for v0.0.43_stats_rpc.
type V0043StatsRpc struct {
	// Count Number of RPCs processed
	Count *int32 `json:"count,omitempty"`

	// Rpc RPC type
	Rpc  *string `json:"rpc,omitempty"`
	Time *struct {
		// Average Average RPC processing time in microseconds
		Average *int64 `json:"average,omitempty"`

		// Total Total RPC processing time in microseconds
		Total *int64 `json:"total,omitempty"`
	} `json:"time,omitempty"`
}

// V0043StatsRpcList defines model for v0.0.43_stats_rpc_list.
type V0043StatsRpcList = []V0043StatsRpc

// V0043StatsUser defines model for v0.0.43_stats_user.
type V0043StatsUser struct {
	// Count Number of RPCs processed
	Count *int32 `json:"count,omitempty"`
	Time  *struct {
		// Average Average RPC processing time in microseconds
		Average *int64 `json:"average,omitempty"`

		// Total Total RPC processing time in microseconds
		Total *int64 `json:"total,omitempty"`
	} `json:"time,omitempty"`

	// User User ID
	User *string `json:"user,omitempty"`
}

// V0043StatsUserList defines model for v0.0.43_stats_user_list.
type V0043StatsUserList = []V0043StatsUser

// V0043Step defines model for v0.0.43_step.
type V0043Step struct {
	CPU *struct {
		// Governor Requested CPU frequency governor in kHz
		Governor           *string `json:"governor,omitempty"`
		RequestedFrequency *struct {
			Max *V0043Uint32NoValStruct `json:"max,omitempty"`
			Min *V0043Uint32NoValStruct `json:"min,omitempty"`
		} `json:"requested_frequency,omitempty"`
	} `json:"CPU,omitempty"`
	ExitCode *V0043ProcessExitCodeVerbose `json:"exit_code,omitempty"`

	// KillRequestUser User ID that requested termination of the step
	KillRequestUser *string `json:"kill_request_user,omitempty"`
	Nodes           *struct {
		// Count Number of nodes in the job step
		Count *int32         `json:"count,omitempty"`
		List  *V0043Hostlist `json:"list,omitempty"`

		// Range Node(s) allocated to the job step
		Range *string `json:"range,omitempty"`
	} `json:"nodes,omitempty"`

	// Pid Deprecated; Process ID
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Pid *string `json:"pid,omitempty"`

	// State Current state
	State      *[]V0043StepState `json:"state,omitempty"`
	Statistics *struct {
		CPU *struct {
			// ActualFrequency Average weighted CPU frequency of all tasks in kHz
			ActualFrequency *int64 `json:"actual_frequency,omitempty"`
		} `json:"CPU,omitempty"`
		Energy *struct {
			Consumed *V0043Uint64NoValStruct `json:"consumed,omitempty"`
		} `json:"energy,omitempty"`
	} `json:"statistics,omitempty"`
	Step *struct {
		// Id Step ID (Slurm job step ID)
		Id *string `json:"id,omitempty"`

		// Name Step name
		Name *string `json:"name,omitempty"`

		// Stderr Path to stderr file
		Stderr *string `json:"stderr,omitempty"`

		// StderrExpanded Step stderr with expanded fields
		StderrExpanded *string `json:"stderr_expanded,omitempty"`

		// Stdin Path to stdin file
		Stdin *string `json:"stdin,omitempty"`

		// StdinExpanded Step stdin with expanded fields
		StdinExpanded *string `json:"stdin_expanded,omitempty"`

		// Stdout Path to stdout file
		Stdout *string `json:"stdout,omitempty"`

		// StdoutExpanded Step stdout with expanded fields
		StdoutExpanded *string `json:"stdout_expanded,omitempty"`
	} `json:"step,omitempty"`
	Task *struct {
		// Distribution The layout of the step was when it was running
		Distribution *string `json:"distribution,omitempty"`
	} `json:"task,omitempty"`
	Tasks *struct {
		// Count Total number of tasks
		Count *int32 `json:"count,omitempty"`
	} `json:"tasks,omitempty"`
	Time *struct {
		// Elapsed Elapsed time in seconds
		Elapsed *int32                  `json:"elapsed,omitempty"`
		End     *V0043Uint64NoValStruct `json:"end,omitempty"`
		Limit   *V0043Uint32NoValStruct `json:"limit,omitempty"`
		Start   *V0043Uint64NoValStruct `json:"start,omitempty"`

		// Suspended Total time in suspended state in seconds
		Suspended *int32 `json:"suspended,omitempty"`
		System    *struct {
			// Microseconds System CPU time used by the step in microseconds
			Microseconds *int32 `json:"microseconds,omitempty"`

			// Seconds System CPU time used by the step in seconds
			Seconds *int64 `json:"seconds,omitempty"`
		} `json:"system,omitempty"`
		Total *struct {
			// Microseconds Total CPU time used by the step in microseconds
			Microseconds *int32 `json:"microseconds,omitempty"`

			// Seconds Total CPU time used by the step in seconds
			Seconds *int64 `json:"seconds,omitempty"`
		} `json:"total,omitempty"`
		User *struct {
			// Microseconds User CPU time used by the step in microseconds
			Microseconds *int32 `json:"microseconds,omitempty"`

			// Seconds User CPU time used by the step in seconds
			Seconds *int64 `json:"seconds,omitempty"`
		} `json:"user,omitempty"`
	} `json:"time,omitempty"`
	Tres *struct {
		Allocated *V0043TresList `json:"allocated,omitempty"`
		Consumed  *struct {
			Average *V0043TresList         `json:"average,omitempty"`
			Max     *V0043StepTresUsageMax `json:"max,omitempty"`
			Min     *V0043StepTresUsageMin `json:"min,omitempty"`
			Total   *V0043TresList         `json:"total,omitempty"`
		} `json:"consumed,omitempty"`
		Requested *struct {
			Average *V0043TresList       `json:"average,omitempty"`
			Max     *V0043StepTresReqMax `json:"max,omitempty"`
			Min     *V0043StepTresReqMin `json:"min,omitempty"`
			Total   *V0043TresList       `json:"total,omitempty"`
		} `json:"requested,omitempty"`
	} `json:"tres,omitempty"`
}

// V0043StepState defines model for V0043Step.State.
type V0043StepState string

// V0043StepList defines model for v0.0.43_step_list.
type V0043StepList = []V0043Step

// V0043StepTresReqMax defines model for v0.0.43_step_tres_req_max.
type V0043StepTresReqMax = []V0043Tres

// V0043StepTresReqMin defines model for v0.0.43_step_tres_req_min.
type V0043StepTresReqMin = []V0043Tres

// V0043StepTresUsageMax defines model for v0.0.43_step_tres_usage_max.
type V0043StepTresUsageMax = []V0043Tres

// V0043StepTresUsageMin defines model for v0.0.43_step_tres_usage_min.
type V0043StepTresUsageMin = []V0043Tres

// V0043StringArray defines model for v0.0.43_string_array.
type V0043StringArray = []string

// V0043StringList defines model for v0.0.43_string_list.
type V0043StringList = []string

// V0043Tres defines model for v0.0.43_tres.
type V0043Tres struct {
	// Count TRES count (0 if listed generically)
	Count *int64 `json:"count,omitempty"`

	// Id ID used in the database
	Id *int32 `json:"id,omitempty"`

	// Name TRES name (if applicable)
	Name *string `json:"name,omitempty"`

	// Type TRES type (CPU, MEM, etc)
	Type string `json:"type"`
}

// V0043TresList defines model for v0.0.43_tres_list.
type V0043TresList = []V0043Tres

// V0043Uint16NoValStruct defines model for v0.0.43_uint16_no_val_struct.
type V0043Uint16NoValStruct struct {
	// Infinite True if number has been set to infinite; "set" and "number" will be ignored
	Infinite *bool `json:"infinite,omitempty"`

	// Number If "set" is True the number will be set with value; otherwise ignore number contents
	Number *int32 `json:"number,omitempty"`

	// Set True if number has been set; False if number is unset
	Set *bool `json:"set,omitempty"`
}

// V0043Uint32NoValStruct defines model for v0.0.43_uint32_no_val_struct.
type V0043Uint32NoValStruct struct {
	// Infinite True if number has been set to infinite; "set" and "number" will be ignored
	Infinite *bool `json:"infinite,omitempty"`

	// Number If "set" is True the number will be set with value; otherwise ignore number contents
	Number *int32 `json:"number,omitempty"`

	// Set True if number has been set; False if number is unset
	Set *bool `json:"set,omitempty"`
}

// V0043Uint64NoValStruct defines model for v0.0.43_uint64_no_val_struct.
type V0043Uint64NoValStruct struct {
	// Infinite True if number has been set to infinite; "set" and "number" will be ignored
	Infinite *bool `json:"infinite,omitempty"`

	// Number If "set" is True the number will be set with value; otherwise ignore number contents
	Number *int64 `json:"number,omitempty"`

	// Set True if number has been set; False if number is unset
	Set *bool `json:"set,omitempty"`
}

// V0043UpdateNodeMsg defines model for v0.0.43_update_node_msg.
type V0043UpdateNodeMsg struct {
	Address *V0043HostlistString `json:"address,omitempty"`

	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// CpuBind Default method for binding tasks to allocated CPUs
	CpuBind *int32 `json:"cpu_bind,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra       *string         `json:"extra,omitempty"`
	Features    *V0043CsvString `json:"features,omitempty"`
	FeaturesAct *V0043CsvString `json:"features_act,omitempty"`

	// Gres Generic resources
	Gres     *string              `json:"gres,omitempty"`
	Hostname *V0043HostlistString `json:"hostname,omitempty"`
	Name     *V0043HostlistString `json:"name,omitempty"`

	// Reason Reason for node being DOWN or DRAINING
	Reason *string `json:"reason,omitempty"`

	// ReasonUid User ID to associate with the reason (needed if user root is sending message)
	ReasonUid   *string                 `json:"reason_uid,omitempty"`
	ResumeAfter *V0043Uint32NoValStruct `json:"resume_after,omitempty"`

	// State New state to assign to the node
	State *[]V0043UpdateNodeMsgState `json:"state,omitempty"`

	// TopologyStr Topology
	TopologyStr *string                 `json:"topology_str,omitempty"`
	Weight      *V0043Uint32NoValStruct `json:"weight,omitempty"`
}

// V0043UpdateNodeMsgState defines model for V0043UpdateNodeMsg.State.
type V0043UpdateNodeMsgState string

// V0043User defines model for v0.0.43_user.
type V0043User struct {
	// AdministratorLevel AdminLevel granted to the user
	AdministratorLevel *[]V0043UserAdministratorLevel `json:"administrator_level,omitempty"`
	Associations       *V0043AssocShortList           `json:"associations,omitempty"`
	Coordinators       *V0043CoordList                `json:"coordinators,omitempty"`
	Default            *struct {
		// Account Default account
		Account *string `json:"account,omitempty"`

		// Wckey Default WCKey
		Wckey *string `json:"wckey,omitempty"`
	} `json:"default,omitempty"`

	// Flags Flags associated with this user
	Flags *[]V0043UserFlags `json:"flags,omitempty"`

	// Name User name
	Name string `json:"name"`

	// OldName Previous user name
	OldName *string         `json:"old_name,omitempty"`
	Wckeys  *V0043WckeyList `json:"wckeys,omitempty"`
}

// V0043UserAdministratorLevel defines model for V0043User.AdministratorLevel.
type V0043UserAdministratorLevel string

// V0043UserFlags defines model for V0043User.Flags.
type V0043UserFlags string

// V0043UserList defines model for v0.0.43_user_list.
type V0043UserList = []V0043User

// V0043UserShort defines model for v0.0.43_user_short.
type V0043UserShort struct {
	// Adminlevel AdminLevel granted to the user
	Adminlevel *[]V0043UserShortAdminlevel `json:"adminlevel,omitempty"`

	// Defaultaccount Default account
	Defaultaccount *string `json:"defaultaccount,omitempty"`

	// Defaultwckey Default WCKey
	Defaultwckey *string `json:"defaultwckey,omitempty"`
}

// V0043UserShortAdminlevel defines model for V0043UserShort.Adminlevel.
type V0043UserShortAdminlevel string

// V0043UsersAddCond defines model for v0.0.43_users_add_cond.
type V0043UsersAddCond struct {
	Accounts    *V0043StringList  `json:"accounts,omitempty"`
	Association *V0043AssocRecSet `json:"association,omitempty"`
	Clusters    *V0043StringList  `json:"clusters,omitempty"`
	Partitions  *V0043StringList  `json:"partitions,omitempty"`
	Users       V0043StringList   `json:"users"`
	Wckeys      *V0043StringList  `json:"wckeys,omitempty"`
}

// V0043Wckey defines model for v0.0.43_wckey.
type V0043Wckey struct {
	Accounting *V0043AccountingList `json:"accounting,omitempty"`

	// Cluster Cluster name
	Cluster string `json:"cluster"`

	// Flags Flags associated with this WCKey
	Flags *[]V0043WckeyFlags `json:"flags,omitempty"`

	// Id Unique ID for this user-cluster-wckey combination
	Id *int32 `json:"id,omitempty"`

	// Name WCKey name
	Name string `json:"name"`

	// User User name
	User string `json:"user"`
}

// V0043WckeyFlags defines model for V0043Wckey.Flags.
type V0043WckeyFlags string

// V0043WckeyList defines model for v0.0.43_wckey_list.
type V0043WckeyList = []V0043Wckey

// V0043WckeyTagStruct defines model for v0.0.43_wckey_tag_struct.
type V0043WckeyTagStruct struct {
	// Flags Active flags
	Flags []V0043WckeyTagStructFlags `json:"flags"`

	// Wckey WCKey name
	Wckey string `json:"wckey"`
}

// V0043WckeyTagStructFlags defines model for V0043WckeyTagStruct.Flags.
type V0043WckeyTagStructFlags string

// SlurmV0043DeleteJobParams defines parameters for SlurmV0043DeleteJob.
type SlurmV0043DeleteJobParams struct {
	// Signal Signal to send to Job
	Signal *string `form:"signal,omitempty" json:"signal,omitempty"`

	// Flags Signalling flags
	Flags *SlurmV0043DeleteJobParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0043DeleteJobParamsFlags defines parameters for SlurmV0043DeleteJob.
type SlurmV0043DeleteJobParamsFlags string

// SlurmV0043GetJobParams defines parameters for SlurmV0043GetJob.
type SlurmV0043GetJobParams struct {
	// UpdateTime Query jobs updated more recently than this time (UNIX timestamp)
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0043GetJobParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0043GetJobParamsFlags defines parameters for SlurmV0043GetJob.
type SlurmV0043GetJobParamsFlags string

// SlurmV0043GetJobsParams defines parameters for SlurmV0043GetJobs.
type SlurmV0043GetJobsParams struct {
	// UpdateTime Query jobs updated more recently than this time (UNIX timestamp)
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0043GetJobsParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0043GetJobsParamsFlags defines parameters for SlurmV0043GetJobs.
type SlurmV0043GetJobsParamsFlags string

// SlurmV0043GetJobsStateParams defines parameters for SlurmV0043GetJobsState.
type SlurmV0043GetJobsStateParams struct {
	// JobId CSV list of Job IDs to search for
	JobId *string `form:"job_id,omitempty" json:"job_id,omitempty"`
}

// SlurmV0043GetNodeParams defines parameters for SlurmV0043GetNode.
type SlurmV0043GetNodeParams struct {
	// UpdateTime Query jobs updated more recently than this time (UNIX timestamp)
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0043GetNodeParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0043GetNodeParamsFlags defines parameters for SlurmV0043GetNode.
type SlurmV0043GetNodeParamsFlags string

// SlurmV0043GetNodesParams defines parameters for SlurmV0043GetNodes.
type SlurmV0043GetNodesParams struct {
	// UpdateTime Query jobs updated more recently than this time (UNIX timestamp)
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0043GetNodesParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0043GetNodesParamsFlags defines parameters for SlurmV0043GetNodes.
type SlurmV0043GetNodesParamsFlags string

// SlurmV0043GetPartitionParams defines parameters for SlurmV0043GetPartition.
type SlurmV0043GetPartitionParams struct {
	// UpdateTime Query partitions updated more recently than this time (UNIX timestamp)
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0043GetPartitionParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0043GetPartitionParamsFlags defines parameters for SlurmV0043GetPartition.
type SlurmV0043GetPartitionParamsFlags string

// SlurmV0043GetPartitionsParams defines parameters for SlurmV0043GetPartitions.
type SlurmV0043GetPartitionsParams struct {
	// UpdateTime Query partitions updated more recently than this time (UNIX timestamp)
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0043GetPartitionsParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0043GetPartitionsParamsFlags defines parameters for SlurmV0043GetPartitions.
type SlurmV0043GetPartitionsParamsFlags string

// SlurmV0043GetReservationParams defines parameters for SlurmV0043GetReservation.
type SlurmV0043GetReservationParams struct {
	// UpdateTime Query reservations updated more recently than this time (UNIX timestamp)
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0043GetReservationsParams defines parameters for SlurmV0043GetReservations.
type SlurmV0043GetReservationsParams struct {
	// UpdateTime Query reservations updated more recently than this time (UNIX timestamp)
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0043GetSharesParams defines parameters for SlurmV0043GetShares.
type SlurmV0043GetSharesParams struct {
	// Accounts Accounts to query
	Accounts *string `form:"accounts,omitempty" json:"accounts,omitempty"`

	// Users Users to query
	Users *string `form:"users,omitempty" json:"users,omitempty"`
}

// SlurmdbV0043GetAccountParams defines parameters for SlurmdbV0043GetAccount.
type SlurmdbV0043GetAccountParams struct {
	// WithAssocs Include associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords Include coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithDeleted Include deleted
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0043GetAccountsParams defines parameters for SlurmdbV0043GetAccounts.
type SlurmdbV0043GetAccountsParams struct {
	// Description CSV description list
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// DELETED include deleted associations
	DELETED *string `form:"DELETED,omitempty" json:"DELETED,omitempty"`

	// WithAssociations query includes associations
	WithAssociations *string `form:"WithAssociations,omitempty" json:"WithAssociations,omitempty"`

	// WithCoordinators query includes coordinators
	WithCoordinators *string `form:"WithCoordinators,omitempty" json:"WithCoordinators,omitempty"`

	// NoUsersAreCoords remove users as coordinators
	NoUsersAreCoords *string `form:"NoUsersAreCoords,omitempty" json:"NoUsersAreCoords,omitempty"`

	// UsersAreCoords users are coordinators
	UsersAreCoords *string `form:"UsersAreCoords,omitempty" json:"UsersAreCoords,omitempty"`
}

// SlurmdbV0043DeleteAssociationParams defines parameters for SlurmdbV0043DeleteAssociation.
type SlurmdbV0043DeleteAssociationParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos                 *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`
	IncludeDeletedAssociations *string `form:"Include deleted associations,omitempty" json:"Include deleted associations,omitempty"`
	IncludeUsage               *string `form:"Include usage,omitempty" json:"Include usage,omitempty"`
	FilterToOnlyDefaults       *string `form:"Filter to only defaults,omitempty" json:"Filter to only defaults,omitempty"`
	IncludeTheRawQOSOrDeltaQos *string `form:"Include the raw QOS or delta_qos,omitempty" json:"Include the raw QOS or delta_qos,omitempty"`
	IncludeSubAcctInformation  *string `form:"Include sub acct information,omitempty" json:"Include sub acct information,omitempty"`
	ExcludeParentIdname        *string `form:"Exclude parent id/name,omitempty" json:"Exclude parent id/name,omitempty"`
	ExcludeLimitsFromParents   *string `form:"Exclude limits from parents,omitempty" json:"Exclude limits from parents,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV ID list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`
}

// SlurmdbV0043GetAssociationParams defines parameters for SlurmdbV0043GetAssociation.
type SlurmdbV0043GetAssociationParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos                 *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`
	IncludeDeletedAssociations *string `form:"Include deleted associations,omitempty" json:"Include deleted associations,omitempty"`
	IncludeUsage               *string `form:"Include usage,omitempty" json:"Include usage,omitempty"`
	FilterToOnlyDefaults       *string `form:"Filter to only defaults,omitempty" json:"Filter to only defaults,omitempty"`
	IncludeTheRawQOSOrDeltaQos *string `form:"Include the raw QOS or delta_qos,omitempty" json:"Include the raw QOS or delta_qos,omitempty"`
	IncludeSubAcctInformation  *string `form:"Include sub acct information,omitempty" json:"Include sub acct information,omitempty"`
	ExcludeParentIdname        *string `form:"Exclude parent id/name,omitempty" json:"Exclude parent id/name,omitempty"`
	ExcludeLimitsFromParents   *string `form:"Exclude limits from parents,omitempty" json:"Exclude limits from parents,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV ID list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`
}

// SlurmdbV0043DeleteAssociationsParams defines parameters for SlurmdbV0043DeleteAssociations.
type SlurmdbV0043DeleteAssociationsParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos                 *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`
	IncludeDeletedAssociations *string `form:"Include deleted associations,omitempty" json:"Include deleted associations,omitempty"`
	IncludeUsage               *string `form:"Include usage,omitempty" json:"Include usage,omitempty"`
	FilterToOnlyDefaults       *string `form:"Filter to only defaults,omitempty" json:"Filter to only defaults,omitempty"`
	IncludeTheRawQOSOrDeltaQos *string `form:"Include the raw QOS or delta_qos,omitempty" json:"Include the raw QOS or delta_qos,omitempty"`
	IncludeSubAcctInformation  *string `form:"Include sub acct information,omitempty" json:"Include sub acct information,omitempty"`
	ExcludeParentIdname        *string `form:"Exclude parent id/name,omitempty" json:"Exclude parent id/name,omitempty"`
	ExcludeLimitsFromParents   *string `form:"Exclude limits from parents,omitempty" json:"Exclude limits from parents,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV ID list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`
}

// SlurmdbV0043GetAssociationsParams defines parameters for SlurmdbV0043GetAssociations.
type SlurmdbV0043GetAssociationsParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos                 *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`
	IncludeDeletedAssociations *string `form:"Include deleted associations,omitempty" json:"Include deleted associations,omitempty"`
	IncludeUsage               *string `form:"Include usage,omitempty" json:"Include usage,omitempty"`
	FilterToOnlyDefaults       *string `form:"Filter to only defaults,omitempty" json:"Filter to only defaults,omitempty"`
	IncludeTheRawQOSOrDeltaQos *string `form:"Include the raw QOS or delta_qos,omitempty" json:"Include the raw QOS or delta_qos,omitempty"`
	IncludeSubAcctInformation  *string `form:"Include sub acct information,omitempty" json:"Include sub acct information,omitempty"`
	ExcludeParentIdname        *string `form:"Exclude parent id/name,omitempty" json:"Exclude parent id/name,omitempty"`
	ExcludeLimitsFromParents   *string `form:"Exclude limits from parents,omitempty" json:"Exclude limits from parents,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV ID list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`
}

// SlurmdbV0043DeleteClusterParams defines parameters for SlurmdbV0043DeleteCluster.
type SlurmdbV0043DeleteClusterParams struct {
	// Classification Type of machine
	Classification *SlurmdbV0043DeleteClusterParamsClassification `form:"classification,omitempty" json:"classification,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Federation CSV federation list
	Federation *string `form:"federation,omitempty" json:"federation,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0043DeleteClusterParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// RpcVersion CSV RPC version list
	RpcVersion *string `form:"rpc_version,omitempty" json:"rpc_version,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// WithDeleted Include deleted clusters
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`
}

// SlurmdbV0043DeleteClusterParamsClassification defines parameters for SlurmdbV0043DeleteCluster.
type SlurmdbV0043DeleteClusterParamsClassification string

// SlurmdbV0043DeleteClusterParamsFlags defines parameters for SlurmdbV0043DeleteCluster.
type SlurmdbV0043DeleteClusterParamsFlags string

// SlurmdbV0043GetClusterParams defines parameters for SlurmdbV0043GetCluster.
type SlurmdbV0043GetClusterParams struct {
	// Classification Type of machine
	Classification *SlurmdbV0043GetClusterParamsClassification `form:"classification,omitempty" json:"classification,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Federation CSV federation list
	Federation *string `form:"federation,omitempty" json:"federation,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0043GetClusterParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// RpcVersion CSV RPC version list
	RpcVersion *string `form:"rpc_version,omitempty" json:"rpc_version,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// WithDeleted Include deleted clusters
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`
}

// SlurmdbV0043GetClusterParamsClassification defines parameters for SlurmdbV0043GetCluster.
type SlurmdbV0043GetClusterParamsClassification string

// SlurmdbV0043GetClusterParamsFlags defines parameters for SlurmdbV0043GetCluster.
type SlurmdbV0043GetClusterParamsFlags string

// SlurmdbV0043GetClustersParams defines parameters for SlurmdbV0043GetClusters.
type SlurmdbV0043GetClustersParams struct {
	// UpdateTime Query reservations updated more recently than this time (UNIX timestamp)
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmdbV0043PostClustersParams defines parameters for SlurmdbV0043PostClusters.
type SlurmdbV0043PostClustersParams struct {
	// UpdateTime Query reservations updated more recently than this time (UNIX timestamp)
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmdbV0043GetInstanceParams defines parameters for SlurmdbV0043GetInstance.
type SlurmdbV0043GetInstanceParams struct {
	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Extra CSV extra list
	Extra *string `form:"extra,omitempty" json:"extra,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// InstanceId CSV instance_id list
	InstanceId *string `form:"instance_id,omitempty" json:"instance_id,omitempty"`

	// InstanceType CSV instance_type list
	InstanceType *string `form:"instance_type,omitempty" json:"instance_type,omitempty"`

	// NodeList Ranged node string
	NodeList *string `form:"node_list,omitempty" json:"node_list,omitempty"`

	// TimeEnd Time end (UNIX timestamp)
	TimeEnd *string `form:"time_end,omitempty" json:"time_end,omitempty"`

	// TimeStart Time start (UNIX timestamp)
	TimeStart *string `form:"time_start,omitempty" json:"time_start,omitempty"`
}

// SlurmdbV0043GetInstancesParams defines parameters for SlurmdbV0043GetInstances.
type SlurmdbV0043GetInstancesParams struct {
	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Extra CSV extra list
	Extra *string `form:"extra,omitempty" json:"extra,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// InstanceId CSV instance_id list
	InstanceId *string `form:"instance_id,omitempty" json:"instance_id,omitempty"`

	// InstanceType CSV instance_type list
	InstanceType *string `form:"instance_type,omitempty" json:"instance_type,omitempty"`

	// NodeList Ranged node string
	NodeList *string `form:"node_list,omitempty" json:"node_list,omitempty"`

	// TimeEnd Time end (UNIX timestamp)
	TimeEnd *string `form:"time_end,omitempty" json:"time_end,omitempty"`

	// TimeStart Time start (UNIX timestamp)
	TimeStart *string `form:"time_start,omitempty" json:"time_start,omitempty"`
}

// SlurmdbV0043GetJobsParams defines parameters for SlurmdbV0043GetJobs.
type SlurmdbV0043GetJobsParams struct {
	// Account CSV account list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Association CSV association list
	Association *string `form:"association,omitempty" json:"association,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Constraints CSV constraint list
	Constraints *string `form:"constraints,omitempty" json:"constraints,omitempty"`

	// SchedulerUnset Schedule bits not set
	SchedulerUnset *string `form:"scheduler_unset,omitempty" json:"scheduler_unset,omitempty"`

	// ScheduledOnSubmit Job was started on submit
	ScheduledOnSubmit *string `form:"scheduled_on_submit,omitempty" json:"scheduled_on_submit,omitempty"`

	// ScheduledByMain Job was started from main scheduler
	ScheduledByMain *string `form:"scheduled_by_main,omitempty" json:"scheduled_by_main,omitempty"`

	// ScheduledByBackfill Job was started from backfill
	ScheduledByBackfill *string `form:"scheduled_by_backfill,omitempty" json:"scheduled_by_backfill,omitempty"`

	// JobStarted Job start RPC was received
	JobStarted *string `form:"job_started,omitempty" json:"job_started,omitempty"`

	// ExitCode Job exit code (numeric)
	ExitCode *string `form:"exit_code,omitempty" json:"exit_code,omitempty"`

	// ShowDuplicates Include duplicate job entries
	ShowDuplicates *string `form:"show_duplicates,omitempty" json:"show_duplicates,omitempty"`

	// SkipSteps Exclude job step details
	SkipSteps *string `form:"skip_steps,omitempty" json:"skip_steps,omitempty"`

	// DisableTruncateUsageTime Do not truncate the time to usage_start and usage_end
	DisableTruncateUsageTime *string `form:"disable_truncate_usage_time,omitempty" json:"disable_truncate_usage_time,omitempty"`

	// WholeHetjob Include details on all hetjob components
	WholeHetjob *string `form:"whole_hetjob,omitempty" json:"whole_hetjob,omitempty"`

	// DisableWholeHetjob Only show details on specified hetjob components
	DisableWholeHetjob *string `form:"disable_whole_hetjob,omitempty" json:"disable_whole_hetjob,omitempty"`

	// DisableWaitForResult Tell dbd not to wait for the result
	DisableWaitForResult *string `form:"disable_wait_for_result,omitempty" json:"disable_wait_for_result,omitempty"`

	// UsageTimeAsSubmitTime Use usage_time as the submit_time of the job
	UsageTimeAsSubmitTime *string `form:"usage_time_as_submit_time,omitempty" json:"usage_time_as_submit_time,omitempty"`

	// ShowBatchScript Include job script
	ShowBatchScript *string `form:"show_batch_script,omitempty" json:"show_batch_script,omitempty"`

	// ShowJobEnvironment Include job environment
	ShowJobEnvironment *string `form:"show_job_environment,omitempty" json:"show_job_environment,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Groups CSV group list
	Groups *string `form:"groups,omitempty" json:"groups,omitempty"`

	// JobName CSV job name list
	JobName *string `form:"job_name,omitempty" json:"job_name,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS name list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// Reason CSV reason list
	Reason *string `form:"reason,omitempty" json:"reason,omitempty"`

	// Reservation CSV reservation name list
	Reservation *string `form:"reservation,omitempty" json:"reservation,omitempty"`

	// ReservationId CSV reservation ID list
	ReservationId *string `form:"reservation_id,omitempty" json:"reservation_id,omitempty"`

	// State CSV state list
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Step CSV step id list
	Step *string `form:"step,omitempty" json:"step,omitempty"`

	// EndTime Usage end (UNIX timestamp)
	EndTime *string `form:"end_time,omitempty" json:"end_time,omitempty"`

	// StartTime Usage start (UNIX timestamp)
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty"`

	// Node Ranged node string where jobs ran
	Node *string `form:"node,omitempty" json:"node,omitempty"`

	// Users CSV user name list
	Users *string `form:"users,omitempty" json:"users,omitempty"`

	// Wckey CSV WCKey list
	Wckey *string `form:"wckey,omitempty" json:"wckey,omitempty"`
}

// SlurmdbV0043GetQosParams defines parameters for SlurmdbV0043GetQos.
type SlurmdbV0043GetQosParams struct {
	// Description CSV description list
	Description       *string `form:"description,omitempty" json:"description,omitempty"`
	IncludeDeletedQOS *string `form:"Include deleted QOS,omitempty" json:"Include deleted QOS,omitempty"`

	// Id CSV QOS id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Name CSV QOS name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// PreemptMode PreemptMode used when jobs in this QOS are preempted
	PreemptMode *SlurmdbV0043GetQosParamsPreemptMode `form:"preempt_mode,omitempty" json:"preempt_mode,omitempty"`
}

// SlurmdbV0043GetQosParamsPreemptMode defines parameters for SlurmdbV0043GetQos.
type SlurmdbV0043GetQosParamsPreemptMode string

// SlurmdbV0043PostQosParams defines parameters for SlurmdbV0043PostQos.
type SlurmdbV0043PostQosParams struct {
	// Description CSV description list
	Description       *string `form:"description,omitempty" json:"description,omitempty"`
	IncludeDeletedQOS *string `form:"Include deleted QOS,omitempty" json:"Include deleted QOS,omitempty"`

	// Id CSV QOS id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Name CSV QOS name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// PreemptMode PreemptMode used when jobs in this QOS are preempted
	PreemptMode *SlurmdbV0043PostQosParamsPreemptMode `form:"preempt_mode,omitempty" json:"preempt_mode,omitempty"`
}

// SlurmdbV0043PostQosParamsPreemptMode defines parameters for SlurmdbV0043PostQos.
type SlurmdbV0043PostQosParamsPreemptMode string

// SlurmdbV0043GetSingleQosParams defines parameters for SlurmdbV0043GetSingleQos.
type SlurmdbV0043GetSingleQosParams struct {
	// WithDeleted Query includes deleted QOS
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0043GetUserParams defines parameters for SlurmdbV0043GetUser.
type SlurmdbV0043GetUserParams struct {
	// WithDeleted Include deleted users
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithAssocs Include associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords Include coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithWckeys Include WCKeys
	WithWckeys *string `form:"with_wckeys,omitempty" json:"with_wckeys,omitempty"`
}

// SlurmdbV0043GetUsersParams defines parameters for SlurmdbV0043GetUsers.
type SlurmdbV0043GetUsersParams struct {
	// AdminLevel Administrator level
	AdminLevel *SlurmdbV0043GetUsersParamsAdminLevel `form:"admin_level,omitempty" json:"admin_level,omitempty"`

	// DefaultAccount CSV default account list
	DefaultAccount *string `form:"default_account,omitempty" json:"default_account,omitempty"`

	// DefaultWckey CSV default WCKey list
	DefaultWckey *string `form:"default_wckey,omitempty" json:"default_wckey,omitempty"`

	// WithAssocs With associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords With coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithDeleted With deleted
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithWckeys With WCKeys
	WithWckeys *string `form:"with_wckeys,omitempty" json:"with_wckeys,omitempty"`

	// WithoutDefaults Exclude defaults
	WithoutDefaults *string `form:"without_defaults,omitempty" json:"without_defaults,omitempty"`
}

// SlurmdbV0043GetUsersParamsAdminLevel defines parameters for SlurmdbV0043GetUsers.
type SlurmdbV0043GetUsersParamsAdminLevel string

// SlurmdbV0043PostUsersAssociationParams defines parameters for SlurmdbV0043PostUsersAssociation.
type SlurmdbV0043PostUsersAssociationParams struct {
	// UpdateTime Query partitions updated more recently than this time (UNIX timestamp)
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0043PostUsersAssociationParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmdbV0043PostUsersAssociationParamsFlags defines parameters for SlurmdbV0043PostUsersAssociation.
type SlurmdbV0043PostUsersAssociationParamsFlags string

// SlurmdbV0043GetWckeysParams defines parameters for SlurmdbV0043GetWckeys.
type SlurmdbV0043GetWckeysParams struct {
	// Cluster CSV cluster name list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV ID list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name CSV name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// OnlyDefaults Only query defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted WCKeys
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0043PostWckeysParams defines parameters for SlurmdbV0043PostWckeys.
type SlurmdbV0043PostWckeysParams struct {
	// Cluster CSV cluster name list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV ID list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name CSV name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// OnlyDefaults Only query defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted WCKeys
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmV0043PostJobAllocateJSONRequestBody defines body for SlurmV0043PostJobAllocate for application/json ContentType.
type SlurmV0043PostJobAllocateJSONRequestBody = V0043JobAllocReq

// SlurmV0043PostJobSubmitJSONRequestBody defines body for SlurmV0043PostJobSubmit for application/json ContentType.
type SlurmV0043PostJobSubmitJSONRequestBody = V0043JobSubmitReq

// SlurmV0043PostJobJSONRequestBody defines body for SlurmV0043PostJob for application/json ContentType.
type SlurmV0043PostJobJSONRequestBody = V0043JobDescMsg

// SlurmV0043DeleteJobsJSONRequestBody defines body for SlurmV0043DeleteJobs for application/json ContentType.
type SlurmV0043DeleteJobsJSONRequestBody = V0043KillJobsMsg

// SlurmV0043PostNodeJSONRequestBody defines body for SlurmV0043PostNode for application/json ContentType.
type SlurmV0043PostNodeJSONRequestBody = V0043UpdateNodeMsg

// SlurmV0043PostNodesJSONRequestBody defines body for SlurmV0043PostNodes for application/json ContentType.
type SlurmV0043PostNodesJSONRequestBody = V0043UpdateNodeMsg

// SlurmV0043PostReservationJSONRequestBody defines body for SlurmV0043PostReservation for application/json ContentType.
type SlurmV0043PostReservationJSONRequestBody = V0043ReservationDescMsg

// SlurmV0043PostReservationsJSONRequestBody defines body for SlurmV0043PostReservations for application/json ContentType.
type SlurmV0043PostReservationsJSONRequestBody = V0043ReservationModReq

// SlurmdbV0043PostAccountsJSONRequestBody defines body for SlurmdbV0043PostAccounts for application/json ContentType.
type SlurmdbV0043PostAccountsJSONRequestBody = V0043OpenapiAccountsResp

// SlurmdbV0043PostAccountsAssociationJSONRequestBody defines body for SlurmdbV0043PostAccountsAssociation for application/json ContentType.
type SlurmdbV0043PostAccountsAssociationJSONRequestBody = V0043OpenapiAccountsAddCondResp

// SlurmdbV0043PostAssociationsJSONRequestBody defines body for SlurmdbV0043PostAssociations for application/json ContentType.
type SlurmdbV0043PostAssociationsJSONRequestBody = V0043OpenapiAssocsResp

// SlurmdbV0043PostClustersJSONRequestBody defines body for SlurmdbV0043PostClusters for application/json ContentType.
type SlurmdbV0043PostClustersJSONRequestBody = V0043OpenapiClustersResp

// SlurmdbV0043PostConfigJSONRequestBody defines body for SlurmdbV0043PostConfig for application/json ContentType.
type SlurmdbV0043PostConfigJSONRequestBody = V0043OpenapiSlurmdbdConfigResp

// SlurmdbV0043PostQosJSONRequestBody defines body for SlurmdbV0043PostQos for application/json ContentType.
type SlurmdbV0043PostQosJSONRequestBody = V0043OpenapiSlurmdbdQosResp

// SlurmdbV0043PostTresJSONRequestBody defines body for SlurmdbV0043PostTres for application/json ContentType.
type SlurmdbV0043PostTresJSONRequestBody = V0043OpenapiTresResp

// SlurmdbV0043PostUsersJSONRequestBody defines body for SlurmdbV0043PostUsers for application/json ContentType.
type SlurmdbV0043PostUsersJSONRequestBody = V0043OpenapiUsersResp

// SlurmdbV0043PostUsersAssociationJSONRequestBody defines body for SlurmdbV0043PostUsersAssociation for application/json ContentType.
type SlurmdbV0043PostUsersAssociationJSONRequestBody = V0043OpenapiUsersAddCondResp

// SlurmdbV0043PostWckeysJSONRequestBody defines body for SlurmdbV0043PostWckeys for application/json ContentType.
type SlurmdbV0043PostWckeysJSONRequestBody = V0043OpenapiWckeyResp

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SlurmV0043GetDiag request
	SlurmV0043GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043PostJobAllocateWithBody request with any body
	SlurmV0043PostJobAllocateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0043PostJobAllocate(ctx context.Context, body SlurmV0043PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043PostJobSubmitWithBody request with any body
	SlurmV0043PostJobSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0043PostJobSubmit(ctx context.Context, body SlurmV0043PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043DeleteJob request
	SlurmV0043DeleteJob(ctx context.Context, jobId string, params *SlurmV0043DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043GetJob request
	SlurmV0043GetJob(ctx context.Context, jobId string, params *SlurmV0043GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043PostJobWithBody request with any body
	SlurmV0043PostJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0043PostJob(ctx context.Context, jobId string, body SlurmV0043PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043DeleteJobsWithBody request with any body
	SlurmV0043DeleteJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0043DeleteJobs(ctx context.Context, body SlurmV0043DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043GetJobs request
	SlurmV0043GetJobs(ctx context.Context, params *SlurmV0043GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043GetJobsState request
	SlurmV0043GetJobsState(ctx context.Context, params *SlurmV0043GetJobsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043GetLicenses request
	SlurmV0043GetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043DeleteNode request
	SlurmV0043DeleteNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043GetNode request
	SlurmV0043GetNode(ctx context.Context, nodeName string, params *SlurmV0043GetNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043PostNodeWithBody request with any body
	SlurmV0043PostNodeWithBody(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0043PostNode(ctx context.Context, nodeName string, body SlurmV0043PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043GetNodes request
	SlurmV0043GetNodes(ctx context.Context, params *SlurmV0043GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043PostNodesWithBody request with any body
	SlurmV0043PostNodesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0043PostNodes(ctx context.Context, body SlurmV0043PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043GetPartition request
	SlurmV0043GetPartition(ctx context.Context, partitionName string, params *SlurmV0043GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043GetPartitions request
	SlurmV0043GetPartitions(ctx context.Context, params *SlurmV0043GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043GetPing request
	SlurmV0043GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043GetReconfigure request
	SlurmV0043GetReconfigure(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043PostReservationWithBody request with any body
	SlurmV0043PostReservationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0043PostReservation(ctx context.Context, body SlurmV0043PostReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043DeleteReservation request
	SlurmV0043DeleteReservation(ctx context.Context, reservationName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043GetReservation request
	SlurmV0043GetReservation(ctx context.Context, reservationName string, params *SlurmV0043GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043GetReservations request
	SlurmV0043GetReservations(ctx context.Context, params *SlurmV0043GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043PostReservationsWithBody request with any body
	SlurmV0043PostReservationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0043PostReservations(ctx context.Context, body SlurmV0043PostReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0043GetShares request
	SlurmV0043GetShares(ctx context.Context, params *SlurmV0043GetSharesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043DeleteAccount request
	SlurmdbV0043DeleteAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetAccount request
	SlurmdbV0043GetAccount(ctx context.Context, accountName string, params *SlurmdbV0043GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetAccounts request
	SlurmdbV0043GetAccounts(ctx context.Context, params *SlurmdbV0043GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043PostAccountsWithBody request with any body
	SlurmdbV0043PostAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0043PostAccounts(ctx context.Context, body SlurmdbV0043PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043PostAccountsAssociationWithBody request with any body
	SlurmdbV0043PostAccountsAssociationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0043PostAccountsAssociation(ctx context.Context, body SlurmdbV0043PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043DeleteAssociation request
	SlurmdbV0043DeleteAssociation(ctx context.Context, params *SlurmdbV0043DeleteAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetAssociation request
	SlurmdbV0043GetAssociation(ctx context.Context, params *SlurmdbV0043GetAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043DeleteAssociations request
	SlurmdbV0043DeleteAssociations(ctx context.Context, params *SlurmdbV0043DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetAssociations request
	SlurmdbV0043GetAssociations(ctx context.Context, params *SlurmdbV0043GetAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043PostAssociationsWithBody request with any body
	SlurmdbV0043PostAssociationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0043PostAssociations(ctx context.Context, body SlurmdbV0043PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043DeleteCluster request
	SlurmdbV0043DeleteCluster(ctx context.Context, clusterName string, params *SlurmdbV0043DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetCluster request
	SlurmdbV0043GetCluster(ctx context.Context, clusterName string, params *SlurmdbV0043GetClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetClusters request
	SlurmdbV0043GetClusters(ctx context.Context, params *SlurmdbV0043GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043PostClustersWithBody request with any body
	SlurmdbV0043PostClustersWithBody(ctx context.Context, params *SlurmdbV0043PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0043PostClusters(ctx context.Context, params *SlurmdbV0043PostClustersParams, body SlurmdbV0043PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetConfig request
	SlurmdbV0043GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043PostConfigWithBody request with any body
	SlurmdbV0043PostConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0043PostConfig(ctx context.Context, body SlurmdbV0043PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetDiag request
	SlurmdbV0043GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetInstance request
	SlurmdbV0043GetInstance(ctx context.Context, params *SlurmdbV0043GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetInstances request
	SlurmdbV0043GetInstances(ctx context.Context, params *SlurmdbV0043GetInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetJob request
	SlurmdbV0043GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetJobs request
	SlurmdbV0043GetJobs(ctx context.Context, params *SlurmdbV0043GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetPing request
	SlurmdbV0043GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetQos request
	SlurmdbV0043GetQos(ctx context.Context, params *SlurmdbV0043GetQosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043PostQosWithBody request with any body
	SlurmdbV0043PostQosWithBody(ctx context.Context, params *SlurmdbV0043PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0043PostQos(ctx context.Context, params *SlurmdbV0043PostQosParams, body SlurmdbV0043PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043DeleteSingleQos request
	SlurmdbV0043DeleteSingleQos(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetSingleQos request
	SlurmdbV0043GetSingleQos(ctx context.Context, qos string, params *SlurmdbV0043GetSingleQosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetTres request
	SlurmdbV0043GetTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043PostTresWithBody request with any body
	SlurmdbV0043PostTresWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0043PostTres(ctx context.Context, body SlurmdbV0043PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043DeleteUser request
	SlurmdbV0043DeleteUser(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetUser request
	SlurmdbV0043GetUser(ctx context.Context, name string, params *SlurmdbV0043GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetUsers request
	SlurmdbV0043GetUsers(ctx context.Context, params *SlurmdbV0043GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043PostUsersWithBody request with any body
	SlurmdbV0043PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0043PostUsers(ctx context.Context, body SlurmdbV0043PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043PostUsersAssociationWithBody request with any body
	SlurmdbV0043PostUsersAssociationWithBody(ctx context.Context, params *SlurmdbV0043PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0043PostUsersAssociation(ctx context.Context, params *SlurmdbV0043PostUsersAssociationParams, body SlurmdbV0043PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043DeleteWckey request
	SlurmdbV0043DeleteWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetWckey request
	SlurmdbV0043GetWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043GetWckeys request
	SlurmdbV0043GetWckeys(ctx context.Context, params *SlurmdbV0043GetWckeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0043PostWckeysWithBody request with any body
	SlurmdbV0043PostWckeysWithBody(ctx context.Context, params *SlurmdbV0043PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0043PostWckeys(ctx context.Context, params *SlurmdbV0043PostWckeysParams, body SlurmdbV0043PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SlurmV0043GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetDiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostJobAllocateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostJobAllocateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostJobAllocate(ctx context.Context, body SlurmV0043PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostJobAllocateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostJobSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostJobSubmitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostJobSubmit(ctx context.Context, body SlurmV0043PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostJobSubmitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043DeleteJob(ctx context.Context, jobId string, params *SlurmV0043DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043DeleteJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043GetJob(ctx context.Context, jobId string, params *SlurmV0043GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostJobRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostJob(ctx context.Context, jobId string, body SlurmV0043PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostJobRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043DeleteJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043DeleteJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043DeleteJobs(ctx context.Context, body SlurmV0043DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043DeleteJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043GetJobs(ctx context.Context, params *SlurmV0043GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043GetJobsState(ctx context.Context, params *SlurmV0043GetJobsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetJobsStateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043GetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetLicensesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043DeleteNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043DeleteNodeRequest(c.Server, nodeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043GetNode(ctx context.Context, nodeName string, params *SlurmV0043GetNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetNodeRequest(c.Server, nodeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostNodeWithBody(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostNodeRequestWithBody(c.Server, nodeName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostNode(ctx context.Context, nodeName string, body SlurmV0043PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostNodeRequest(c.Server, nodeName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043GetNodes(ctx context.Context, params *SlurmV0043GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetNodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostNodesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostNodesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostNodes(ctx context.Context, body SlurmV0043PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostNodesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043GetPartition(ctx context.Context, partitionName string, params *SlurmV0043GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetPartitionRequest(c.Server, partitionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043GetPartitions(ctx context.Context, params *SlurmV0043GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetPartitionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043GetReconfigure(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetReconfigureRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostReservationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostReservationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostReservation(ctx context.Context, body SlurmV0043PostReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostReservationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043DeleteReservation(ctx context.Context, reservationName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043DeleteReservationRequest(c.Server, reservationName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043GetReservation(ctx context.Context, reservationName string, params *SlurmV0043GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetReservationRequest(c.Server, reservationName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043GetReservations(ctx context.Context, params *SlurmV0043GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetReservationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostReservationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostReservationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043PostReservations(ctx context.Context, body SlurmV0043PostReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043PostReservationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0043GetShares(ctx context.Context, params *SlurmV0043GetSharesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0043GetSharesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043DeleteAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043DeleteAccountRequest(c.Server, accountName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetAccount(ctx context.Context, accountName string, params *SlurmdbV0043GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetAccountRequest(c.Server, accountName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetAccounts(ctx context.Context, params *SlurmdbV0043GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostAccountsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostAccounts(ctx context.Context, body SlurmdbV0043PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostAccountsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostAccountsAssociationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostAccountsAssociationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostAccountsAssociation(ctx context.Context, body SlurmdbV0043PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostAccountsAssociationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043DeleteAssociation(ctx context.Context, params *SlurmdbV0043DeleteAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043DeleteAssociationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetAssociation(ctx context.Context, params *SlurmdbV0043GetAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetAssociationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043DeleteAssociations(ctx context.Context, params *SlurmdbV0043DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043DeleteAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetAssociations(ctx context.Context, params *SlurmdbV0043GetAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostAssociationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostAssociationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostAssociations(ctx context.Context, body SlurmdbV0043PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostAssociationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043DeleteCluster(ctx context.Context, clusterName string, params *SlurmdbV0043DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043DeleteClusterRequest(c.Server, clusterName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetCluster(ctx context.Context, clusterName string, params *SlurmdbV0043GetClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetClusterRequest(c.Server, clusterName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetClusters(ctx context.Context, params *SlurmdbV0043GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostClustersWithBody(ctx context.Context, params *SlurmdbV0043PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostClustersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostClusters(ctx context.Context, params *SlurmdbV0043PostClustersParams, body SlurmdbV0043PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostClustersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostConfig(ctx context.Context, body SlurmdbV0043PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetDiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetInstance(ctx context.Context, params *SlurmdbV0043GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetInstanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetInstances(ctx context.Context, params *SlurmdbV0043GetInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetInstancesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetJobs(ctx context.Context, params *SlurmdbV0043GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetQos(ctx context.Context, params *SlurmdbV0043GetQosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetQosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostQosWithBody(ctx context.Context, params *SlurmdbV0043PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostQosRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostQos(ctx context.Context, params *SlurmdbV0043PostQosParams, body SlurmdbV0043PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostQosRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043DeleteSingleQos(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043DeleteSingleQosRequest(c.Server, qos)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetSingleQos(ctx context.Context, qos string, params *SlurmdbV0043GetSingleQosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetSingleQosRequest(c.Server, qos, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetTresRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostTresWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostTresRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostTres(ctx context.Context, body SlurmdbV0043PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostTresRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043DeleteUser(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043DeleteUserRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetUser(ctx context.Context, name string, params *SlurmdbV0043GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetUserRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetUsers(ctx context.Context, params *SlurmdbV0043GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostUsers(ctx context.Context, body SlurmdbV0043PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostUsersAssociationWithBody(ctx context.Context, params *SlurmdbV0043PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostUsersAssociationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostUsersAssociation(ctx context.Context, params *SlurmdbV0043PostUsersAssociationParams, body SlurmdbV0043PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostUsersAssociationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043DeleteWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043DeleteWckeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetWckeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043GetWckeys(ctx context.Context, params *SlurmdbV0043GetWckeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043GetWckeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostWckeysWithBody(ctx context.Context, params *SlurmdbV0043PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostWckeysRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0043PostWckeys(ctx context.Context, params *SlurmdbV0043PostWckeysParams, body SlurmdbV0043PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0043PostWckeysRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSlurmV0043GetDiagRequest generates requests for SlurmV0043GetDiag
func NewSlurmV0043GetDiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/diag/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043PostJobAllocateRequest calls the generic SlurmV0043PostJobAllocate builder with application/json body
func NewSlurmV0043PostJobAllocateRequest(server string, body SlurmV0043PostJobAllocateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0043PostJobAllocateRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0043PostJobAllocateRequestWithBody generates requests for SlurmV0043PostJobAllocate with any type of body
func NewSlurmV0043PostJobAllocateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/job/allocate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0043PostJobSubmitRequest calls the generic SlurmV0043PostJobSubmit builder with application/json body
func NewSlurmV0043PostJobSubmitRequest(server string, body SlurmV0043PostJobSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0043PostJobSubmitRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0043PostJobSubmitRequestWithBody generates requests for SlurmV0043PostJobSubmit with any type of body
func NewSlurmV0043PostJobSubmitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/job/submit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0043DeleteJobRequest generates requests for SlurmV0043DeleteJob
func NewSlurmV0043DeleteJobRequest(server string, jobId string, params *SlurmV0043DeleteJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Signal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "signal", runtime.ParamLocationQuery, *params.Signal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043GetJobRequest generates requests for SlurmV0043GetJob
func NewSlurmV0043GetJobRequest(server string, jobId string, params *SlurmV0043GetJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043PostJobRequest calls the generic SlurmV0043PostJob builder with application/json body
func NewSlurmV0043PostJobRequest(server string, jobId string, body SlurmV0043PostJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0043PostJobRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewSlurmV0043PostJobRequestWithBody generates requests for SlurmV0043PostJob with any type of body
func NewSlurmV0043PostJobRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0043DeleteJobsRequest calls the generic SlurmV0043DeleteJobs builder with application/json body
func NewSlurmV0043DeleteJobsRequest(server string, body SlurmV0043DeleteJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0043DeleteJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0043DeleteJobsRequestWithBody generates requests for SlurmV0043DeleteJobs with any type of body
func NewSlurmV0043DeleteJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0043GetJobsRequest generates requests for SlurmV0043GetJobs
func NewSlurmV0043GetJobsRequest(server string, params *SlurmV0043GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043GetJobsStateRequest generates requests for SlurmV0043GetJobsState
func NewSlurmV0043GetJobsStateRequest(server string, params *SlurmV0043GetJobsStateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/jobs/state/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043GetLicensesRequest generates requests for SlurmV0043GetLicenses
func NewSlurmV0043GetLicensesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/licenses/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043DeleteNodeRequest generates requests for SlurmV0043DeleteNode
func NewSlurmV0043DeleteNodeRequest(server string, nodeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043GetNodeRequest generates requests for SlurmV0043GetNode
func NewSlurmV0043GetNodeRequest(server string, nodeName string, params *SlurmV0043GetNodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043PostNodeRequest calls the generic SlurmV0043PostNode builder with application/json body
func NewSlurmV0043PostNodeRequest(server string, nodeName string, body SlurmV0043PostNodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0043PostNodeRequestWithBody(server, nodeName, "application/json", bodyReader)
}

// NewSlurmV0043PostNodeRequestWithBody generates requests for SlurmV0043PostNode with any type of body
func NewSlurmV0043PostNodeRequestWithBody(server string, nodeName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0043GetNodesRequest generates requests for SlurmV0043GetNodes
func NewSlurmV0043GetNodesRequest(server string, params *SlurmV0043GetNodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/nodes/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043PostNodesRequest calls the generic SlurmV0043PostNodes builder with application/json body
func NewSlurmV0043PostNodesRequest(server string, body SlurmV0043PostNodesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0043PostNodesRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0043PostNodesRequestWithBody generates requests for SlurmV0043PostNodes with any type of body
func NewSlurmV0043PostNodesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/nodes/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0043GetPartitionRequest generates requests for SlurmV0043GetPartition
func NewSlurmV0043GetPartitionRequest(server string, partitionName string, params *SlurmV0043GetPartitionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "partition_name", runtime.ParamLocationPath, partitionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/partition/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043GetPartitionsRequest generates requests for SlurmV0043GetPartitions
func NewSlurmV0043GetPartitionsRequest(server string, params *SlurmV0043GetPartitionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/partitions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043GetPingRequest generates requests for SlurmV0043GetPing
func NewSlurmV0043GetPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/ping/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043GetReconfigureRequest generates requests for SlurmV0043GetReconfigure
func NewSlurmV0043GetReconfigureRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/reconfigure/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043PostReservationRequest calls the generic SlurmV0043PostReservation builder with application/json body
func NewSlurmV0043PostReservationRequest(server string, body SlurmV0043PostReservationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0043PostReservationRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0043PostReservationRequestWithBody generates requests for SlurmV0043PostReservation with any type of body
func NewSlurmV0043PostReservationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/reservation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0043DeleteReservationRequest generates requests for SlurmV0043DeleteReservation
func NewSlurmV0043DeleteReservationRequest(server string, reservationName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reservation_name", runtime.ParamLocationPath, reservationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/reservation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043GetReservationRequest generates requests for SlurmV0043GetReservation
func NewSlurmV0043GetReservationRequest(server string, reservationName string, params *SlurmV0043GetReservationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reservation_name", runtime.ParamLocationPath, reservationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/reservation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043GetReservationsRequest generates requests for SlurmV0043GetReservations
func NewSlurmV0043GetReservationsRequest(server string, params *SlurmV0043GetReservationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/reservations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0043PostReservationsRequest calls the generic SlurmV0043PostReservations builder with application/json body
func NewSlurmV0043PostReservationsRequest(server string, body SlurmV0043PostReservationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0043PostReservationsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0043PostReservationsRequestWithBody generates requests for SlurmV0043PostReservations with any type of body
func NewSlurmV0043PostReservationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/reservations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0043GetSharesRequest generates requests for SlurmV0043GetShares
func NewSlurmV0043GetSharesRequest(server string, params *SlurmV0043GetSharesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.43/shares")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "accounts", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Users != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "users", runtime.ParamLocationQuery, *params.Users); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043DeleteAccountRequest generates requests for SlurmdbV0043DeleteAccount
func NewSlurmdbV0043DeleteAccountRequest(server string, accountName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_name", runtime.ParamLocationPath, accountName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetAccountRequest generates requests for SlurmdbV0043GetAccount
func NewSlurmdbV0043GetAccountRequest(server string, accountName string, params *SlurmdbV0043GetAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_name", runtime.ParamLocationPath, accountName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetAccountsRequest generates requests for SlurmdbV0043GetAccounts
func NewSlurmdbV0043GetAccountsRequest(server string, params *SlurmdbV0043GetAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/accounts/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DELETED != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "DELETED", runtime.ParamLocationQuery, *params.DELETED); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssociations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "WithAssociations", runtime.ParamLocationQuery, *params.WithAssociations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoordinators != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "WithCoordinators", runtime.ParamLocationQuery, *params.WithCoordinators); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoUsersAreCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "NoUsersAreCoords", runtime.ParamLocationQuery, *params.NoUsersAreCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsersAreCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "UsersAreCoords", runtime.ParamLocationQuery, *params.UsersAreCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043PostAccountsRequest calls the generic SlurmdbV0043PostAccounts builder with application/json body
func NewSlurmdbV0043PostAccountsRequest(server string, body SlurmdbV0043PostAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0043PostAccountsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0043PostAccountsRequestWithBody generates requests for SlurmdbV0043PostAccounts with any type of body
func NewSlurmdbV0043PostAccountsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/accounts/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0043PostAccountsAssociationRequest calls the generic SlurmdbV0043PostAccountsAssociation builder with application/json body
func NewSlurmdbV0043PostAccountsAssociationRequest(server string, body SlurmdbV0043PostAccountsAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0043PostAccountsAssociationRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0043PostAccountsAssociationRequestWithBody generates requests for SlurmdbV0043PostAccountsAssociation with any type of body
func NewSlurmdbV0043PostAccountsAssociationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/accounts_association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0043DeleteAssociationRequest generates requests for SlurmdbV0043DeleteAssociation
func NewSlurmdbV0043DeleteAssociationRequest(server string, params *SlurmdbV0043DeleteAssociationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeletedAssociations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include deleted associations", runtime.ParamLocationQuery, *params.IncludeDeletedAssociations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include usage", runtime.ParamLocationQuery, *params.IncludeUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterToOnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Filter to only defaults", runtime.ParamLocationQuery, *params.FilterToOnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTheRawQOSOrDeltaQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include the raw QOS or delta_qos", runtime.ParamLocationQuery, *params.IncludeTheRawQOSOrDeltaQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSubAcctInformation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include sub acct information", runtime.ParamLocationQuery, *params.IncludeSubAcctInformation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeParentIdname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Exclude parent id/name", runtime.ParamLocationQuery, *params.ExcludeParentIdname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeLimitsFromParents != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Exclude limits from parents", runtime.ParamLocationQuery, *params.ExcludeLimitsFromParents); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetAssociationRequest generates requests for SlurmdbV0043GetAssociation
func NewSlurmdbV0043GetAssociationRequest(server string, params *SlurmdbV0043GetAssociationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeletedAssociations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include deleted associations", runtime.ParamLocationQuery, *params.IncludeDeletedAssociations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include usage", runtime.ParamLocationQuery, *params.IncludeUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterToOnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Filter to only defaults", runtime.ParamLocationQuery, *params.FilterToOnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTheRawQOSOrDeltaQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include the raw QOS or delta_qos", runtime.ParamLocationQuery, *params.IncludeTheRawQOSOrDeltaQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSubAcctInformation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include sub acct information", runtime.ParamLocationQuery, *params.IncludeSubAcctInformation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeParentIdname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Exclude parent id/name", runtime.ParamLocationQuery, *params.ExcludeParentIdname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeLimitsFromParents != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Exclude limits from parents", runtime.ParamLocationQuery, *params.ExcludeLimitsFromParents); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043DeleteAssociationsRequest generates requests for SlurmdbV0043DeleteAssociations
func NewSlurmdbV0043DeleteAssociationsRequest(server string, params *SlurmdbV0043DeleteAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeletedAssociations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include deleted associations", runtime.ParamLocationQuery, *params.IncludeDeletedAssociations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include usage", runtime.ParamLocationQuery, *params.IncludeUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterToOnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Filter to only defaults", runtime.ParamLocationQuery, *params.FilterToOnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTheRawQOSOrDeltaQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include the raw QOS or delta_qos", runtime.ParamLocationQuery, *params.IncludeTheRawQOSOrDeltaQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSubAcctInformation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include sub acct information", runtime.ParamLocationQuery, *params.IncludeSubAcctInformation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeParentIdname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Exclude parent id/name", runtime.ParamLocationQuery, *params.ExcludeParentIdname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeLimitsFromParents != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Exclude limits from parents", runtime.ParamLocationQuery, *params.ExcludeLimitsFromParents); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetAssociationsRequest generates requests for SlurmdbV0043GetAssociations
func NewSlurmdbV0043GetAssociationsRequest(server string, params *SlurmdbV0043GetAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeletedAssociations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include deleted associations", runtime.ParamLocationQuery, *params.IncludeDeletedAssociations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include usage", runtime.ParamLocationQuery, *params.IncludeUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterToOnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Filter to only defaults", runtime.ParamLocationQuery, *params.FilterToOnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTheRawQOSOrDeltaQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include the raw QOS or delta_qos", runtime.ParamLocationQuery, *params.IncludeTheRawQOSOrDeltaQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSubAcctInformation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include sub acct information", runtime.ParamLocationQuery, *params.IncludeSubAcctInformation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeParentIdname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Exclude parent id/name", runtime.ParamLocationQuery, *params.ExcludeParentIdname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeLimitsFromParents != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Exclude limits from parents", runtime.ParamLocationQuery, *params.ExcludeLimitsFromParents); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043PostAssociationsRequest calls the generic SlurmdbV0043PostAssociations builder with application/json body
func NewSlurmdbV0043PostAssociationsRequest(server string, body SlurmdbV0043PostAssociationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0043PostAssociationsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0043PostAssociationsRequestWithBody generates requests for SlurmdbV0043PostAssociations with any type of body
func NewSlurmdbV0043PostAssociationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0043DeleteClusterRequest generates requests for SlurmdbV0043DeleteCluster
func NewSlurmdbV0043DeleteClusterRequest(server string, clusterName string, params *SlurmdbV0043DeleteClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_name", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/cluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Classification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "classification", runtime.ParamLocationQuery, *params.Classification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Federation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "federation", runtime.ParamLocationQuery, *params.Federation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RpcVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rpc_version", runtime.ParamLocationQuery, *params.RpcVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetClusterRequest generates requests for SlurmdbV0043GetCluster
func NewSlurmdbV0043GetClusterRequest(server string, clusterName string, params *SlurmdbV0043GetClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_name", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/cluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Classification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "classification", runtime.ParamLocationQuery, *params.Classification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Federation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "federation", runtime.ParamLocationQuery, *params.Federation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RpcVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rpc_version", runtime.ParamLocationQuery, *params.RpcVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetClustersRequest generates requests for SlurmdbV0043GetClusters
func NewSlurmdbV0043GetClustersRequest(server string, params *SlurmdbV0043GetClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/clusters/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043PostClustersRequest calls the generic SlurmdbV0043PostClusters builder with application/json body
func NewSlurmdbV0043PostClustersRequest(server string, params *SlurmdbV0043PostClustersParams, body SlurmdbV0043PostClustersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0043PostClustersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0043PostClustersRequestWithBody generates requests for SlurmdbV0043PostClusters with any type of body
func NewSlurmdbV0043PostClustersRequestWithBody(server string, params *SlurmdbV0043PostClustersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/clusters/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0043GetConfigRequest generates requests for SlurmdbV0043GetConfig
func NewSlurmdbV0043GetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043PostConfigRequest calls the generic SlurmdbV0043PostConfig builder with application/json body
func NewSlurmdbV0043PostConfigRequest(server string, body SlurmdbV0043PostConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0043PostConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0043PostConfigRequestWithBody generates requests for SlurmdbV0043PostConfig with any type of body
func NewSlurmdbV0043PostConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0043GetDiagRequest generates requests for SlurmdbV0043GetDiag
func NewSlurmdbV0043GetDiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/diag/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetInstanceRequest generates requests for SlurmdbV0043GetInstance
func NewSlurmdbV0043GetInstanceRequest(server string, params *SlurmdbV0043GetInstanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/instance/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Extra != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "extra", runtime.ParamLocationQuery, *params.Extra); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_id", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_type", runtime.ParamLocationQuery, *params.InstanceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NodeList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node_list", runtime.ParamLocationQuery, *params.NodeList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_end", runtime.ParamLocationQuery, *params.TimeEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_start", runtime.ParamLocationQuery, *params.TimeStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetInstancesRequest generates requests for SlurmdbV0043GetInstances
func NewSlurmdbV0043GetInstancesRequest(server string, params *SlurmdbV0043GetInstancesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/instances/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Extra != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "extra", runtime.ParamLocationQuery, *params.Extra); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_id", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_type", runtime.ParamLocationQuery, *params.InstanceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NodeList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node_list", runtime.ParamLocationQuery, *params.NodeList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_end", runtime.ParamLocationQuery, *params.TimeEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_start", runtime.ParamLocationQuery, *params.TimeStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetJobRequest generates requests for SlurmdbV0043GetJob
func NewSlurmdbV0043GetJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetJobsRequest generates requests for SlurmdbV0043GetJobs
func NewSlurmdbV0043GetJobsRequest(server string, params *SlurmdbV0043GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Association != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "association", runtime.ParamLocationQuery, *params.Association); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Constraints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "constraints", runtime.ParamLocationQuery, *params.Constraints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchedulerUnset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduler_unset", runtime.ParamLocationQuery, *params.SchedulerUnset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledOnSubmit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_on_submit", runtime.ParamLocationQuery, *params.ScheduledOnSubmit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledByMain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_by_main", runtime.ParamLocationQuery, *params.ScheduledByMain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledByBackfill != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_by_backfill", runtime.ParamLocationQuery, *params.ScheduledByBackfill); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobStarted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_started", runtime.ParamLocationQuery, *params.JobStarted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExitCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exit_code", runtime.ParamLocationQuery, *params.ExitCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowDuplicates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_duplicates", runtime.ParamLocationQuery, *params.ShowDuplicates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipSteps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "skip_steps", runtime.ParamLocationQuery, *params.SkipSteps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableTruncateUsageTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_truncate_usage_time", runtime.ParamLocationQuery, *params.DisableTruncateUsageTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WholeHetjob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "whole_hetjob", runtime.ParamLocationQuery, *params.WholeHetjob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableWholeHetjob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_whole_hetjob", runtime.ParamLocationQuery, *params.DisableWholeHetjob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableWaitForResult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_wait_for_result", runtime.ParamLocationQuery, *params.DisableWaitForResult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageTimeAsSubmitTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_time_as_submit_time", runtime.ParamLocationQuery, *params.UsageTimeAsSubmitTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowBatchScript != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_batch_script", runtime.ParamLocationQuery, *params.ShowBatchScript); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowJobEnvironment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_job_environment", runtime.ParamLocationQuery, *params.ShowJobEnvironment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Groups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "groups", runtime.ParamLocationQuery, *params.Groups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_name", runtime.ParamLocationQuery, *params.JobName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reason", runtime.ParamLocationQuery, *params.Reason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reservation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reservation", runtime.ParamLocationQuery, *params.Reservation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReservationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reservation_id", runtime.ParamLocationQuery, *params.ReservationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Step != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "step", runtime.ParamLocationQuery, *params.Step); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Node != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node", runtime.ParamLocationQuery, *params.Node); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Users != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "users", runtime.ParamLocationQuery, *params.Users); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Wckey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "wckey", runtime.ParamLocationQuery, *params.Wckey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetPingRequest generates requests for SlurmdbV0043GetPing
func NewSlurmdbV0043GetPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/ping/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetQosRequest generates requests for SlurmdbV0043GetQos
func NewSlurmdbV0043GetQosRequest(server string, params *SlurmdbV0043GetQosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/qos/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeletedQOS != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include deleted QOS", runtime.ParamLocationQuery, *params.IncludeDeletedQOS); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreemptMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "preempt_mode", runtime.ParamLocationQuery, *params.PreemptMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043PostQosRequest calls the generic SlurmdbV0043PostQos builder with application/json body
func NewSlurmdbV0043PostQosRequest(server string, params *SlurmdbV0043PostQosParams, body SlurmdbV0043PostQosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0043PostQosRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0043PostQosRequestWithBody generates requests for SlurmdbV0043PostQos with any type of body
func NewSlurmdbV0043PostQosRequestWithBody(server string, params *SlurmdbV0043PostQosParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/qos/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeletedQOS != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "Include deleted QOS", runtime.ParamLocationQuery, *params.IncludeDeletedQOS); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreemptMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "preempt_mode", runtime.ParamLocationQuery, *params.PreemptMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0043DeleteSingleQosRequest generates requests for SlurmdbV0043DeleteSingleQos
func NewSlurmdbV0043DeleteSingleQosRequest(server string, qos string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "qos", runtime.ParamLocationPath, qos)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/qos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetSingleQosRequest generates requests for SlurmdbV0043GetSingleQos
func NewSlurmdbV0043GetSingleQosRequest(server string, qos string, params *SlurmdbV0043GetSingleQosParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "qos", runtime.ParamLocationPath, qos)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/qos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetTresRequest generates requests for SlurmdbV0043GetTres
func NewSlurmdbV0043GetTresRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/tres/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043PostTresRequest calls the generic SlurmdbV0043PostTres builder with application/json body
func NewSlurmdbV0043PostTresRequest(server string, body SlurmdbV0043PostTresJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0043PostTresRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0043PostTresRequestWithBody generates requests for SlurmdbV0043PostTres with any type of body
func NewSlurmdbV0043PostTresRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/tres/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0043DeleteUserRequest generates requests for SlurmdbV0043DeleteUser
func NewSlurmdbV0043DeleteUserRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetUserRequest generates requests for SlurmdbV0043GetUser
func NewSlurmdbV0043GetUserRequest(server string, name string, params *SlurmdbV0043GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWckeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_wckeys", runtime.ParamLocationQuery, *params.WithWckeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetUsersRequest generates requests for SlurmdbV0043GetUsers
func NewSlurmdbV0043GetUsersRequest(server string, params *SlurmdbV0043GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/users/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AdminLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "admin_level", runtime.ParamLocationQuery, *params.AdminLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_account", runtime.ParamLocationQuery, *params.DefaultAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultWckey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_wckey", runtime.ParamLocationQuery, *params.DefaultWckey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWckeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_wckeys", runtime.ParamLocationQuery, *params.WithWckeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_defaults", runtime.ParamLocationQuery, *params.WithoutDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043PostUsersRequest calls the generic SlurmdbV0043PostUsers builder with application/json body
func NewSlurmdbV0043PostUsersRequest(server string, body SlurmdbV0043PostUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0043PostUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0043PostUsersRequestWithBody generates requests for SlurmdbV0043PostUsers with any type of body
func NewSlurmdbV0043PostUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/users/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0043PostUsersAssociationRequest calls the generic SlurmdbV0043PostUsersAssociation builder with application/json body
func NewSlurmdbV0043PostUsersAssociationRequest(server string, params *SlurmdbV0043PostUsersAssociationParams, body SlurmdbV0043PostUsersAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0043PostUsersAssociationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0043PostUsersAssociationRequestWithBody generates requests for SlurmdbV0043PostUsersAssociation with any type of body
func NewSlurmdbV0043PostUsersAssociationRequestWithBody(server string, params *SlurmdbV0043PostUsersAssociationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/users_association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0043DeleteWckeyRequest generates requests for SlurmdbV0043DeleteWckey
func NewSlurmdbV0043DeleteWckeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/wckey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetWckeyRequest generates requests for SlurmdbV0043GetWckey
func NewSlurmdbV0043GetWckeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/wckey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043GetWckeysRequest generates requests for SlurmdbV0043GetWckeys
func NewSlurmdbV0043GetWckeysRequest(server string, params *SlurmdbV0043GetWckeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/wckeys/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0043PostWckeysRequest calls the generic SlurmdbV0043PostWckeys builder with application/json body
func NewSlurmdbV0043PostWckeysRequest(server string, params *SlurmdbV0043PostWckeysParams, body SlurmdbV0043PostWckeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0043PostWckeysRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0043PostWckeysRequestWithBody generates requests for SlurmdbV0043PostWckeys with any type of body
func NewSlurmdbV0043PostWckeysRequestWithBody(server string, params *SlurmdbV0043PostWckeysParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.43/wckeys/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SlurmV0043GetDiagWithResponse request
	SlurmV0043GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0043GetDiagResponse, error)

	// SlurmV0043PostJobAllocateWithBodyWithResponse request with any body
	SlurmV0043PostJobAllocateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostJobAllocateResponse, error)

	SlurmV0043PostJobAllocateWithResponse(ctx context.Context, body SlurmV0043PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostJobAllocateResponse, error)

	// SlurmV0043PostJobSubmitWithBodyWithResponse request with any body
	SlurmV0043PostJobSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostJobSubmitResponse, error)

	SlurmV0043PostJobSubmitWithResponse(ctx context.Context, body SlurmV0043PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostJobSubmitResponse, error)

	// SlurmV0043DeleteJobWithResponse request
	SlurmV0043DeleteJobWithResponse(ctx context.Context, jobId string, params *SlurmV0043DeleteJobParams, reqEditors ...RequestEditorFn) (*SlurmV0043DeleteJobResponse, error)

	// SlurmV0043GetJobWithResponse request
	SlurmV0043GetJobWithResponse(ctx context.Context, jobId string, params *SlurmV0043GetJobParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetJobResponse, error)

	// SlurmV0043PostJobWithBodyWithResponse request with any body
	SlurmV0043PostJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostJobResponse, error)

	SlurmV0043PostJobWithResponse(ctx context.Context, jobId string, body SlurmV0043PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostJobResponse, error)

	// SlurmV0043DeleteJobsWithBodyWithResponse request with any body
	SlurmV0043DeleteJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043DeleteJobsResponse, error)

	SlurmV0043DeleteJobsWithResponse(ctx context.Context, body SlurmV0043DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043DeleteJobsResponse, error)

	// SlurmV0043GetJobsWithResponse request
	SlurmV0043GetJobsWithResponse(ctx context.Context, params *SlurmV0043GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetJobsResponse, error)

	// SlurmV0043GetJobsStateWithResponse request
	SlurmV0043GetJobsStateWithResponse(ctx context.Context, params *SlurmV0043GetJobsStateParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetJobsStateResponse, error)

	// SlurmV0043GetLicensesWithResponse request
	SlurmV0043GetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0043GetLicensesResponse, error)

	// SlurmV0043DeleteNodeWithResponse request
	SlurmV0043DeleteNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0043DeleteNodeResponse, error)

	// SlurmV0043GetNodeWithResponse request
	SlurmV0043GetNodeWithResponse(ctx context.Context, nodeName string, params *SlurmV0043GetNodeParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetNodeResponse, error)

	// SlurmV0043PostNodeWithBodyWithResponse request with any body
	SlurmV0043PostNodeWithBodyWithResponse(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostNodeResponse, error)

	SlurmV0043PostNodeWithResponse(ctx context.Context, nodeName string, body SlurmV0043PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostNodeResponse, error)

	// SlurmV0043GetNodesWithResponse request
	SlurmV0043GetNodesWithResponse(ctx context.Context, params *SlurmV0043GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetNodesResponse, error)

	// SlurmV0043PostNodesWithBodyWithResponse request with any body
	SlurmV0043PostNodesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostNodesResponse, error)

	SlurmV0043PostNodesWithResponse(ctx context.Context, body SlurmV0043PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostNodesResponse, error)

	// SlurmV0043GetPartitionWithResponse request
	SlurmV0043GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0043GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetPartitionResponse, error)

	// SlurmV0043GetPartitionsWithResponse request
	SlurmV0043GetPartitionsWithResponse(ctx context.Context, params *SlurmV0043GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetPartitionsResponse, error)

	// SlurmV0043GetPingWithResponse request
	SlurmV0043GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0043GetPingResponse, error)

	// SlurmV0043GetReconfigureWithResponse request
	SlurmV0043GetReconfigureWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0043GetReconfigureResponse, error)

	// SlurmV0043PostReservationWithBodyWithResponse request with any body
	SlurmV0043PostReservationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostReservationResponse, error)

	SlurmV0043PostReservationWithResponse(ctx context.Context, body SlurmV0043PostReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostReservationResponse, error)

	// SlurmV0043DeleteReservationWithResponse request
	SlurmV0043DeleteReservationWithResponse(ctx context.Context, reservationName string, reqEditors ...RequestEditorFn) (*SlurmV0043DeleteReservationResponse, error)

	// SlurmV0043GetReservationWithResponse request
	SlurmV0043GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0043GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetReservationResponse, error)

	// SlurmV0043GetReservationsWithResponse request
	SlurmV0043GetReservationsWithResponse(ctx context.Context, params *SlurmV0043GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetReservationsResponse, error)

	// SlurmV0043PostReservationsWithBodyWithResponse request with any body
	SlurmV0043PostReservationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostReservationsResponse, error)

	SlurmV0043PostReservationsWithResponse(ctx context.Context, body SlurmV0043PostReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostReservationsResponse, error)

	// SlurmV0043GetSharesWithResponse request
	SlurmV0043GetSharesWithResponse(ctx context.Context, params *SlurmV0043GetSharesParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetSharesResponse, error)

	// SlurmdbV0043DeleteAccountWithResponse request
	SlurmdbV0043DeleteAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteAccountResponse, error)

	// SlurmdbV0043GetAccountWithResponse request
	SlurmdbV0043GetAccountWithResponse(ctx context.Context, accountName string, params *SlurmdbV0043GetAccountParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetAccountResponse, error)

	// SlurmdbV0043GetAccountsWithResponse request
	SlurmdbV0043GetAccountsWithResponse(ctx context.Context, params *SlurmdbV0043GetAccountsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetAccountsResponse, error)

	// SlurmdbV0043PostAccountsWithBodyWithResponse request with any body
	SlurmdbV0043PostAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostAccountsResponse, error)

	SlurmdbV0043PostAccountsWithResponse(ctx context.Context, body SlurmdbV0043PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostAccountsResponse, error)

	// SlurmdbV0043PostAccountsAssociationWithBodyWithResponse request with any body
	SlurmdbV0043PostAccountsAssociationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostAccountsAssociationResponse, error)

	SlurmdbV0043PostAccountsAssociationWithResponse(ctx context.Context, body SlurmdbV0043PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostAccountsAssociationResponse, error)

	// SlurmdbV0043DeleteAssociationWithResponse request
	SlurmdbV0043DeleteAssociationWithResponse(ctx context.Context, params *SlurmdbV0043DeleteAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteAssociationResponse, error)

	// SlurmdbV0043GetAssociationWithResponse request
	SlurmdbV0043GetAssociationWithResponse(ctx context.Context, params *SlurmdbV0043GetAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetAssociationResponse, error)

	// SlurmdbV0043DeleteAssociationsWithResponse request
	SlurmdbV0043DeleteAssociationsWithResponse(ctx context.Context, params *SlurmdbV0043DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteAssociationsResponse, error)

	// SlurmdbV0043GetAssociationsWithResponse request
	SlurmdbV0043GetAssociationsWithResponse(ctx context.Context, params *SlurmdbV0043GetAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetAssociationsResponse, error)

	// SlurmdbV0043PostAssociationsWithBodyWithResponse request with any body
	SlurmdbV0043PostAssociationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostAssociationsResponse, error)

	SlurmdbV0043PostAssociationsWithResponse(ctx context.Context, body SlurmdbV0043PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostAssociationsResponse, error)

	// SlurmdbV0043DeleteClusterWithResponse request
	SlurmdbV0043DeleteClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0043DeleteClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteClusterResponse, error)

	// SlurmdbV0043GetClusterWithResponse request
	SlurmdbV0043GetClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0043GetClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetClusterResponse, error)

	// SlurmdbV0043GetClustersWithResponse request
	SlurmdbV0043GetClustersWithResponse(ctx context.Context, params *SlurmdbV0043GetClustersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetClustersResponse, error)

	// SlurmdbV0043PostClustersWithBodyWithResponse request with any body
	SlurmdbV0043PostClustersWithBodyWithResponse(ctx context.Context, params *SlurmdbV0043PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostClustersResponse, error)

	SlurmdbV0043PostClustersWithResponse(ctx context.Context, params *SlurmdbV0043PostClustersParams, body SlurmdbV0043PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostClustersResponse, error)

	// SlurmdbV0043GetConfigWithResponse request
	SlurmdbV0043GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetConfigResponse, error)

	// SlurmdbV0043PostConfigWithBodyWithResponse request with any body
	SlurmdbV0043PostConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostConfigResponse, error)

	SlurmdbV0043PostConfigWithResponse(ctx context.Context, body SlurmdbV0043PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostConfigResponse, error)

	// SlurmdbV0043GetDiagWithResponse request
	SlurmdbV0043GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetDiagResponse, error)

	// SlurmdbV0043GetInstanceWithResponse request
	SlurmdbV0043GetInstanceWithResponse(ctx context.Context, params *SlurmdbV0043GetInstanceParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetInstanceResponse, error)

	// SlurmdbV0043GetInstancesWithResponse request
	SlurmdbV0043GetInstancesWithResponse(ctx context.Context, params *SlurmdbV0043GetInstancesParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetInstancesResponse, error)

	// SlurmdbV0043GetJobWithResponse request
	SlurmdbV0043GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetJobResponse, error)

	// SlurmdbV0043GetJobsWithResponse request
	SlurmdbV0043GetJobsWithResponse(ctx context.Context, params *SlurmdbV0043GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetJobsResponse, error)

	// SlurmdbV0043GetPingWithResponse request
	SlurmdbV0043GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetPingResponse, error)

	// SlurmdbV0043GetQosWithResponse request
	SlurmdbV0043GetQosWithResponse(ctx context.Context, params *SlurmdbV0043GetQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetQosResponse, error)

	// SlurmdbV0043PostQosWithBodyWithResponse request with any body
	SlurmdbV0043PostQosWithBodyWithResponse(ctx context.Context, params *SlurmdbV0043PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostQosResponse, error)

	SlurmdbV0043PostQosWithResponse(ctx context.Context, params *SlurmdbV0043PostQosParams, body SlurmdbV0043PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostQosResponse, error)

	// SlurmdbV0043DeleteSingleQosWithResponse request
	SlurmdbV0043DeleteSingleQosWithResponse(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteSingleQosResponse, error)

	// SlurmdbV0043GetSingleQosWithResponse request
	SlurmdbV0043GetSingleQosWithResponse(ctx context.Context, qos string, params *SlurmdbV0043GetSingleQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetSingleQosResponse, error)

	// SlurmdbV0043GetTresWithResponse request
	SlurmdbV0043GetTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetTresResponse, error)

	// SlurmdbV0043PostTresWithBodyWithResponse request with any body
	SlurmdbV0043PostTresWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostTresResponse, error)

	SlurmdbV0043PostTresWithResponse(ctx context.Context, body SlurmdbV0043PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostTresResponse, error)

	// SlurmdbV0043DeleteUserWithResponse request
	SlurmdbV0043DeleteUserWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteUserResponse, error)

	// SlurmdbV0043GetUserWithResponse request
	SlurmdbV0043GetUserWithResponse(ctx context.Context, name string, params *SlurmdbV0043GetUserParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetUserResponse, error)

	// SlurmdbV0043GetUsersWithResponse request
	SlurmdbV0043GetUsersWithResponse(ctx context.Context, params *SlurmdbV0043GetUsersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetUsersResponse, error)

	// SlurmdbV0043PostUsersWithBodyWithResponse request with any body
	SlurmdbV0043PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostUsersResponse, error)

	SlurmdbV0043PostUsersWithResponse(ctx context.Context, body SlurmdbV0043PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostUsersResponse, error)

	// SlurmdbV0043PostUsersAssociationWithBodyWithResponse request with any body
	SlurmdbV0043PostUsersAssociationWithBodyWithResponse(ctx context.Context, params *SlurmdbV0043PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostUsersAssociationResponse, error)

	SlurmdbV0043PostUsersAssociationWithResponse(ctx context.Context, params *SlurmdbV0043PostUsersAssociationParams, body SlurmdbV0043PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostUsersAssociationResponse, error)

	// SlurmdbV0043DeleteWckeyWithResponse request
	SlurmdbV0043DeleteWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteWckeyResponse, error)

	// SlurmdbV0043GetWckeyWithResponse request
	SlurmdbV0043GetWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetWckeyResponse, error)

	// SlurmdbV0043GetWckeysWithResponse request
	SlurmdbV0043GetWckeysWithResponse(ctx context.Context, params *SlurmdbV0043GetWckeysParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetWckeysResponse, error)

	// SlurmdbV0043PostWckeysWithBodyWithResponse request with any body
	SlurmdbV0043PostWckeysWithBodyWithResponse(ctx context.Context, params *SlurmdbV0043PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostWckeysResponse, error)

	SlurmdbV0043PostWckeysWithResponse(ctx context.Context, params *SlurmdbV0043PostWckeysParams, body SlurmdbV0043PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostWckeysResponse, error)
}

type SlurmV0043GetDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiDiagResp
	JSONDefault  *V0043OpenapiDiagResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043PostJobAllocateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiJobAllocResp
	JSONDefault  *V0043OpenapiJobAllocResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043PostJobAllocateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043PostJobAllocateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043PostJobSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiJobSubmitResponse
	JSONDefault  *V0043OpenapiJobSubmitResponse
}

// Status returns HTTPResponse.Status
func (r SlurmV0043PostJobSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043PostJobSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043DeleteJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiKillJobResp
	JSONDefault  *V0043OpenapiKillJobResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043DeleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043DeleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiJobInfoResp
	JSONDefault  *V0043OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043PostJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiJobPostResponse
	JSONDefault  *V0043OpenapiJobPostResponse
}

// Status returns HTTPResponse.Status
func (r SlurmV0043PostJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043PostJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043DeleteJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiKillJobsResp
	JSONDefault  *V0043OpenapiKillJobsResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043DeleteJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043DeleteJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiJobInfoResp
	JSONDefault  *V0043OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043GetJobsStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiJobInfoResp
	JSONDefault  *V0043OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetJobsStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetJobsStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043GetLicensesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiLicensesResp
	JSONDefault  *V0043OpenapiLicensesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetLicensesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetLicensesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043DeleteNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043DeleteNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043DeleteNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043GetNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiNodesResp
	JSONDefault  *V0043OpenapiNodesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043PostNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043PostNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043PostNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043GetNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiNodesResp
	JSONDefault  *V0043OpenapiNodesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043PostNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043PostNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043PostNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043GetPartitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiPartitionResp
	JSONDefault  *V0043OpenapiPartitionResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetPartitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetPartitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043GetPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiPartitionResp
	JSONDefault  *V0043OpenapiPartitionResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043GetPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiPingArrayResp
	JSONDefault  *V0043OpenapiPingArrayResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043GetReconfigureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetReconfigureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetReconfigureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043PostReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiReservationModResp
	JSONDefault  *V0043OpenapiReservationModResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043PostReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043PostReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043DeleteReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043DeleteReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043DeleteReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043GetReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiReservationResp
	JSONDefault  *V0043OpenapiReservationResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043GetReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiReservationResp
	JSONDefault  *V0043OpenapiReservationResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043PostReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiReservationModResp
	JSONDefault  *V0043OpenapiReservationModResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043PostReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043PostReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0043GetSharesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiSharesResp
	JSONDefault  *V0043OpenapiSharesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0043GetSharesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0043GetSharesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043DeleteAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiAccountsRemovedResp
	JSONDefault  *V0043OpenapiAccountsRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043DeleteAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043DeleteAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiAccountsResp
	JSONDefault  *V0043OpenapiAccountsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiAccountsResp
	JSONDefault  *V0043OpenapiAccountsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043PostAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043PostAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043PostAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043PostAccountsAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiAccountsAddCondRespStr
	JSONDefault  *V0043OpenapiAccountsAddCondRespStr
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043PostAccountsAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043PostAccountsAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043DeleteAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiAssocsRemovedResp
	JSONDefault  *V0043OpenapiAssocsRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043DeleteAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043DeleteAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiAssocsResp
	JSONDefault  *V0043OpenapiAssocsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043DeleteAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiAssocsRemovedResp
	JSONDefault  *V0043OpenapiAssocsRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043DeleteAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043DeleteAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiAssocsResp
	JSONDefault  *V0043OpenapiAssocsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043PostAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043PostAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043PostAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiClustersRemovedResp
	JSONDefault  *V0043OpenapiClustersRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiClustersResp
	JSONDefault  *V0043OpenapiClustersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiClustersResp
	JSONDefault  *V0043OpenapiClustersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043PostClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043PostClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043PostClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiSlurmdbdConfigResp
	JSONDefault  *V0043OpenapiSlurmdbdConfigResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043PostConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043PostConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043PostConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiSlurmdbdStatsResp
	JSONDefault  *V0043OpenapiSlurmdbdStatsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiInstancesResp
	JSONDefault  *V0043OpenapiInstancesResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiInstancesResp
	JSONDefault  *V0043OpenapiInstancesResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiSlurmdbdJobsResp
	JSONDefault  *V0043OpenapiSlurmdbdJobsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiSlurmdbdJobsResp
	JSONDefault  *V0043OpenapiSlurmdbdJobsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiSlurmdbdPingResp
	JSONDefault  *V0043OpenapiSlurmdbdPingResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiSlurmdbdQosResp
	JSONDefault  *V0043OpenapiSlurmdbdQosResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043PostQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043PostQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043PostQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043DeleteSingleQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiSlurmdbdQosRemovedResp
	JSONDefault  *V0043OpenapiSlurmdbdQosRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043DeleteSingleQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043DeleteSingleQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetSingleQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiSlurmdbdQosResp
	JSONDefault  *V0043OpenapiSlurmdbdQosResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetSingleQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetSingleQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetTresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiTresResp
	JSONDefault  *V0043OpenapiTresResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetTresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetTresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043PostTresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043PostTresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043PostTresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiUsersResp
	JSONDefault  *V0043OpenapiUsersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiUsersResp
	JSONDefault  *V0043OpenapiUsersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043PostUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043PostUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043PostUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043PostUsersAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiUsersAddCondRespStr
	JSONDefault  *V0043OpenapiUsersAddCondRespStr
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043PostUsersAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043PostUsersAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043DeleteWckeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiWckeyRemovedResp
	JSONDefault  *V0043OpenapiWckeyRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043DeleteWckeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043DeleteWckeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetWckeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiWckeyResp
	JSONDefault  *V0043OpenapiWckeyResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetWckeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetWckeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043GetWckeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiWckeyResp
	JSONDefault  *V0043OpenapiWckeyResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043GetWckeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043GetWckeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0043PostWckeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0043OpenapiResp
	JSONDefault  *V0043OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0043PostWckeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0043PostWckeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SlurmV0043GetDiagWithResponse request returning *SlurmV0043GetDiagResponse
func (c *ClientWithResponses) SlurmV0043GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0043GetDiagResponse, error) {
	rsp, err := c.SlurmV0043GetDiag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetDiagResponse(rsp)
}

// SlurmV0043PostJobAllocateWithBodyWithResponse request with arbitrary body returning *SlurmV0043PostJobAllocateResponse
func (c *ClientWithResponses) SlurmV0043PostJobAllocateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostJobAllocateResponse, error) {
	rsp, err := c.SlurmV0043PostJobAllocateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostJobAllocateResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0043PostJobAllocateWithResponse(ctx context.Context, body SlurmV0043PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostJobAllocateResponse, error) {
	rsp, err := c.SlurmV0043PostJobAllocate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostJobAllocateResponse(rsp)
}

// SlurmV0043PostJobSubmitWithBodyWithResponse request with arbitrary body returning *SlurmV0043PostJobSubmitResponse
func (c *ClientWithResponses) SlurmV0043PostJobSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostJobSubmitResponse, error) {
	rsp, err := c.SlurmV0043PostJobSubmitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostJobSubmitResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0043PostJobSubmitWithResponse(ctx context.Context, body SlurmV0043PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostJobSubmitResponse, error) {
	rsp, err := c.SlurmV0043PostJobSubmit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostJobSubmitResponse(rsp)
}

// SlurmV0043DeleteJobWithResponse request returning *SlurmV0043DeleteJobResponse
func (c *ClientWithResponses) SlurmV0043DeleteJobWithResponse(ctx context.Context, jobId string, params *SlurmV0043DeleteJobParams, reqEditors ...RequestEditorFn) (*SlurmV0043DeleteJobResponse, error) {
	rsp, err := c.SlurmV0043DeleteJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043DeleteJobResponse(rsp)
}

// SlurmV0043GetJobWithResponse request returning *SlurmV0043GetJobResponse
func (c *ClientWithResponses) SlurmV0043GetJobWithResponse(ctx context.Context, jobId string, params *SlurmV0043GetJobParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetJobResponse, error) {
	rsp, err := c.SlurmV0043GetJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetJobResponse(rsp)
}

// SlurmV0043PostJobWithBodyWithResponse request with arbitrary body returning *SlurmV0043PostJobResponse
func (c *ClientWithResponses) SlurmV0043PostJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostJobResponse, error) {
	rsp, err := c.SlurmV0043PostJobWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostJobResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0043PostJobWithResponse(ctx context.Context, jobId string, body SlurmV0043PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostJobResponse, error) {
	rsp, err := c.SlurmV0043PostJob(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostJobResponse(rsp)
}

// SlurmV0043DeleteJobsWithBodyWithResponse request with arbitrary body returning *SlurmV0043DeleteJobsResponse
func (c *ClientWithResponses) SlurmV0043DeleteJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043DeleteJobsResponse, error) {
	rsp, err := c.SlurmV0043DeleteJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043DeleteJobsResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0043DeleteJobsWithResponse(ctx context.Context, body SlurmV0043DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043DeleteJobsResponse, error) {
	rsp, err := c.SlurmV0043DeleteJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043DeleteJobsResponse(rsp)
}

// SlurmV0043GetJobsWithResponse request returning *SlurmV0043GetJobsResponse
func (c *ClientWithResponses) SlurmV0043GetJobsWithResponse(ctx context.Context, params *SlurmV0043GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetJobsResponse, error) {
	rsp, err := c.SlurmV0043GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetJobsResponse(rsp)
}

// SlurmV0043GetJobsStateWithResponse request returning *SlurmV0043GetJobsStateResponse
func (c *ClientWithResponses) SlurmV0043GetJobsStateWithResponse(ctx context.Context, params *SlurmV0043GetJobsStateParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetJobsStateResponse, error) {
	rsp, err := c.SlurmV0043GetJobsState(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetJobsStateResponse(rsp)
}

// SlurmV0043GetLicensesWithResponse request returning *SlurmV0043GetLicensesResponse
func (c *ClientWithResponses) SlurmV0043GetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0043GetLicensesResponse, error) {
	rsp, err := c.SlurmV0043GetLicenses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetLicensesResponse(rsp)
}

// SlurmV0043DeleteNodeWithResponse request returning *SlurmV0043DeleteNodeResponse
func (c *ClientWithResponses) SlurmV0043DeleteNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0043DeleteNodeResponse, error) {
	rsp, err := c.SlurmV0043DeleteNode(ctx, nodeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043DeleteNodeResponse(rsp)
}

// SlurmV0043GetNodeWithResponse request returning *SlurmV0043GetNodeResponse
func (c *ClientWithResponses) SlurmV0043GetNodeWithResponse(ctx context.Context, nodeName string, params *SlurmV0043GetNodeParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetNodeResponse, error) {
	rsp, err := c.SlurmV0043GetNode(ctx, nodeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetNodeResponse(rsp)
}

// SlurmV0043PostNodeWithBodyWithResponse request with arbitrary body returning *SlurmV0043PostNodeResponse
func (c *ClientWithResponses) SlurmV0043PostNodeWithBodyWithResponse(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostNodeResponse, error) {
	rsp, err := c.SlurmV0043PostNodeWithBody(ctx, nodeName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostNodeResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0043PostNodeWithResponse(ctx context.Context, nodeName string, body SlurmV0043PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostNodeResponse, error) {
	rsp, err := c.SlurmV0043PostNode(ctx, nodeName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostNodeResponse(rsp)
}

// SlurmV0043GetNodesWithResponse request returning *SlurmV0043GetNodesResponse
func (c *ClientWithResponses) SlurmV0043GetNodesWithResponse(ctx context.Context, params *SlurmV0043GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetNodesResponse, error) {
	rsp, err := c.SlurmV0043GetNodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetNodesResponse(rsp)
}

// SlurmV0043PostNodesWithBodyWithResponse request with arbitrary body returning *SlurmV0043PostNodesResponse
func (c *ClientWithResponses) SlurmV0043PostNodesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostNodesResponse, error) {
	rsp, err := c.SlurmV0043PostNodesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostNodesResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0043PostNodesWithResponse(ctx context.Context, body SlurmV0043PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostNodesResponse, error) {
	rsp, err := c.SlurmV0043PostNodes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostNodesResponse(rsp)
}

// SlurmV0043GetPartitionWithResponse request returning *SlurmV0043GetPartitionResponse
func (c *ClientWithResponses) SlurmV0043GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0043GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetPartitionResponse, error) {
	rsp, err := c.SlurmV0043GetPartition(ctx, partitionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetPartitionResponse(rsp)
}

// SlurmV0043GetPartitionsWithResponse request returning *SlurmV0043GetPartitionsResponse
func (c *ClientWithResponses) SlurmV0043GetPartitionsWithResponse(ctx context.Context, params *SlurmV0043GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetPartitionsResponse, error) {
	rsp, err := c.SlurmV0043GetPartitions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetPartitionsResponse(rsp)
}

// SlurmV0043GetPingWithResponse request returning *SlurmV0043GetPingResponse
func (c *ClientWithResponses) SlurmV0043GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0043GetPingResponse, error) {
	rsp, err := c.SlurmV0043GetPing(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetPingResponse(rsp)
}

// SlurmV0043GetReconfigureWithResponse request returning *SlurmV0043GetReconfigureResponse
func (c *ClientWithResponses) SlurmV0043GetReconfigureWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0043GetReconfigureResponse, error) {
	rsp, err := c.SlurmV0043GetReconfigure(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetReconfigureResponse(rsp)
}

// SlurmV0043PostReservationWithBodyWithResponse request with arbitrary body returning *SlurmV0043PostReservationResponse
func (c *ClientWithResponses) SlurmV0043PostReservationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostReservationResponse, error) {
	rsp, err := c.SlurmV0043PostReservationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostReservationResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0043PostReservationWithResponse(ctx context.Context, body SlurmV0043PostReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostReservationResponse, error) {
	rsp, err := c.SlurmV0043PostReservation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostReservationResponse(rsp)
}

// SlurmV0043DeleteReservationWithResponse request returning *SlurmV0043DeleteReservationResponse
func (c *ClientWithResponses) SlurmV0043DeleteReservationWithResponse(ctx context.Context, reservationName string, reqEditors ...RequestEditorFn) (*SlurmV0043DeleteReservationResponse, error) {
	rsp, err := c.SlurmV0043DeleteReservation(ctx, reservationName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043DeleteReservationResponse(rsp)
}

// SlurmV0043GetReservationWithResponse request returning *SlurmV0043GetReservationResponse
func (c *ClientWithResponses) SlurmV0043GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0043GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetReservationResponse, error) {
	rsp, err := c.SlurmV0043GetReservation(ctx, reservationName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetReservationResponse(rsp)
}

// SlurmV0043GetReservationsWithResponse request returning *SlurmV0043GetReservationsResponse
func (c *ClientWithResponses) SlurmV0043GetReservationsWithResponse(ctx context.Context, params *SlurmV0043GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetReservationsResponse, error) {
	rsp, err := c.SlurmV0043GetReservations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetReservationsResponse(rsp)
}

// SlurmV0043PostReservationsWithBodyWithResponse request with arbitrary body returning *SlurmV0043PostReservationsResponse
func (c *ClientWithResponses) SlurmV0043PostReservationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0043PostReservationsResponse, error) {
	rsp, err := c.SlurmV0043PostReservationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostReservationsResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0043PostReservationsWithResponse(ctx context.Context, body SlurmV0043PostReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0043PostReservationsResponse, error) {
	rsp, err := c.SlurmV0043PostReservations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043PostReservationsResponse(rsp)
}

// SlurmV0043GetSharesWithResponse request returning *SlurmV0043GetSharesResponse
func (c *ClientWithResponses) SlurmV0043GetSharesWithResponse(ctx context.Context, params *SlurmV0043GetSharesParams, reqEditors ...RequestEditorFn) (*SlurmV0043GetSharesResponse, error) {
	rsp, err := c.SlurmV0043GetShares(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0043GetSharesResponse(rsp)
}

// SlurmdbV0043DeleteAccountWithResponse request returning *SlurmdbV0043DeleteAccountResponse
func (c *ClientWithResponses) SlurmdbV0043DeleteAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteAccountResponse, error) {
	rsp, err := c.SlurmdbV0043DeleteAccount(ctx, accountName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043DeleteAccountResponse(rsp)
}

// SlurmdbV0043GetAccountWithResponse request returning *SlurmdbV0043GetAccountResponse
func (c *ClientWithResponses) SlurmdbV0043GetAccountWithResponse(ctx context.Context, accountName string, params *SlurmdbV0043GetAccountParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetAccountResponse, error) {
	rsp, err := c.SlurmdbV0043GetAccount(ctx, accountName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetAccountResponse(rsp)
}

// SlurmdbV0043GetAccountsWithResponse request returning *SlurmdbV0043GetAccountsResponse
func (c *ClientWithResponses) SlurmdbV0043GetAccountsWithResponse(ctx context.Context, params *SlurmdbV0043GetAccountsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetAccountsResponse, error) {
	rsp, err := c.SlurmdbV0043GetAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetAccountsResponse(rsp)
}

// SlurmdbV0043PostAccountsWithBodyWithResponse request with arbitrary body returning *SlurmdbV0043PostAccountsResponse
func (c *ClientWithResponses) SlurmdbV0043PostAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostAccountsResponse, error) {
	rsp, err := c.SlurmdbV0043PostAccountsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostAccountsResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0043PostAccountsWithResponse(ctx context.Context, body SlurmdbV0043PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostAccountsResponse, error) {
	rsp, err := c.SlurmdbV0043PostAccounts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostAccountsResponse(rsp)
}

// SlurmdbV0043PostAccountsAssociationWithBodyWithResponse request with arbitrary body returning *SlurmdbV0043PostAccountsAssociationResponse
func (c *ClientWithResponses) SlurmdbV0043PostAccountsAssociationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostAccountsAssociationResponse, error) {
	rsp, err := c.SlurmdbV0043PostAccountsAssociationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostAccountsAssociationResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0043PostAccountsAssociationWithResponse(ctx context.Context, body SlurmdbV0043PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostAccountsAssociationResponse, error) {
	rsp, err := c.SlurmdbV0043PostAccountsAssociation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostAccountsAssociationResponse(rsp)
}

// SlurmdbV0043DeleteAssociationWithResponse request returning *SlurmdbV0043DeleteAssociationResponse
func (c *ClientWithResponses) SlurmdbV0043DeleteAssociationWithResponse(ctx context.Context, params *SlurmdbV0043DeleteAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteAssociationResponse, error) {
	rsp, err := c.SlurmdbV0043DeleteAssociation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043DeleteAssociationResponse(rsp)
}

// SlurmdbV0043GetAssociationWithResponse request returning *SlurmdbV0043GetAssociationResponse
func (c *ClientWithResponses) SlurmdbV0043GetAssociationWithResponse(ctx context.Context, params *SlurmdbV0043GetAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetAssociationResponse, error) {
	rsp, err := c.SlurmdbV0043GetAssociation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetAssociationResponse(rsp)
}

// SlurmdbV0043DeleteAssociationsWithResponse request returning *SlurmdbV0043DeleteAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0043DeleteAssociationsWithResponse(ctx context.Context, params *SlurmdbV0043DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0043DeleteAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043DeleteAssociationsResponse(rsp)
}

// SlurmdbV0043GetAssociationsWithResponse request returning *SlurmdbV0043GetAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0043GetAssociationsWithResponse(ctx context.Context, params *SlurmdbV0043GetAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0043GetAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetAssociationsResponse(rsp)
}

// SlurmdbV0043PostAssociationsWithBodyWithResponse request with arbitrary body returning *SlurmdbV0043PostAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0043PostAssociationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0043PostAssociationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostAssociationsResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0043PostAssociationsWithResponse(ctx context.Context, body SlurmdbV0043PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0043PostAssociations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostAssociationsResponse(rsp)
}

// SlurmdbV0043DeleteClusterWithResponse request returning *SlurmdbV0043DeleteClusterResponse
func (c *ClientWithResponses) SlurmdbV0043DeleteClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0043DeleteClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteClusterResponse, error) {
	rsp, err := c.SlurmdbV0043DeleteCluster(ctx, clusterName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043DeleteClusterResponse(rsp)
}

// SlurmdbV0043GetClusterWithResponse request returning *SlurmdbV0043GetClusterResponse
func (c *ClientWithResponses) SlurmdbV0043GetClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0043GetClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetClusterResponse, error) {
	rsp, err := c.SlurmdbV0043GetCluster(ctx, clusterName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetClusterResponse(rsp)
}

// SlurmdbV0043GetClustersWithResponse request returning *SlurmdbV0043GetClustersResponse
func (c *ClientWithResponses) SlurmdbV0043GetClustersWithResponse(ctx context.Context, params *SlurmdbV0043GetClustersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetClustersResponse, error) {
	rsp, err := c.SlurmdbV0043GetClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetClustersResponse(rsp)
}

// SlurmdbV0043PostClustersWithBodyWithResponse request with arbitrary body returning *SlurmdbV0043PostClustersResponse
func (c *ClientWithResponses) SlurmdbV0043PostClustersWithBodyWithResponse(ctx context.Context, params *SlurmdbV0043PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostClustersResponse, error) {
	rsp, err := c.SlurmdbV0043PostClustersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostClustersResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0043PostClustersWithResponse(ctx context.Context, params *SlurmdbV0043PostClustersParams, body SlurmdbV0043PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostClustersResponse, error) {
	rsp, err := c.SlurmdbV0043PostClusters(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostClustersResponse(rsp)
}

// SlurmdbV0043GetConfigWithResponse request returning *SlurmdbV0043GetConfigResponse
func (c *ClientWithResponses) SlurmdbV0043GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetConfigResponse, error) {
	rsp, err := c.SlurmdbV0043GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetConfigResponse(rsp)
}

// SlurmdbV0043PostConfigWithBodyWithResponse request with arbitrary body returning *SlurmdbV0043PostConfigResponse
func (c *ClientWithResponses) SlurmdbV0043PostConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostConfigResponse, error) {
	rsp, err := c.SlurmdbV0043PostConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostConfigResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0043PostConfigWithResponse(ctx context.Context, body SlurmdbV0043PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostConfigResponse, error) {
	rsp, err := c.SlurmdbV0043PostConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostConfigResponse(rsp)
}

// SlurmdbV0043GetDiagWithResponse request returning *SlurmdbV0043GetDiagResponse
func (c *ClientWithResponses) SlurmdbV0043GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetDiagResponse, error) {
	rsp, err := c.SlurmdbV0043GetDiag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetDiagResponse(rsp)
}

// SlurmdbV0043GetInstanceWithResponse request returning *SlurmdbV0043GetInstanceResponse
func (c *ClientWithResponses) SlurmdbV0043GetInstanceWithResponse(ctx context.Context, params *SlurmdbV0043GetInstanceParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetInstanceResponse, error) {
	rsp, err := c.SlurmdbV0043GetInstance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetInstanceResponse(rsp)
}

// SlurmdbV0043GetInstancesWithResponse request returning *SlurmdbV0043GetInstancesResponse
func (c *ClientWithResponses) SlurmdbV0043GetInstancesWithResponse(ctx context.Context, params *SlurmdbV0043GetInstancesParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetInstancesResponse, error) {
	rsp, err := c.SlurmdbV0043GetInstances(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetInstancesResponse(rsp)
}

// SlurmdbV0043GetJobWithResponse request returning *SlurmdbV0043GetJobResponse
func (c *ClientWithResponses) SlurmdbV0043GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetJobResponse, error) {
	rsp, err := c.SlurmdbV0043GetJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetJobResponse(rsp)
}

// SlurmdbV0043GetJobsWithResponse request returning *SlurmdbV0043GetJobsResponse
func (c *ClientWithResponses) SlurmdbV0043GetJobsWithResponse(ctx context.Context, params *SlurmdbV0043GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetJobsResponse, error) {
	rsp, err := c.SlurmdbV0043GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetJobsResponse(rsp)
}

// SlurmdbV0043GetPingWithResponse request returning *SlurmdbV0043GetPingResponse
func (c *ClientWithResponses) SlurmdbV0043GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetPingResponse, error) {
	rsp, err := c.SlurmdbV0043GetPing(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetPingResponse(rsp)
}

// SlurmdbV0043GetQosWithResponse request returning *SlurmdbV0043GetQosResponse
func (c *ClientWithResponses) SlurmdbV0043GetQosWithResponse(ctx context.Context, params *SlurmdbV0043GetQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetQosResponse, error) {
	rsp, err := c.SlurmdbV0043GetQos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetQosResponse(rsp)
}

// SlurmdbV0043PostQosWithBodyWithResponse request with arbitrary body returning *SlurmdbV0043PostQosResponse
func (c *ClientWithResponses) SlurmdbV0043PostQosWithBodyWithResponse(ctx context.Context, params *SlurmdbV0043PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostQosResponse, error) {
	rsp, err := c.SlurmdbV0043PostQosWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostQosResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0043PostQosWithResponse(ctx context.Context, params *SlurmdbV0043PostQosParams, body SlurmdbV0043PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostQosResponse, error) {
	rsp, err := c.SlurmdbV0043PostQos(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostQosResponse(rsp)
}

// SlurmdbV0043DeleteSingleQosWithResponse request returning *SlurmdbV0043DeleteSingleQosResponse
func (c *ClientWithResponses) SlurmdbV0043DeleteSingleQosWithResponse(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteSingleQosResponse, error) {
	rsp, err := c.SlurmdbV0043DeleteSingleQos(ctx, qos, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043DeleteSingleQosResponse(rsp)
}

// SlurmdbV0043GetSingleQosWithResponse request returning *SlurmdbV0043GetSingleQosResponse
func (c *ClientWithResponses) SlurmdbV0043GetSingleQosWithResponse(ctx context.Context, qos string, params *SlurmdbV0043GetSingleQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetSingleQosResponse, error) {
	rsp, err := c.SlurmdbV0043GetSingleQos(ctx, qos, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetSingleQosResponse(rsp)
}

// SlurmdbV0043GetTresWithResponse request returning *SlurmdbV0043GetTresResponse
func (c *ClientWithResponses) SlurmdbV0043GetTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetTresResponse, error) {
	rsp, err := c.SlurmdbV0043GetTres(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetTresResponse(rsp)
}

// SlurmdbV0043PostTresWithBodyWithResponse request with arbitrary body returning *SlurmdbV0043PostTresResponse
func (c *ClientWithResponses) SlurmdbV0043PostTresWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostTresResponse, error) {
	rsp, err := c.SlurmdbV0043PostTresWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostTresResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0043PostTresWithResponse(ctx context.Context, body SlurmdbV0043PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostTresResponse, error) {
	rsp, err := c.SlurmdbV0043PostTres(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostTresResponse(rsp)
}

// SlurmdbV0043DeleteUserWithResponse request returning *SlurmdbV0043DeleteUserResponse
func (c *ClientWithResponses) SlurmdbV0043DeleteUserWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteUserResponse, error) {
	rsp, err := c.SlurmdbV0043DeleteUser(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043DeleteUserResponse(rsp)
}

// SlurmdbV0043GetUserWithResponse request returning *SlurmdbV0043GetUserResponse
func (c *ClientWithResponses) SlurmdbV0043GetUserWithResponse(ctx context.Context, name string, params *SlurmdbV0043GetUserParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetUserResponse, error) {
	rsp, err := c.SlurmdbV0043GetUser(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetUserResponse(rsp)
}

// SlurmdbV0043GetUsersWithResponse request returning *SlurmdbV0043GetUsersResponse
func (c *ClientWithResponses) SlurmdbV0043GetUsersWithResponse(ctx context.Context, params *SlurmdbV0043GetUsersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetUsersResponse, error) {
	rsp, err := c.SlurmdbV0043GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetUsersResponse(rsp)
}

// SlurmdbV0043PostUsersWithBodyWithResponse request with arbitrary body returning *SlurmdbV0043PostUsersResponse
func (c *ClientWithResponses) SlurmdbV0043PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostUsersResponse, error) {
	rsp, err := c.SlurmdbV0043PostUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostUsersResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0043PostUsersWithResponse(ctx context.Context, body SlurmdbV0043PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostUsersResponse, error) {
	rsp, err := c.SlurmdbV0043PostUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostUsersResponse(rsp)
}

// SlurmdbV0043PostUsersAssociationWithBodyWithResponse request with arbitrary body returning *SlurmdbV0043PostUsersAssociationResponse
func (c *ClientWithResponses) SlurmdbV0043PostUsersAssociationWithBodyWithResponse(ctx context.Context, params *SlurmdbV0043PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostUsersAssociationResponse, error) {
	rsp, err := c.SlurmdbV0043PostUsersAssociationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostUsersAssociationResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0043PostUsersAssociationWithResponse(ctx context.Context, params *SlurmdbV0043PostUsersAssociationParams, body SlurmdbV0043PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostUsersAssociationResponse, error) {
	rsp, err := c.SlurmdbV0043PostUsersAssociation(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostUsersAssociationResponse(rsp)
}

// SlurmdbV0043DeleteWckeyWithResponse request returning *SlurmdbV0043DeleteWckeyResponse
func (c *ClientWithResponses) SlurmdbV0043DeleteWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0043DeleteWckeyResponse, error) {
	rsp, err := c.SlurmdbV0043DeleteWckey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043DeleteWckeyResponse(rsp)
}

// SlurmdbV0043GetWckeyWithResponse request returning *SlurmdbV0043GetWckeyResponse
func (c *ClientWithResponses) SlurmdbV0043GetWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetWckeyResponse, error) {
	rsp, err := c.SlurmdbV0043GetWckey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetWckeyResponse(rsp)
}

// SlurmdbV0043GetWckeysWithResponse request returning *SlurmdbV0043GetWckeysResponse
func (c *ClientWithResponses) SlurmdbV0043GetWckeysWithResponse(ctx context.Context, params *SlurmdbV0043GetWckeysParams, reqEditors ...RequestEditorFn) (*SlurmdbV0043GetWckeysResponse, error) {
	rsp, err := c.SlurmdbV0043GetWckeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043GetWckeysResponse(rsp)
}

// SlurmdbV0043PostWckeysWithBodyWithResponse request with arbitrary body returning *SlurmdbV0043PostWckeysResponse
func (c *ClientWithResponses) SlurmdbV0043PostWckeysWithBodyWithResponse(ctx context.Context, params *SlurmdbV0043PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostWckeysResponse, error) {
	rsp, err := c.SlurmdbV0043PostWckeysWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostWckeysResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0043PostWckeysWithResponse(ctx context.Context, params *SlurmdbV0043PostWckeysParams, body SlurmdbV0043PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0043PostWckeysResponse, error) {
	rsp, err := c.SlurmdbV0043PostWckeys(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0043PostWckeysResponse(rsp)
}

// ParseSlurmV0043GetDiagResponse parses an HTTP response from a SlurmV0043GetDiagWithResponse call
func ParseSlurmV0043GetDiagResponse(rsp *http.Response) (*SlurmV0043GetDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiDiagResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiDiagResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043PostJobAllocateResponse parses an HTTP response from a SlurmV0043PostJobAllocateWithResponse call
func ParseSlurmV0043PostJobAllocateResponse(rsp *http.Response) (*SlurmV0043PostJobAllocateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043PostJobAllocateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiJobAllocResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiJobAllocResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043PostJobSubmitResponse parses an HTTP response from a SlurmV0043PostJobSubmitWithResponse call
func ParseSlurmV0043PostJobSubmitResponse(rsp *http.Response) (*SlurmV0043PostJobSubmitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043PostJobSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiJobSubmitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiJobSubmitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043DeleteJobResponse parses an HTTP response from a SlurmV0043DeleteJobWithResponse call
func ParseSlurmV0043DeleteJobResponse(rsp *http.Response) (*SlurmV0043DeleteJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043DeleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiKillJobResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiKillJobResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043GetJobResponse parses an HTTP response from a SlurmV0043GetJobWithResponse call
func ParseSlurmV0043GetJobResponse(rsp *http.Response) (*SlurmV0043GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043PostJobResponse parses an HTTP response from a SlurmV0043PostJobWithResponse call
func ParseSlurmV0043PostJobResponse(rsp *http.Response) (*SlurmV0043PostJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043PostJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiJobPostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiJobPostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043DeleteJobsResponse parses an HTTP response from a SlurmV0043DeleteJobsWithResponse call
func ParseSlurmV0043DeleteJobsResponse(rsp *http.Response) (*SlurmV0043DeleteJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043DeleteJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiKillJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiKillJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043GetJobsResponse parses an HTTP response from a SlurmV0043GetJobsWithResponse call
func ParseSlurmV0043GetJobsResponse(rsp *http.Response) (*SlurmV0043GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043GetJobsStateResponse parses an HTTP response from a SlurmV0043GetJobsStateWithResponse call
func ParseSlurmV0043GetJobsStateResponse(rsp *http.Response) (*SlurmV0043GetJobsStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetJobsStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043GetLicensesResponse parses an HTTP response from a SlurmV0043GetLicensesWithResponse call
func ParseSlurmV0043GetLicensesResponse(rsp *http.Response) (*SlurmV0043GetLicensesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetLicensesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiLicensesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiLicensesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043DeleteNodeResponse parses an HTTP response from a SlurmV0043DeleteNodeWithResponse call
func ParseSlurmV0043DeleteNodeResponse(rsp *http.Response) (*SlurmV0043DeleteNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043DeleteNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043GetNodeResponse parses an HTTP response from a SlurmV0043GetNodeWithResponse call
func ParseSlurmV0043GetNodeResponse(rsp *http.Response) (*SlurmV0043GetNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043PostNodeResponse parses an HTTP response from a SlurmV0043PostNodeWithResponse call
func ParseSlurmV0043PostNodeResponse(rsp *http.Response) (*SlurmV0043PostNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043PostNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043GetNodesResponse parses an HTTP response from a SlurmV0043GetNodesWithResponse call
func ParseSlurmV0043GetNodesResponse(rsp *http.Response) (*SlurmV0043GetNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043PostNodesResponse parses an HTTP response from a SlurmV0043PostNodesWithResponse call
func ParseSlurmV0043PostNodesResponse(rsp *http.Response) (*SlurmV0043PostNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043PostNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043GetPartitionResponse parses an HTTP response from a SlurmV0043GetPartitionWithResponse call
func ParseSlurmV0043GetPartitionResponse(rsp *http.Response) (*SlurmV0043GetPartitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetPartitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043GetPartitionsResponse parses an HTTP response from a SlurmV0043GetPartitionsWithResponse call
func ParseSlurmV0043GetPartitionsResponse(rsp *http.Response) (*SlurmV0043GetPartitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043GetPingResponse parses an HTTP response from a SlurmV0043GetPingWithResponse call
func ParseSlurmV0043GetPingResponse(rsp *http.Response) (*SlurmV0043GetPingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiPingArrayResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiPingArrayResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043GetReconfigureResponse parses an HTTP response from a SlurmV0043GetReconfigureWithResponse call
func ParseSlurmV0043GetReconfigureResponse(rsp *http.Response) (*SlurmV0043GetReconfigureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetReconfigureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043PostReservationResponse parses an HTTP response from a SlurmV0043PostReservationWithResponse call
func ParseSlurmV0043PostReservationResponse(rsp *http.Response) (*SlurmV0043PostReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043PostReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiReservationModResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiReservationModResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043DeleteReservationResponse parses an HTTP response from a SlurmV0043DeleteReservationWithResponse call
func ParseSlurmV0043DeleteReservationResponse(rsp *http.Response) (*SlurmV0043DeleteReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043DeleteReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043GetReservationResponse parses an HTTP response from a SlurmV0043GetReservationWithResponse call
func ParseSlurmV0043GetReservationResponse(rsp *http.Response) (*SlurmV0043GetReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043GetReservationsResponse parses an HTTP response from a SlurmV0043GetReservationsWithResponse call
func ParseSlurmV0043GetReservationsResponse(rsp *http.Response) (*SlurmV0043GetReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043PostReservationsResponse parses an HTTP response from a SlurmV0043PostReservationsWithResponse call
func ParseSlurmV0043PostReservationsResponse(rsp *http.Response) (*SlurmV0043PostReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043PostReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiReservationModResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiReservationModResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0043GetSharesResponse parses an HTTP response from a SlurmV0043GetSharesWithResponse call
func ParseSlurmV0043GetSharesResponse(rsp *http.Response) (*SlurmV0043GetSharesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0043GetSharesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiSharesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiSharesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043DeleteAccountResponse parses an HTTP response from a SlurmdbV0043DeleteAccountWithResponse call
func ParseSlurmdbV0043DeleteAccountResponse(rsp *http.Response) (*SlurmdbV0043DeleteAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043DeleteAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiAccountsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiAccountsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetAccountResponse parses an HTTP response from a SlurmdbV0043GetAccountWithResponse call
func ParseSlurmdbV0043GetAccountResponse(rsp *http.Response) (*SlurmdbV0043GetAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetAccountsResponse parses an HTTP response from a SlurmdbV0043GetAccountsWithResponse call
func ParseSlurmdbV0043GetAccountsResponse(rsp *http.Response) (*SlurmdbV0043GetAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043PostAccountsResponse parses an HTTP response from a SlurmdbV0043PostAccountsWithResponse call
func ParseSlurmdbV0043PostAccountsResponse(rsp *http.Response) (*SlurmdbV0043PostAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043PostAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043PostAccountsAssociationResponse parses an HTTP response from a SlurmdbV0043PostAccountsAssociationWithResponse call
func ParseSlurmdbV0043PostAccountsAssociationResponse(rsp *http.Response) (*SlurmdbV0043PostAccountsAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043PostAccountsAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiAccountsAddCondRespStr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiAccountsAddCondRespStr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043DeleteAssociationResponse parses an HTTP response from a SlurmdbV0043DeleteAssociationWithResponse call
func ParseSlurmdbV0043DeleteAssociationResponse(rsp *http.Response) (*SlurmdbV0043DeleteAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043DeleteAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetAssociationResponse parses an HTTP response from a SlurmdbV0043GetAssociationWithResponse call
func ParseSlurmdbV0043GetAssociationResponse(rsp *http.Response) (*SlurmdbV0043GetAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043DeleteAssociationsResponse parses an HTTP response from a SlurmdbV0043DeleteAssociationsWithResponse call
func ParseSlurmdbV0043DeleteAssociationsResponse(rsp *http.Response) (*SlurmdbV0043DeleteAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043DeleteAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetAssociationsResponse parses an HTTP response from a SlurmdbV0043GetAssociationsWithResponse call
func ParseSlurmdbV0043GetAssociationsResponse(rsp *http.Response) (*SlurmdbV0043GetAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043PostAssociationsResponse parses an HTTP response from a SlurmdbV0043PostAssociationsWithResponse call
func ParseSlurmdbV0043PostAssociationsResponse(rsp *http.Response) (*SlurmdbV0043PostAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043PostAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043DeleteClusterResponse parses an HTTP response from a SlurmdbV0043DeleteClusterWithResponse call
func ParseSlurmdbV0043DeleteClusterResponse(rsp *http.Response) (*SlurmdbV0043DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiClustersRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiClustersRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetClusterResponse parses an HTTP response from a SlurmdbV0043GetClusterWithResponse call
func ParseSlurmdbV0043GetClusterResponse(rsp *http.Response) (*SlurmdbV0043GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetClustersResponse parses an HTTP response from a SlurmdbV0043GetClustersWithResponse call
func ParseSlurmdbV0043GetClustersResponse(rsp *http.Response) (*SlurmdbV0043GetClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043PostClustersResponse parses an HTTP response from a SlurmdbV0043PostClustersWithResponse call
func ParseSlurmdbV0043PostClustersResponse(rsp *http.Response) (*SlurmdbV0043PostClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043PostClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetConfigResponse parses an HTTP response from a SlurmdbV0043GetConfigWithResponse call
func ParseSlurmdbV0043GetConfigResponse(rsp *http.Response) (*SlurmdbV0043GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiSlurmdbdConfigResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiSlurmdbdConfigResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043PostConfigResponse parses an HTTP response from a SlurmdbV0043PostConfigWithResponse call
func ParseSlurmdbV0043PostConfigResponse(rsp *http.Response) (*SlurmdbV0043PostConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043PostConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetDiagResponse parses an HTTP response from a SlurmdbV0043GetDiagWithResponse call
func ParseSlurmdbV0043GetDiagResponse(rsp *http.Response) (*SlurmdbV0043GetDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiSlurmdbdStatsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiSlurmdbdStatsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetInstanceResponse parses an HTTP response from a SlurmdbV0043GetInstanceWithResponse call
func ParseSlurmdbV0043GetInstanceResponse(rsp *http.Response) (*SlurmdbV0043GetInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetInstancesResponse parses an HTTP response from a SlurmdbV0043GetInstancesWithResponse call
func ParseSlurmdbV0043GetInstancesResponse(rsp *http.Response) (*SlurmdbV0043GetInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetJobResponse parses an HTTP response from a SlurmdbV0043GetJobWithResponse call
func ParseSlurmdbV0043GetJobResponse(rsp *http.Response) (*SlurmdbV0043GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetJobsResponse parses an HTTP response from a SlurmdbV0043GetJobsWithResponse call
func ParseSlurmdbV0043GetJobsResponse(rsp *http.Response) (*SlurmdbV0043GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetPingResponse parses an HTTP response from a SlurmdbV0043GetPingWithResponse call
func ParseSlurmdbV0043GetPingResponse(rsp *http.Response) (*SlurmdbV0043GetPingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiSlurmdbdPingResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiSlurmdbdPingResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetQosResponse parses an HTTP response from a SlurmdbV0043GetQosWithResponse call
func ParseSlurmdbV0043GetQosResponse(rsp *http.Response) (*SlurmdbV0043GetQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043PostQosResponse parses an HTTP response from a SlurmdbV0043PostQosWithResponse call
func ParseSlurmdbV0043PostQosResponse(rsp *http.Response) (*SlurmdbV0043PostQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043PostQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043DeleteSingleQosResponse parses an HTTP response from a SlurmdbV0043DeleteSingleQosWithResponse call
func ParseSlurmdbV0043DeleteSingleQosResponse(rsp *http.Response) (*SlurmdbV0043DeleteSingleQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043DeleteSingleQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiSlurmdbdQosRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiSlurmdbdQosRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetSingleQosResponse parses an HTTP response from a SlurmdbV0043GetSingleQosWithResponse call
func ParseSlurmdbV0043GetSingleQosResponse(rsp *http.Response) (*SlurmdbV0043GetSingleQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetSingleQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetTresResponse parses an HTTP response from a SlurmdbV0043GetTresWithResponse call
func ParseSlurmdbV0043GetTresResponse(rsp *http.Response) (*SlurmdbV0043GetTresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetTresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiTresResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiTresResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043PostTresResponse parses an HTTP response from a SlurmdbV0043PostTresWithResponse call
func ParseSlurmdbV0043PostTresResponse(rsp *http.Response) (*SlurmdbV0043PostTresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043PostTresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043DeleteUserResponse parses an HTTP response from a SlurmdbV0043DeleteUserWithResponse call
func ParseSlurmdbV0043DeleteUserResponse(rsp *http.Response) (*SlurmdbV0043DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetUserResponse parses an HTTP response from a SlurmdbV0043GetUserWithResponse call
func ParseSlurmdbV0043GetUserResponse(rsp *http.Response) (*SlurmdbV0043GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetUsersResponse parses an HTTP response from a SlurmdbV0043GetUsersWithResponse call
func ParseSlurmdbV0043GetUsersResponse(rsp *http.Response) (*SlurmdbV0043GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043PostUsersResponse parses an HTTP response from a SlurmdbV0043PostUsersWithResponse call
func ParseSlurmdbV0043PostUsersResponse(rsp *http.Response) (*SlurmdbV0043PostUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043PostUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043PostUsersAssociationResponse parses an HTTP response from a SlurmdbV0043PostUsersAssociationWithResponse call
func ParseSlurmdbV0043PostUsersAssociationResponse(rsp *http.Response) (*SlurmdbV0043PostUsersAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043PostUsersAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiUsersAddCondRespStr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiUsersAddCondRespStr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043DeleteWckeyResponse parses an HTTP response from a SlurmdbV0043DeleteWckeyWithResponse call
func ParseSlurmdbV0043DeleteWckeyResponse(rsp *http.Response) (*SlurmdbV0043DeleteWckeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043DeleteWckeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiWckeyRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiWckeyRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetWckeyResponse parses an HTTP response from a SlurmdbV0043GetWckeyWithResponse call
func ParseSlurmdbV0043GetWckeyResponse(rsp *http.Response) (*SlurmdbV0043GetWckeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetWckeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043GetWckeysResponse parses an HTTP response from a SlurmdbV0043GetWckeysWithResponse call
func ParseSlurmdbV0043GetWckeysResponse(rsp *http.Response) (*SlurmdbV0043GetWckeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043GetWckeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0043PostWckeysResponse parses an HTTP response from a SlurmdbV0043PostWckeysWithResponse call
func ParseSlurmdbV0043PostWckeysResponse(rsp *http.Response) (*SlurmdbV0043PostWckeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0043PostWckeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0043OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"pWmEpN8CAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
